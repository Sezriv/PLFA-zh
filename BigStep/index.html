<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../public/css/style.css">
  
  <title>编程语言基础：Agda 语言描述 – BigStep</title>
  
  
  
</head>

    <body>
        <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="../">编程语言基础：Agda 语言描述</a>
        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="../">主页</a>
                <a class="page-link" href="../Announcements/">公告</a>
                <a class="page-link" href="../GettingStarted/">使用说明</a>
                <a class="page-link" href="../Citing/">引用</a>
                <a class="page-link" href="https://plfa.github.io/">English</a>
            </div>
        </nav>
    </div>
</header>

        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Confluence/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part2/BigStep.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Denotational/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

    <header class="post-header">
        <h1 class="post-title" id="bigstep">BigStep: Big-step semantics of untyped lambda calculus</h1>
    </header>
    <div class="post-content">
        <pre class="Agda"><a id="174" class="Keyword">module</a> <a id="181" href="../BigStep/" class="Module">plfa.part2.BigStep</a> <a id="200" class="Keyword">where</a>
</pre>
<h2 id="introduction">Introduction</h2>
<p>The call-by-name evaluation strategy is a deterministic method for computing the value of a program in the lambda calculus. That is, call-by-name produces a value if and only if beta reduction can reduce the program to a lambda abstraction. In this chapter we define call-by-name evaluation and prove the forward direction of this if-and-only-if. The backward direction is traditionally proved via Curry-Feys standardisation, which is quite complex. We give a sketch of that proof, due to Plotkin, but postpone the proof in Agda until after we have developed a denotational semantics for the lambda calculus, at which point the proof is an easy corollary of properties of the denotational semantics.</p>
<p>We present the call-by-name strategy as a relation between an input term and an output value. Such a relation is often called a <em>big-step semantics</em>, written <code>M ⇓ V</code>, as it relates the input term <code>M</code> directly to the final result <code>V</code>, in contrast to the small-step reduction relation, <code>M —→ M′</code>, that maps <code>M</code> to another term <code>M′</code> in which a single sub-computation has been completed.</p>
<h2 id="imports">Imports</h2>
<pre class="Agda"><a id="1332" class="Keyword">open</a> <a id="1337" class="Keyword">import</a> <a id="1344" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="1384" class="Keyword">using</a> <a id="1390" class="Symbol">(</a><a id="1391" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="1394" class="Symbol">;</a> <a id="1396" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1400" class="Symbol">;</a> <a id="1402" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1025" class="Function">trans</a><a id="1407" class="Symbol">;</a> <a id="1409" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a><a id="1412" class="Symbol">;</a> <a id="1414" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html#1396" class="Function">cong-app</a><a id="1422" class="Symbol">)</a>
<a id="1424" class="Keyword">open</a> <a id="1429" class="Keyword">import</a> <a id="1436" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html" class="Module">Data.Product</a> <a id="1449" class="Keyword">using</a> <a id="1455" class="Symbol">(</a><a id="1456" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">_×_</a><a id="1459" class="Symbol">;</a> <a id="1461" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#166" class="Record">Σ</a><a id="1462" class="Symbol">;</a> <a id="1464" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">Σ-syntax</a><a id="1472" class="Symbol">;</a> <a id="1474" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1369" class="Function">∃</a><a id="1475" class="Symbol">;</a> <a id="1477" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1788" class="Function">∃-syntax</a><a id="1485" class="Symbol">;</a> <a id="1487" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="1492" class="Symbol">;</a> <a id="1494" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="1499" class="Symbol">)</a>
  <a id="1503" class="Keyword">renaming</a> <a id="1512" class="Symbol">(</a><a id="1513" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="1517" class="Symbol">to</a> <a id="_,_"></a><a id="1520" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="1525" class="Symbol">)</a>
<a id="1527" class="Keyword">open</a> <a id="1532" class="Keyword">import</a> <a id="1539" href="https://agda.github.io/agda-stdlib/v1.3/Function.html" class="Module">Function</a> <a id="1548" class="Keyword">using</a> <a id="1554" class="Symbol">(</a><a id="1555" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">_∘_</a><a id="1558" class="Symbol">)</a>
<a id="1560" class="Keyword">open</a> <a id="1565" class="Keyword">import</a> <a id="1572" href="../Untyped/" class="Module">plfa.part2.Untyped</a>
  <a id="1593" class="Keyword">using</a> <a id="1599" class="Symbol">(</a><a id="1600" href="../Untyped/#3135" class="Datatype">Context</a><a id="1607" class="Symbol">;</a> <a id="1609" href="../Untyped/#4276" class="Datatype Operator">_⊢_</a><a id="1612" class="Symbol">;</a> <a id="1614" href="../Untyped/#3503" class="Datatype Operator">_∋_</a><a id="1617" class="Symbol">;</a> <a id="1619" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="1620" class="Symbol">;</a> <a id="1622" href="../Untyped/#3157" class="InductiveConstructor">∅</a><a id="1623" class="Symbol">;</a> <a id="1625" href="../Untyped/#3173" class="InductiveConstructor Operator">_,_</a><a id="1628" class="Symbol">;</a> <a id="1630" href="../Untyped/#3539" class="InductiveConstructor">Z</a><a id="1631" class="Symbol">;</a> <a id="1633" href="../Untyped/#3584" class="InductiveConstructor Operator">S_</a><a id="1635" class="Symbol">;</a> <a id="1637" href="../Untyped/#4312" class="InductiveConstructor Operator">`_</a><a id="1639" class="Symbol">;</a> <a id="1641" href="../Untyped/#5093" class="Function Operator">#_</a><a id="1643" class="Symbol">;</a> <a id="1645" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ_</a><a id="1647" class="Symbol">;</a> <a id="1649" href="../Untyped/#4424" class="InductiveConstructor Operator">_·_</a><a id="1652" class="Symbol">;</a>
  <a id="1656" href="../Untyped/#6945" class="Function">subst</a><a id="1661" class="Symbol">;</a> <a id="1663" href="../Untyped/#7357" class="Function">subst-zero</a><a id="1673" class="Symbol">;</a> <a id="1675" href="../Untyped/#6653" class="Function">exts</a><a id="1679" class="Symbol">;</a> <a id="1681" href="../Untyped/#6217" class="Function">rename</a><a id="1687" class="Symbol">;</a> <a id="1689" href="../Untyped/#10160" class="InductiveConstructor">β</a><a id="1690" class="Symbol">;</a> <a id="1692" href="../Untyped/#9980" class="InductiveConstructor">ξ₁</a><a id="1694" class="Symbol">;</a> <a id="1696" href="../Untyped/#10070" class="InductiveConstructor">ξ₂</a><a id="1698" class="Symbol">;</a> <a id="1700" href="../Untyped/#10268" class="InductiveConstructor">ζ</a><a id="1701" class="Symbol">;</a> <a id="1703" href="../Untyped/#9930" class="Datatype Operator">_—→_</a><a id="1707" class="Symbol">;</a> <a id="1709" href="../Untyped/#11050" class="Datatype Operator">_—↠_</a><a id="1713" class="Symbol">;</a> <a id="1715" href="../Untyped/#11156" class="InductiveConstructor Operator">_—→⟨_⟩_</a><a id="1722" class="Symbol">;</a> <a id="1724" href="../Untyped/#11100" class="InductiveConstructor Operator">_∎</a><a id="1726" class="Symbol">;</a>
  <a id="1730" href="../Untyped/#21711" class="Function">—↠-trans</a><a id="1738" class="Symbol">;</a> <a id="1740" href="../Untyped/#22877" class="Function">appL-cong</a><a id="1749" class="Symbol">)</a>
<a id="1751" class="Keyword">open</a> <a id="1756" class="Keyword">import</a> <a id="1763" href="../Substitution/" class="Module">plfa.part2.Substitution</a> <a id="1787" class="Keyword">using</a> <a id="1793" class="Symbol">(</a><a id="1794" href="../Substitution/#2405" class="Function">Subst</a><a id="1799" class="Symbol">;</a> <a id="1801" href="../Substitution/#3046" class="Function">ids</a><a id="1804" class="Symbol">)</a>
</pre>
<h2 id="environments">Environments</h2>
<p>To handle variables and function application, there is the choice between using substitution, as in <code>—→</code>, or to use an <em>environment</em>. An environment in call-by-name is a map from variables to closures, that is, to terms paired with their environments. We choose to use environments instead of substitution because the point of the call-by-name strategy is to be closer to an implementation of the language. Also, the denotational semantics introduced in later chapters uses environments and the proof of adequacy is made easier by aligning these choices.</p>
<p>We define environments and closures as follows.</p>
<pre class="Agda"><a id="ClosEnv"></a><a id="2437" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="2445" class="Symbol">:</a> <a id="2447" href="../Untyped/#3135" class="Datatype">Context</a> <a id="2455" class="Symbol">→</a> <a id="2457" class="PrimitiveType">Set</a>

<a id="2462" class="Keyword">data</a> <a id="Clos"></a><a id="2467" href="../BigStep/#2467" class="Datatype">Clos</a> <a id="2472" class="Symbol">:</a> <a id="2474" class="PrimitiveType">Set</a> <a id="2478" class="Keyword">where</a>
  <a id="Clos.clos"></a><a id="2486" href="../BigStep/#2486" class="InductiveConstructor">clos</a> <a id="2491" class="Symbol">:</a> <a id="2493" class="Symbol">∀{</a><a id="2495" href="../BigStep/#2495" class="Bound">Γ</a><a id="2496" class="Symbol">}</a> <a id="2498" class="Symbol">→</a> <a id="2500" class="Symbol">(</a><a id="2501" href="../BigStep/#2501" class="Bound">M</a> <a id="2503" class="Symbol">:</a> <a id="2505" href="../BigStep/#2495" class="Bound">Γ</a> <a id="2507" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="2509" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="2510" class="Symbol">)</a> <a id="2512" class="Symbol">→</a> <a id="2514" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="2522" href="../BigStep/#2495" class="Bound">Γ</a> <a id="2524" class="Symbol">→</a> <a id="2526" href="../BigStep/#2467" class="Datatype">Clos</a>

<a id="2532" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="2540" href="../BigStep/#2540" class="Bound">Γ</a> <a id="2542" class="Symbol">=</a> <a id="2544" class="Symbol">∀</a> <a id="2546" class="Symbol">(</a><a id="2547" href="../BigStep/#2547" class="Bound">x</a> <a id="2549" class="Symbol">:</a> <a id="2551" href="../BigStep/#2540" class="Bound">Γ</a> <a id="2553" href="../Untyped/#3503" class="Datatype Operator">∋</a> <a id="2555" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="2556" class="Symbol">)</a> <a id="2558" class="Symbol">→</a> <a id="2560" href="../BigStep/#2467" class="Datatype">Clos</a>
</pre>
<p>As usual, we have the empty environment, and we can extend an environment.</p>
<pre class="Agda"><a id="∅'"></a><a id="2650" href="../BigStep/#2650" class="Function">∅'</a> <a id="2653" class="Symbol">:</a> <a id="2655" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="2663" href="../Untyped/#3157" class="InductiveConstructor">∅</a>
<a id="2665" href="../BigStep/#2650" class="Function">∅'</a> <a id="2668" class="Symbol">()</a>

<a id="_,'_"></a><a id="2672" href="../BigStep/#2672" class="Function Operator">_,'_</a> <a id="2677" class="Symbol">:</a> <a id="2679" class="Symbol">∀</a> <a id="2681" class="Symbol">{</a><a id="2682" href="../BigStep/#2682" class="Bound">Γ</a><a id="2683" class="Symbol">}</a> <a id="2685" class="Symbol">→</a> <a id="2687" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="2695" href="../BigStep/#2682" class="Bound">Γ</a> <a id="2697" class="Symbol">→</a> <a id="2699" href="../BigStep/#2467" class="Datatype">Clos</a> <a id="2704" class="Symbol">→</a> <a id="2706" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="2714" class="Symbol">(</a><a id="2715" href="../BigStep/#2682" class="Bound">Γ</a> <a id="2717" href="../Untyped/#3173" class="InductiveConstructor Operator">,</a> <a id="2719" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="2720" class="Symbol">)</a>
<a id="2722" class="Symbol">(</a><a id="2723" href="../BigStep/#2723" class="Bound">γ</a> <a id="2725" href="../BigStep/#2672" class="Function Operator">,'</a> <a id="2728" href="../BigStep/#2728" class="Bound">c</a><a id="2729" class="Symbol">)</a> <a id="2731" href="../Untyped/#3539" class="InductiveConstructor">Z</a> <a id="2733" class="Symbol">=</a> <a id="2735" href="../BigStep/#2728" class="Bound">c</a>
<a id="2737" class="Symbol">(</a><a id="2738" href="../BigStep/#2738" class="Bound">γ</a> <a id="2740" href="../BigStep/#2672" class="Function Operator">,'</a> <a id="2743" href="../BigStep/#2743" class="Bound">c</a><a id="2744" class="Symbol">)</a> <a id="2746" class="Symbol">(</a><a id="2747" href="../Untyped/#3584" class="InductiveConstructor Operator">S</a> <a id="2749" href="../BigStep/#2749" class="Bound">x</a><a id="2750" class="Symbol">)</a> <a id="2752" class="Symbol">=</a> <a id="2754" href="../BigStep/#2738" class="Bound">γ</a> <a id="2756" href="../BigStep/#2749" class="Bound">x</a>
</pre>
<h2 id="big-step-evaluation">Big-step evaluation</h2>
<p>The big-step semantics is represented as a ternary relation, written <code>γ ⊢ M ⇓ V</code>, where <code>γ</code> is the environment, <code>M</code> is the input term, and <code>V</code> is the result value. A <em>value</em> is a closure whose term is a lambda abstraction.</p>
<pre class="Agda"><a id="3016" class="Keyword">data</a> <a id="_⊢_⇓_"></a><a id="3021" href="../BigStep/#3021" class="Datatype Operator">_⊢_⇓_</a> <a id="3027" class="Symbol">:</a> <a id="3029" class="Symbol">∀{</a><a id="3031" href="../BigStep/#3031" class="Bound">Γ</a><a id="3032" class="Symbol">}</a> <a id="3034" class="Symbol">→</a> <a id="3036" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="3044" href="../BigStep/#3031" class="Bound">Γ</a> <a id="3046" class="Symbol">→</a> <a id="3048" class="Symbol">(</a><a id="3049" href="../BigStep/#3031" class="Bound">Γ</a> <a id="3051" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="3053" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="3054" class="Symbol">)</a> <a id="3056" class="Symbol">→</a> <a id="3058" href="../BigStep/#2467" class="Datatype">Clos</a> <a id="3063" class="Symbol">→</a> <a id="3065" class="PrimitiveType">Set</a> <a id="3069" class="Keyword">where</a>

  <a id="_⊢_⇓_.⇓-var"></a><a id="3078" href="../BigStep/#3078" class="InductiveConstructor">⇓-var</a> <a id="3084" class="Symbol">:</a> <a id="3086" class="Symbol">∀{</a><a id="3088" href="../BigStep/#3088" class="Bound">Γ</a><a id="3089" class="Symbol">}{</a><a id="3091" href="../BigStep/#3091" class="Bound">γ</a> <a id="3093" class="Symbol">:</a> <a id="3095" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="3103" href="../BigStep/#3088" class="Bound">Γ</a><a id="3104" class="Symbol">}{</a><a id="3106" href="../BigStep/#3106" class="Bound">x</a> <a id="3108" class="Symbol">:</a> <a id="3110" href="../BigStep/#3088" class="Bound">Γ</a> <a id="3112" href="../Untyped/#3503" class="Datatype Operator">∋</a> <a id="3114" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="3115" class="Symbol">}{</a><a id="3117" href="../BigStep/#3117" class="Bound">Δ</a><a id="3118" class="Symbol">}{</a><a id="3120" href="../BigStep/#3120" class="Bound">δ</a> <a id="3122" class="Symbol">:</a> <a id="3124" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="3132" href="../BigStep/#3117" class="Bound">Δ</a><a id="3133" class="Symbol">}{</a><a id="3135" href="../BigStep/#3135" class="Bound">M</a> <a id="3137" class="Symbol">:</a> <a id="3139" href="../BigStep/#3117" class="Bound">Δ</a> <a id="3141" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="3143" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="3144" class="Symbol">}{</a><a id="3146" href="../BigStep/#3146" class="Bound">V</a><a id="3147" class="Symbol">}</a>
    <a id="3153" class="Symbol">→</a> <a id="3155" href="../BigStep/#3091" class="Bound">γ</a> <a id="3157" href="../BigStep/#3106" class="Bound">x</a> <a id="3159" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3161" href="../BigStep/#2486" class="InductiveConstructor">clos</a> <a id="3166" href="../BigStep/#3135" class="Bound">M</a> <a id="3168" href="../BigStep/#3120" class="Bound">δ</a>
    <a id="3174" class="Symbol">→</a> <a id="3176" href="../BigStep/#3120" class="Bound">δ</a> <a id="3178" href="../BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3180" href="../BigStep/#3135" class="Bound">M</a> <a id="3182" href="../BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3184" href="../BigStep/#3146" class="Bound">V</a>
      <a id="3192" class="Comment">-----------</a>
    <a id="3208" class="Symbol">→</a> <a id="3210" href="../BigStep/#3091" class="Bound">γ</a> <a id="3212" href="../BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3214" href="../Untyped/#4312" class="InductiveConstructor Operator">`</a> <a id="3216" href="../BigStep/#3106" class="Bound">x</a> <a id="3218" href="../BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3220" href="../BigStep/#3146" class="Bound">V</a>

  <a id="_⊢_⇓_.⇓-lam"></a><a id="3225" href="../BigStep/#3225" class="InductiveConstructor">⇓-lam</a> <a id="3231" class="Symbol">:</a> <a id="3233" class="Symbol">∀{</a><a id="3235" href="../BigStep/#3235" class="Bound">Γ</a><a id="3236" class="Symbol">}{</a><a id="3238" href="../BigStep/#3238" class="Bound">γ</a> <a id="3240" class="Symbol">:</a> <a id="3242" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="3250" href="../BigStep/#3235" class="Bound">Γ</a><a id="3251" class="Symbol">}{</a><a id="3253" href="../BigStep/#3253" class="Bound">M</a> <a id="3255" class="Symbol">:</a> <a id="3257" href="../BigStep/#3235" class="Bound">Γ</a> <a id="3259" href="../Untyped/#3173" class="InductiveConstructor Operator">,</a> <a id="3261" href="../Untyped/#2870" class="InductiveConstructor">★</a> <a id="3263" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="3265" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="3266" class="Symbol">}</a>
    <a id="3272" class="Symbol">→</a> <a id="3274" href="../BigStep/#3238" class="Bound">γ</a> <a id="3276" href="../BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3278" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="3280" href="../BigStep/#3253" class="Bound">M</a> <a id="3282" href="../BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3284" href="../BigStep/#2486" class="InductiveConstructor">clos</a> <a id="3289" class="Symbol">(</a><a id="3290" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="3292" href="../BigStep/#3253" class="Bound">M</a><a id="3293" class="Symbol">)</a> <a id="3295" href="../BigStep/#3238" class="Bound">γ</a>

  <a id="_⊢_⇓_.⇓-app"></a><a id="3300" href="../BigStep/#3300" class="InductiveConstructor">⇓-app</a> <a id="3306" class="Symbol">:</a> <a id="3308" class="Symbol">∀{</a><a id="3310" href="../BigStep/#3310" class="Bound">Γ</a><a id="3311" class="Symbol">}{</a><a id="3313" href="../BigStep/#3313" class="Bound">γ</a> <a id="3315" class="Symbol">:</a> <a id="3317" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="3325" href="../BigStep/#3310" class="Bound">Γ</a><a id="3326" class="Symbol">}{</a><a id="3328" href="../BigStep/#3328" class="Bound">L</a> <a id="3330" href="../BigStep/#3330" class="Bound">M</a> <a id="3332" class="Symbol">:</a> <a id="3334" href="../BigStep/#3310" class="Bound">Γ</a> <a id="3336" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="3338" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="3339" class="Symbol">}{</a><a id="3341" href="../BigStep/#3341" class="Bound">Δ</a><a id="3342" class="Symbol">}{</a><a id="3344" href="../BigStep/#3344" class="Bound">δ</a> <a id="3346" class="Symbol">:</a> <a id="3348" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="3356" href="../BigStep/#3341" class="Bound">Δ</a><a id="3357" class="Symbol">}{</a><a id="3359" href="../BigStep/#3359" class="Bound">N</a> <a id="3361" class="Symbol">:</a> <a id="3363" href="../BigStep/#3341" class="Bound">Δ</a> <a id="3365" href="../Untyped/#3173" class="InductiveConstructor Operator">,</a> <a id="3367" href="../Untyped/#2870" class="InductiveConstructor">★</a> <a id="3369" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="3371" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="3372" class="Symbol">}{</a><a id="3374" href="../BigStep/#3374" class="Bound">V</a><a id="3375" class="Symbol">}</a>
    <a id="3381" class="Symbol">→</a> <a id="3383" href="../BigStep/#3313" class="Bound">γ</a> <a id="3385" href="../BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3387" href="../BigStep/#3328" class="Bound">L</a> <a id="3389" href="../BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3391" href="../BigStep/#2486" class="InductiveConstructor">clos</a> <a id="3396" class="Symbol">(</a><a id="3397" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="3399" href="../BigStep/#3359" class="Bound">N</a><a id="3400" class="Symbol">)</a> <a id="3402" href="../BigStep/#3344" class="Bound">δ</a>   <a id="3406" class="Symbol">→</a>   <a id="3410" class="Symbol">(</a><a id="3411" href="../BigStep/#3344" class="Bound">δ</a> <a id="3413" href="../BigStep/#2672" class="Function Operator">,'</a> <a id="3416" href="../BigStep/#2486" class="InductiveConstructor">clos</a> <a id="3421" href="../BigStep/#3330" class="Bound">M</a> <a id="3423" href="../BigStep/#3313" class="Bound">γ</a><a id="3424" class="Symbol">)</a> <a id="3426" href="../BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3428" href="../BigStep/#3359" class="Bound">N</a> <a id="3430" href="../BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3432" href="../BigStep/#3374" class="Bound">V</a>
      <a id="3440" class="Comment">---------------------------------------------------</a>
    <a id="3496" class="Symbol">→</a> <a id="3498" href="../BigStep/#3313" class="Bound">γ</a> <a id="3500" href="../BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3502" href="../BigStep/#3328" class="Bound">L</a> <a id="3504" href="../Untyped/#4424" class="InductiveConstructor Operator">·</a> <a id="3506" href="../BigStep/#3330" class="Bound">M</a> <a id="3508" href="../BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3510" href="../BigStep/#3374" class="Bound">V</a>
</pre>
<ul>
<li><p>The <code>⇓-var</code> rule evaluates a variable by finding the associated closure in the environment and then evaluating the closure.</p></li>
<li><p>The <code>⇓-lam</code> rule turns a lambda abstraction into a closure by packaging it up with its environment.</p></li>
<li><p>The <code>⇓-app</code> rule performs function application by first evaluating the term <code>L</code> in operator position. If that produces a closure containing a lambda abstraction <code>ƛ N</code>, then we evaluate the body <code>N</code> in an environment extended with the argument <code>M</code>. Note that <code>M</code> is not evaluated in rule <code>⇓-app</code> because this is call-by-name and not call-by-value.</p></li>
</ul>
<h4 id="exercise-big-step-eg-practice">Exercise <code>big-step-eg</code> (practice)</h4>
<p>Show that <code>(ƛ ƛ # 1) · ((ƛ # 0 · # 0) · (ƛ # 0 · # 0))</code> terminates under big-step call-by-name evaluation.</p>
<pre class="Agda"><a id="4264" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="the-big-step-semantics-is-deterministic">The big-step semantics is deterministic</h2>
<p>If the big-step relation evaluates a term <code>M</code> to both <code>V</code> and <code>V′</code>, then <code>V</code> and <code>V′</code> must be identical. In other words, the call-by-name relation is a partial function. The proof is a straightforward induction on the two big-step derivations.</p>
<pre class="Agda"><a id="⇓-determ"></a><a id="4586" href="../BigStep/#4586" class="Function">⇓-determ</a> <a id="4595" class="Symbol">:</a> <a id="4597" class="Symbol">∀{</a><a id="4599" href="../BigStep/#4599" class="Bound">Γ</a><a id="4600" class="Symbol">}{</a><a id="4602" href="../BigStep/#4602" class="Bound">γ</a> <a id="4604" class="Symbol">:</a> <a id="4606" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="4614" href="../BigStep/#4599" class="Bound">Γ</a><a id="4615" class="Symbol">}{</a><a id="4617" href="../BigStep/#4617" class="Bound">M</a> <a id="4619" class="Symbol">:</a> <a id="4621" href="../BigStep/#4599" class="Bound">Γ</a> <a id="4623" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="4625" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="4626" class="Symbol">}{</a><a id="4628" href="../BigStep/#4628" class="Bound">V</a> <a id="4630" href="../BigStep/#4630" class="Bound">V'</a> <a id="4633" class="Symbol">:</a> <a id="4635" href="../BigStep/#2467" class="Datatype">Clos</a><a id="4639" class="Symbol">}</a>
  <a id="4643" class="Symbol">→</a> <a id="4645" href="../BigStep/#4602" class="Bound">γ</a> <a id="4647" href="../BigStep/#3021" class="Datatype Operator">⊢</a> <a id="4649" href="../BigStep/#4617" class="Bound">M</a> <a id="4651" href="../BigStep/#3021" class="Datatype Operator">⇓</a> <a id="4653" href="../BigStep/#4628" class="Bound">V</a> <a id="4655" class="Symbol">→</a> <a id="4657" href="../BigStep/#4602" class="Bound">γ</a> <a id="4659" href="../BigStep/#3021" class="Datatype Operator">⊢</a> <a id="4661" href="../BigStep/#4617" class="Bound">M</a> <a id="4663" href="../BigStep/#3021" class="Datatype Operator">⇓</a> <a id="4665" href="../BigStep/#4630" class="Bound">V'</a>
  <a id="4670" class="Symbol">→</a> <a id="4672" href="../BigStep/#4628" class="Bound">V</a> <a id="4674" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4676" href="../BigStep/#4630" class="Bound">V'</a>
<a id="4679" href="../BigStep/#4586" class="Function">⇓-determ</a> <a id="4688" class="Symbol">(</a><a id="4689" href="../BigStep/#3078" class="InductiveConstructor">⇓-var</a> <a id="4695" href="../BigStep/#4695" class="Bound">eq1</a> <a id="4699" href="../BigStep/#4699" class="Bound">mc</a><a id="4701" class="Symbol">)</a> <a id="4703" class="Symbol">(</a><a id="4704" href="../BigStep/#3078" class="InductiveConstructor">⇓-var</a> <a id="4710" href="../BigStep/#4710" class="Bound">eq2</a> <a id="4714" href="../BigStep/#4714" class="Bound">mc'</a><a id="4717" class="Symbol">)</a>
    <a id="4723" class="Keyword">with</a> <a id="4728" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1025" class="Function">trans</a> <a id="4734" class="Symbol">(</a><a id="4735" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a> <a id="4739" href="../BigStep/#4695" class="Bound">eq1</a><a id="4742" class="Symbol">)</a> <a id="4744" href="../BigStep/#4710" class="Bound">eq2</a>
<a id="4748" class="Symbol">...</a> <a id="4752" class="Symbol">|</a> <a id="4754" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="4759" class="Symbol">=</a> <a id="4761" href="../BigStep/#4586" class="Function">⇓-determ</a> <a id="4770" class="Bound">mc</a> <a id="4773" class="Bound">mc'</a>
<a id="4777" href="../BigStep/#4586" class="Function">⇓-determ</a> <a id="4786" href="../BigStep/#3225" class="InductiveConstructor">⇓-lam</a> <a id="4792" href="../BigStep/#3225" class="InductiveConstructor">⇓-lam</a> <a id="4798" class="Symbol">=</a> <a id="4800" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="4805" href="../BigStep/#4586" class="Function">⇓-determ</a> <a id="4814" class="Symbol">(</a><a id="4815" href="../BigStep/#3300" class="InductiveConstructor">⇓-app</a> <a id="4821" href="../BigStep/#4821" class="Bound">mc</a> <a id="4824" href="../BigStep/#4824" class="Bound">mc₁</a><a id="4827" class="Symbol">)</a> <a id="4829" class="Symbol">(</a><a id="4830" href="../BigStep/#3300" class="InductiveConstructor">⇓-app</a> <a id="4836" href="../BigStep/#4836" class="Bound">mc'</a> <a id="4840" href="../BigStep/#4840" class="Bound">mc''</a><a id="4844" class="Symbol">)</a>
    <a id="4850" class="Keyword">with</a> <a id="4855" href="../BigStep/#4586" class="Function">⇓-determ</a> <a id="4864" href="../BigStep/#4821" class="Bound">mc</a> <a id="4867" href="../BigStep/#4836" class="Bound">mc'</a>
<a id="4871" class="Symbol">...</a> <a id="4875" class="Symbol">|</a> <a id="4877" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="4882" class="Symbol">=</a> <a id="4884" href="../BigStep/#4586" class="Function">⇓-determ</a> <a id="4893" class="Bound">mc₁</a> <a id="4897" class="Bound">mc''</a>
</pre>
<h2 id="big-step-evaluation-implies-beta-reduction-to-a-lambda">Big-step evaluation implies beta reduction to a lambda</h2>
<p>If big-step evaluation produces a value, then the input term can reduce to a lambda abstraction by beta reduction:</p>
<pre><code>  ∅' ⊢ M ⇓ clos (ƛ N′) δ
  -----------------------------
→ Σ[ N ∈ ∅ , ★ ⊢ ★ ] (M —↠ ƛ N)</code></pre>
<p>The proof is by induction on the big-step derivation. As is often necessary, one must generalize the statement to get the induction to go through. In the case for <code>⇓-app</code> (function application), the argument is added to the environment, so the environment becomes non-empty. The corresponding β reduction substitutes the argument into the body of the lambda abstraction. So we generalize the lemma to allow an arbitrary environment <code>γ</code> and we add a premise that relates the environment <code>γ</code> to an equivalent substitution <code>σ</code>.</p>
<p>The case for <code>⇓-app</code> also requires that we strengthen the conclusion. In the case for <code>⇓-app</code> we have <code>γ ⊢ L ⇓ clos (λ N) δ</code> and the induction hypothesis gives us <code>L —↠ ƛ N′</code>, but we need to know that <code>N</code> and <code>N′</code> are equivalent. In particular, that <code>N′ ≡ subst τ N</code> where <code>τ</code> is the substitution that is equivalent to <code>δ</code>. Therefore we expand the conclusion of the statement, stating that the results are equivalent.</p>
<p>We make the two notions of equivalence precise by defining the following two mutually-recursive predicates <code>V ≈ M</code> and <code>γ ≈ₑ σ</code>.</p>
<pre class="Agda"><a id="_≈_"></a><a id="6265" href="../BigStep/#6265" class="Function Operator">_≈_</a> <a id="6269" class="Symbol">:</a> <a id="6271" href="../BigStep/#2467" class="Datatype">Clos</a> <a id="6276" class="Symbol">→</a> <a id="6278" class="Symbol">(</a><a id="6279" href="../Untyped/#3157" class="InductiveConstructor">∅</a> <a id="6281" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="6283" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="6284" class="Symbol">)</a> <a id="6286" class="Symbol">→</a> <a id="6288" class="PrimitiveType">Set</a>
<a id="_≈ₑ_"></a><a id="6292" href="../BigStep/#6292" class="Function Operator">_≈ₑ_</a> <a id="6297" class="Symbol">:</a> <a id="6299" class="Symbol">∀{</a><a id="6301" href="../BigStep/#6301" class="Bound">Γ</a><a id="6302" class="Symbol">}</a> <a id="6304" class="Symbol">→</a> <a id="6306" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="6314" href="../BigStep/#6301" class="Bound">Γ</a> <a id="6316" class="Symbol">→</a> <a id="6318" href="../Substitution/#2405" class="Function">Subst</a> <a id="6324" href="../BigStep/#6301" class="Bound">Γ</a> <a id="6326" href="../Untyped/#3157" class="InductiveConstructor">∅</a> <a id="6328" class="Symbol">→</a> <a id="6330" class="PrimitiveType">Set</a>

<a id="6335" class="Symbol">(</a><a id="6336" href="../BigStep/#2486" class="InductiveConstructor">clos</a> <a id="6341" class="Symbol">{</a><a id="6342" href="../BigStep/#6342" class="Bound">Γ</a><a id="6343" class="Symbol">}</a> <a id="6345" href="../BigStep/#6345" class="Bound">M</a> <a id="6347" href="../BigStep/#6347" class="Bound">γ</a><a id="6348" class="Symbol">)</a> <a id="6350" href="../BigStep/#6265" class="Function Operator">≈</a> <a id="6352" href="../BigStep/#6352" class="Bound">N</a> <a id="6354" class="Symbol">=</a> <a id="6356" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">Σ[</a> <a id="6359" href="../BigStep/#6359" class="Bound">σ</a> <a id="6361" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">∈</a> <a id="6363" href="../Substitution/#2405" class="Function">Subst</a> <a id="6369" href="../BigStep/#6342" class="Bound">Γ</a> <a id="6371" href="../Untyped/#3157" class="InductiveConstructor">∅</a> <a id="6373" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">]</a> <a id="6375" href="../BigStep/#6347" class="Bound">γ</a> <a id="6377" href="../BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="6380" href="../BigStep/#6359" class="Bound">σ</a> <a id="6382" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="6384" class="Symbol">(</a><a id="6385" href="../BigStep/#6352" class="Bound">N</a> <a id="6387" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="6389" href="../Untyped/#6945" class="Function">subst</a> <a id="6395" href="../BigStep/#6359" class="Bound">σ</a> <a id="6397" href="../BigStep/#6345" class="Bound">M</a><a id="6398" class="Symbol">)</a>

<a id="6401" href="../BigStep/#6401" class="Bound">γ</a> <a id="6403" href="../BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="6406" href="../BigStep/#6406" class="Bound">σ</a> <a id="6408" class="Symbol">=</a> <a id="6410" class="Symbol">∀{</a><a id="6412" href="../BigStep/#6412" class="Bound">x</a><a id="6413" class="Symbol">}</a> <a id="6415" class="Symbol">→</a> <a id="6417" class="Symbol">(</a><a id="6418" href="../BigStep/#6401" class="Bound">γ</a> <a id="6420" href="../BigStep/#6412" class="Bound">x</a><a id="6421" class="Symbol">)</a> <a id="6423" href="../BigStep/#6265" class="Function Operator">≈</a> <a id="6425" class="Symbol">(</a><a id="6426" href="../BigStep/#6406" class="Bound">σ</a> <a id="6428" href="../BigStep/#6412" class="Bound">x</a><a id="6429" class="Symbol">)</a>
</pre>
<p>We can now state the main lemma:</p>
<pre><code>If γ ⊢ M ⇓ V  and  γ ≈ₑ σ,
then  subst σ M —↠ N  and  V ≈ N  for some N.</code></pre>
<p>Before starting the proof, we establish a couple lemmas about equivalent environments and substitutions.</p>
<p>The empty environment is equivalent to the identity substitution <code>ids</code>, which we import from Chapter <a href="../Substitution/">Substitution</a>.</p>
<pre class="Agda"><a id="≈ₑ-id"></a><a id="6796" href="../BigStep/#6796" class="Function">≈ₑ-id</a> <a id="6802" class="Symbol">:</a> <a id="6804" href="../BigStep/#2650" class="Function">∅'</a> <a id="6807" href="../BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="6810" href="../Substitution/#3046" class="Function">ids</a>
<a id="6814" href="../BigStep/#6796" class="Function">≈ₑ-id</a> <a id="6820" class="Symbol">{()}</a>
</pre>
<p>Of course, applying the identity substitution to a term returns the same term.</p>
<pre class="Agda"><a id="sub-id"></a><a id="6914" href="../BigStep/#6914" class="Function">sub-id</a> <a id="6921" class="Symbol">:</a> <a id="6923" class="Symbol">∀{</a><a id="6925" href="../BigStep/#6925" class="Bound">Γ</a><a id="6926" class="Symbol">}</a> <a id="6928" class="Symbol">{</a><a id="6929" href="../BigStep/#6929" class="Bound">A</a><a id="6930" class="Symbol">}</a> <a id="6932" class="Symbol">{</a><a id="6933" href="../BigStep/#6933" class="Bound">M</a> <a id="6935" class="Symbol">:</a> <a id="6937" href="../BigStep/#6925" class="Bound">Γ</a> <a id="6939" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="6941" href="../BigStep/#6929" class="Bound">A</a><a id="6942" class="Symbol">}</a> <a id="6944" class="Symbol">→</a> <a id="6946" href="../Untyped/#6945" class="Function">subst</a> <a id="6952" href="../Substitution/#3046" class="Function">ids</a> <a id="6956" href="../BigStep/#6933" class="Bound">M</a> <a id="6958" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="6960" href="../BigStep/#6933" class="Bound">M</a>
<a id="6962" href="../BigStep/#6914" class="Function">sub-id</a> <a id="6969" class="Symbol">=</a> <a id="6971" href="../Substitution/#16936" class="Function">plfa.part2.Substitution.sub-id</a>
</pre>
<p>We define an auxiliary function for extending a substitution.</p>
<pre class="Agda"><a id="ext-subst"></a><a id="7075" href="../BigStep/#7075" class="Function">ext-subst</a> <a id="7085" class="Symbol">:</a> <a id="7087" class="Symbol">∀{</a><a id="7089" href="../BigStep/#7089" class="Bound">Γ</a> <a id="7091" href="../BigStep/#7091" class="Bound">Δ</a><a id="7092" class="Symbol">}</a> <a id="7094" class="Symbol">→</a> <a id="7096" href="../Substitution/#2405" class="Function">Subst</a> <a id="7102" href="../BigStep/#7089" class="Bound">Γ</a> <a id="7104" href="../BigStep/#7091" class="Bound">Δ</a> <a id="7106" class="Symbol">→</a> <a id="7108" href="../BigStep/#7091" class="Bound">Δ</a> <a id="7110" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="7112" href="../Untyped/#2870" class="InductiveConstructor">★</a> <a id="7114" class="Symbol">→</a> <a id="7116" href="../Substitution/#2405" class="Function">Subst</a> <a id="7122" class="Symbol">(</a><a id="7123" href="../BigStep/#7089" class="Bound">Γ</a> <a id="7125" href="../Untyped/#3173" class="InductiveConstructor Operator">,</a> <a id="7127" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="7128" class="Symbol">)</a> <a id="7130" href="../BigStep/#7091" class="Bound">Δ</a>
<a id="7132" href="../BigStep/#7075" class="Function">ext-subst</a><a id="7141" class="Symbol">{</a><a id="7142" href="../BigStep/#7142" class="Bound">Γ</a><a id="7143" class="Symbol">}{</a><a id="7145" href="../BigStep/#7145" class="Bound">Δ</a><a id="7146" class="Symbol">}</a> <a id="7148" href="../BigStep/#7148" class="Bound">σ</a> <a id="7150" href="../BigStep/#7150" class="Bound">N</a> <a id="7152" class="Symbol">{</a><a id="7153" href="../BigStep/#7153" class="Bound">A</a><a id="7154" class="Symbol">}</a> <a id="7156" class="Symbol">=</a> <a id="7158" href="../Untyped/#6945" class="Function">subst</a> <a id="7164" class="Symbol">(</a><a id="7165" href="../Untyped/#7357" class="Function">subst-zero</a> <a id="7176" href="../BigStep/#7150" class="Bound">N</a><a id="7177" class="Symbol">)</a> <a id="7179" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="7181" href="../Untyped/#6653" class="Function">exts</a> <a id="7186" href="../BigStep/#7148" class="Bound">σ</a>
</pre>
<p>The next lemma we need to prove states that if you start with an equivalent environment and substitution <code>γ ≈ₑ σ</code>, extending them with an equivalent closure and term <code>c ≈ N</code> produces an equivalent environment and substitution: <code>(γ ,' V) ≈ₑ (ext-subst σ N)</code>, or equivalently, <code>(γ ,' V) x ≈ₑ (ext-subst σ N) x</code> for any variable <code>x</code>. The proof will be by induction on <code>x</code> and for the induction step we need the following lemma, which states that applying the composition of <code>exts σ</code> and <code>subst-zero</code> to <code>S x</code> is the same as just <code>σ x</code>, which is a corollary of a theorem in Chapter <a href="../Substitution/">Substitution</a>.</p>
<pre class="Agda"><a id="subst-zero-exts"></a><a id="7808" href="../BigStep/#7808" class="Function">subst-zero-exts</a> <a id="7824" class="Symbol">:</a> <a id="7826" class="Symbol">∀{</a><a id="7828" href="../BigStep/#7828" class="Bound">Γ</a> <a id="7830" href="../BigStep/#7830" class="Bound">Δ</a><a id="7831" class="Symbol">}{</a><a id="7833" href="../BigStep/#7833" class="Bound">σ</a> <a id="7835" class="Symbol">:</a> <a id="7837" href="../Substitution/#2405" class="Function">Subst</a> <a id="7843" href="../BigStep/#7828" class="Bound">Γ</a> <a id="7845" href="../BigStep/#7830" class="Bound">Δ</a><a id="7846" class="Symbol">}{</a><a id="7848" href="../BigStep/#7848" class="Bound">B</a><a id="7849" class="Symbol">}{</a><a id="7851" href="../BigStep/#7851" class="Bound">M</a> <a id="7853" class="Symbol">:</a> <a id="7855" href="../BigStep/#7830" class="Bound">Δ</a> <a id="7857" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="7859" href="../BigStep/#7848" class="Bound">B</a><a id="7860" class="Symbol">}{</a><a id="7862" href="../BigStep/#7862" class="Bound">x</a> <a id="7864" class="Symbol">:</a> <a id="7866" href="../BigStep/#7828" class="Bound">Γ</a> <a id="7868" href="../Untyped/#3503" class="Datatype Operator">∋</a> <a id="7870" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="7871" class="Symbol">}</a>
  <a id="7875" class="Symbol">→</a> <a id="7877" class="Symbol">(</a><a id="7878" href="../Untyped/#6945" class="Function">subst</a> <a id="7884" class="Symbol">(</a><a id="7885" href="../Untyped/#7357" class="Function">subst-zero</a> <a id="7896" href="../BigStep/#7851" class="Bound">M</a><a id="7897" class="Symbol">)</a> <a id="7899" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="7901" href="../Untyped/#6653" class="Function">exts</a> <a id="7906" href="../BigStep/#7833" class="Bound">σ</a><a id="7907" class="Symbol">)</a> <a id="7909" class="Symbol">(</a><a id="7910" href="../Untyped/#3584" class="InductiveConstructor Operator">S</a> <a id="7912" href="../BigStep/#7862" class="Bound">x</a><a id="7913" class="Symbol">)</a> <a id="7915" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="7917" href="../BigStep/#7833" class="Bound">σ</a> <a id="7919" href="../BigStep/#7862" class="Bound">x</a>
<a id="7921" href="../BigStep/#7808" class="Function">subst-zero-exts</a> <a id="7937" class="Symbol">{</a><a id="7938" href="../BigStep/#7938" class="Bound">Γ</a><a id="7939" class="Symbol">}{</a><a id="7941" href="../BigStep/#7941" class="Bound">Δ</a><a id="7942" class="Symbol">}{</a><a id="7944" href="../BigStep/#7944" class="Bound">σ</a><a id="7945" class="Symbol">}{</a><a id="7947" href="../BigStep/#7947" class="Bound">B</a><a id="7948" class="Symbol">}{</a><a id="7950" href="../BigStep/#7950" class="Bound">M</a><a id="7951" class="Symbol">}{</a><a id="7953" href="../BigStep/#7953" class="Bound">x</a><a id="7954" class="Symbol">}</a> <a id="7956" class="Symbol">=</a>
   <a id="7961" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html#1396" class="Function">cong-app</a> <a id="7970" class="Symbol">(</a><a id="7971" href="../Substitution/#25159" class="Function">plfa.part2.Substitution.subst-zero-exts-cons</a><a id="8015" class="Symbol">{</a><a id="8016" class="Argument">σ</a> <a id="8018" class="Symbol">=</a> <a id="8020" href="../BigStep/#7944" class="Bound">σ</a><a id="8021" class="Symbol">})</a> <a id="8024" class="Symbol">(</a><a id="8025" href="../Untyped/#3584" class="InductiveConstructor Operator">S</a> <a id="8027" href="../BigStep/#7953" class="Bound">x</a><a id="8028" class="Symbol">)</a>
</pre>
<p>So the proof of <code>≈ₑ-ext</code> is as follows.</p>
<pre class="Agda"><a id="≈ₑ-ext"></a><a id="8080" href="../BigStep/#8080" class="Function">≈ₑ-ext</a> <a id="8087" class="Symbol">:</a> <a id="8089" class="Symbol">∀</a> <a id="8091" class="Symbol">{</a><a id="8092" href="../BigStep/#8092" class="Bound">Γ</a><a id="8093" class="Symbol">}</a> <a id="8095" class="Symbol">{</a><a id="8096" href="../BigStep/#8096" class="Bound">γ</a> <a id="8098" class="Symbol">:</a> <a id="8100" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="8108" href="../BigStep/#8092" class="Bound">Γ</a><a id="8109" class="Symbol">}</a> <a id="8111" class="Symbol">{</a><a id="8112" href="../BigStep/#8112" class="Bound">σ</a> <a id="8114" class="Symbol">:</a> <a id="8116" href="../Substitution/#2405" class="Function">Subst</a> <a id="8122" href="../BigStep/#8092" class="Bound">Γ</a> <a id="8124" href="../Untyped/#3157" class="InductiveConstructor">∅</a><a id="8125" class="Symbol">}</a> <a id="8127" class="Symbol">{</a><a id="8128" href="../BigStep/#8128" class="Bound">V</a><a id="8129" class="Symbol">}</a> <a id="8131" class="Symbol">{</a><a id="8132" href="../BigStep/#8132" class="Bound">N</a> <a id="8134" class="Symbol">:</a> <a id="8136" href="../Untyped/#3157" class="InductiveConstructor">∅</a> <a id="8138" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="8140" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="8141" class="Symbol">}</a>
  <a id="8145" class="Symbol">→</a> <a id="8147" href="../BigStep/#8096" class="Bound">γ</a> <a id="8149" href="../BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="8152" href="../BigStep/#8112" class="Bound">σ</a>  <a id="8155" class="Symbol">→</a>  <a id="8158" href="../BigStep/#8128" class="Bound">V</a> <a id="8160" href="../BigStep/#6265" class="Function Operator">≈</a> <a id="8162" href="../BigStep/#8132" class="Bound">N</a>
    <a id="8168" class="Comment">--------------------------</a>
  <a id="8197" class="Symbol">→</a> <a id="8199" class="Symbol">(</a><a id="8200" href="../BigStep/#8096" class="Bound">γ</a> <a id="8202" href="../BigStep/#2672" class="Function Operator">,'</a> <a id="8205" href="../BigStep/#8128" class="Bound">V</a><a id="8206" class="Symbol">)</a> <a id="8208" href="../BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="8211" class="Symbol">(</a><a id="8212" href="../BigStep/#7075" class="Function">ext-subst</a> <a id="8222" href="../BigStep/#8112" class="Bound">σ</a> <a id="8224" href="../BigStep/#8132" class="Bound">N</a><a id="8225" class="Symbol">)</a>
<a id="8227" href="../BigStep/#8080" class="Function">≈ₑ-ext</a> <a id="8234" class="Symbol">{</a><a id="8235" href="../BigStep/#8235" class="Bound">Γ</a><a id="8236" class="Symbol">}</a> <a id="8238" class="Symbol">{</a><a id="8239" href="../BigStep/#8239" class="Bound">γ</a><a id="8240" class="Symbol">}</a> <a id="8242" class="Symbol">{</a><a id="8243" href="../BigStep/#8243" class="Bound">σ</a><a id="8244" class="Symbol">}</a> <a id="8246" class="Symbol">{</a><a id="8247" href="../BigStep/#8247" class="Bound">V</a><a id="8248" class="Symbol">}</a> <a id="8250" class="Symbol">{</a><a id="8251" href="../BigStep/#8251" class="Bound">N</a><a id="8252" class="Symbol">}</a> <a id="8254" href="../BigStep/#8254" class="Bound">γ≈ₑσ</a> <a id="8259" href="../BigStep/#8259" class="Bound">V≈N</a> <a id="8263" class="Symbol">{</a><a id="8264" href="../Untyped/#3539" class="InductiveConstructor">Z</a><a id="8265" class="Symbol">}</a> <a id="8267" class="Symbol">=</a> <a id="8269" href="../BigStep/#8259" class="Bound">V≈N</a>
<a id="8273" href="../BigStep/#8080" class="Function">≈ₑ-ext</a> <a id="8280" class="Symbol">{</a><a id="8281" href="../BigStep/#8281" class="Bound">Γ</a><a id="8282" class="Symbol">}</a> <a id="8284" class="Symbol">{</a><a id="8285" href="../BigStep/#8285" class="Bound">γ</a><a id="8286" class="Symbol">}</a> <a id="8288" class="Symbol">{</a><a id="8289" href="../BigStep/#8289" class="Bound">σ</a><a id="8290" class="Symbol">}</a> <a id="8292" class="Symbol">{</a><a id="8293" href="../BigStep/#8293" class="Bound">V</a><a id="8294" class="Symbol">}</a> <a id="8296" class="Symbol">{</a><a id="8297" href="../BigStep/#8297" class="Bound">N</a><a id="8298" class="Symbol">}</a> <a id="8300" href="../BigStep/#8300" class="Bound">γ≈ₑσ</a> <a id="8305" href="../BigStep/#8305" class="Bound">V≈N</a> <a id="8309" class="Symbol">{</a><a id="8310" href="../Untyped/#3584" class="InductiveConstructor Operator">S</a> <a id="8312" href="../BigStep/#8312" class="Bound">x</a><a id="8313" class="Symbol">}</a>
  <a id="8317" class="Keyword">rewrite</a> <a id="8325" href="../BigStep/#7808" class="Function">subst-zero-exts</a> <a id="8341" class="Symbol">{</a><a id="8342" class="Argument">σ</a> <a id="8344" class="Symbol">=</a> <a id="8346" href="../BigStep/#8289" class="Bound">σ</a><a id="8347" class="Symbol">}{</a><a id="8349" class="Argument">M</a> <a id="8351" class="Symbol">=</a> <a id="8353" href="../BigStep/#8297" class="Bound">N</a><a id="8354" class="Symbol">}{</a><a id="8356" href="../BigStep/#8312" class="Bound">x</a><a id="8357" class="Symbol">}</a> <a id="8359" class="Symbol">=</a> <a id="8361" href="../BigStep/#8300" class="Bound">γ≈ₑσ</a>
</pre>
<p>We proceed by induction on the input variable.</p>
<ul>
<li><p>If it is <code>Z</code>, then we immediately conclude using the premise <code>V ≈ N</code>.</p></li>
<li><p>If it is <code>S x</code>, then we rewrite using the <code>subst-zero-exts</code> lemma and use the premise <code>γ ≈ₑ σ</code> to conclude.</p></li>
</ul>
<p>To prove the main lemma, we need another technical lemma about substitution. Applying one substitution after another is the same as composing the two substitutions and then applying them.</p>
<pre class="Agda"><a id="sub-sub"></a><a id="8803" href="../BigStep/#8803" class="Function">sub-sub</a> <a id="8811" class="Symbol">:</a> <a id="8813" class="Symbol">∀{</a><a id="8815" href="../BigStep/#8815" class="Bound">Γ</a> <a id="8817" href="../BigStep/#8817" class="Bound">Δ</a> <a id="8819" href="../BigStep/#8819" class="Bound">Σ</a><a id="8820" class="Symbol">}{</a><a id="8822" href="../BigStep/#8822" class="Bound">A</a><a id="8823" class="Symbol">}{</a><a id="8825" href="../BigStep/#8825" class="Bound">M</a> <a id="8827" class="Symbol">:</a> <a id="8829" href="../BigStep/#8815" class="Bound">Γ</a> <a id="8831" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="8833" href="../BigStep/#8822" class="Bound">A</a><a id="8834" class="Symbol">}</a> <a id="8836" class="Symbol">{</a><a id="8837" href="../BigStep/#8837" class="Bound">σ₁</a> <a id="8840" class="Symbol">:</a> <a id="8842" href="../Substitution/#2405" class="Function">Subst</a> <a id="8848" href="../BigStep/#8815" class="Bound">Γ</a> <a id="8850" href="../BigStep/#8817" class="Bound">Δ</a><a id="8851" class="Symbol">}{</a><a id="8853" href="../BigStep/#8853" class="Bound">σ₂</a> <a id="8856" class="Symbol">:</a> <a id="8858" href="../Substitution/#2405" class="Function">Subst</a> <a id="8864" href="../BigStep/#8817" class="Bound">Δ</a> <a id="8866" href="../BigStep/#8819" class="Bound">Σ</a><a id="8867" class="Symbol">}</a>
  <a id="8871" class="Symbol">→</a> <a id="8873" href="../Untyped/#6945" class="Function">subst</a> <a id="8879" href="../BigStep/#8853" class="Bound">σ₂</a> <a id="8882" class="Symbol">(</a><a id="8883" href="../Untyped/#6945" class="Function">subst</a> <a id="8889" href="../BigStep/#8837" class="Bound">σ₁</a> <a id="8892" href="../BigStep/#8825" class="Bound">M</a><a id="8893" class="Symbol">)</a> <a id="8895" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="8897" href="../Untyped/#6945" class="Function">subst</a> <a id="8903" class="Symbol">(</a><a id="8904" href="../Untyped/#6945" class="Function">subst</a> <a id="8910" href="../BigStep/#8853" class="Bound">σ₂</a> <a id="8913" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="8915" href="../BigStep/#8837" class="Bound">σ₁</a><a id="8917" class="Symbol">)</a> <a id="8919" href="../BigStep/#8825" class="Bound">M</a>
<a id="8921" href="../BigStep/#8803" class="Function">sub-sub</a> <a id="8929" class="Symbol">{</a><a id="8930" class="Argument">M</a> <a id="8932" class="Symbol">=</a> <a id="8934" href="../BigStep/#8934" class="Bound">M</a><a id="8935" class="Symbol">}</a> <a id="8937" class="Symbol">=</a> <a id="8939" href="../Substitution/#22929" class="Function">plfa.part2.Substitution.sub-sub</a> <a id="8971" class="Symbol">{</a><a id="8972" class="Argument">M</a> <a id="8974" class="Symbol">=</a> <a id="8976" href="../BigStep/#8934" class="Bound">M</a><a id="8977" class="Symbol">}</a>
</pre>
<p>We arive at the main lemma: if <code>M</code> big steps to a closure <code>V</code> in environment <code>γ</code>, and if <code>γ ≈ₑ σ</code>, then <code>subst σ M</code> reduces to some term <code>N</code> that is equivalent to <code>V</code>. We describe the proof below.</p>
<pre class="Agda"><a id="⇓→—↠×≈"></a><a id="9186" href="../BigStep/#9186" class="Function">⇓→—↠×≈</a> <a id="9193" class="Symbol">:</a> <a id="9195" class="Symbol">∀{</a><a id="9197" href="../BigStep/#9197" class="Bound">Γ</a><a id="9198" class="Symbol">}{</a><a id="9200" href="../BigStep/#9200" class="Bound">γ</a> <a id="9202" class="Symbol">:</a> <a id="9204" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="9212" href="../BigStep/#9197" class="Bound">Γ</a><a id="9213" class="Symbol">}{</a><a id="9215" href="../BigStep/#9215" class="Bound">σ</a> <a id="9217" class="Symbol">:</a> <a id="9219" href="../Substitution/#2405" class="Function">Subst</a> <a id="9225" href="../BigStep/#9197" class="Bound">Γ</a> <a id="9227" href="../Untyped/#3157" class="InductiveConstructor">∅</a><a id="9228" class="Symbol">}{</a><a id="9230" href="../BigStep/#9230" class="Bound">M</a> <a id="9232" class="Symbol">:</a> <a id="9234" href="../BigStep/#9197" class="Bound">Γ</a> <a id="9236" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="9238" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="9239" class="Symbol">}{</a><a id="9241" href="../BigStep/#9241" class="Bound">V</a> <a id="9243" class="Symbol">:</a> <a id="9245" href="../BigStep/#2467" class="Datatype">Clos</a><a id="9249" class="Symbol">}</a>
       <a id="9258" class="Symbol">→</a> <a id="9260" href="../BigStep/#9200" class="Bound">γ</a> <a id="9262" href="../BigStep/#3021" class="Datatype Operator">⊢</a> <a id="9264" href="../BigStep/#9230" class="Bound">M</a> <a id="9266" href="../BigStep/#3021" class="Datatype Operator">⇓</a> <a id="9268" href="../BigStep/#9241" class="Bound">V</a>  <a id="9271" class="Symbol">→</a>  <a id="9274" href="../BigStep/#9200" class="Bound">γ</a> <a id="9276" href="../BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="9279" href="../BigStep/#9215" class="Bound">σ</a>
         <a id="9290" class="Comment">---------------------------------------</a>
       <a id="9337" class="Symbol">→</a> <a id="9339" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">Σ[</a> <a id="9342" href="../BigStep/#9342" class="Bound">N</a> <a id="9344" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">∈</a> <a id="9346" href="../Untyped/#3157" class="InductiveConstructor">∅</a> <a id="9348" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="9350" href="../Untyped/#2870" class="InductiveConstructor">★</a> <a id="9352" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">]</a> <a id="9354" class="Symbol">(</a><a id="9355" href="../Untyped/#6945" class="Function">subst</a> <a id="9361" href="../BigStep/#9215" class="Bound">σ</a> <a id="9363" href="../BigStep/#9230" class="Bound">M</a> <a id="9365" href="../Untyped/#11050" class="Datatype Operator">—↠</a> <a id="9368" href="../BigStep/#9342" class="Bound">N</a><a id="9369" class="Symbol">)</a> <a id="9371" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="9373" href="../BigStep/#9241" class="Bound">V</a> <a id="9375" href="../BigStep/#6265" class="Function Operator">≈</a> <a id="9377" href="../BigStep/#9342" class="Bound">N</a>
<a id="9379" href="../BigStep/#9186" class="Function">⇓→—↠×≈</a> <a id="9386" class="Symbol">{</a><a id="9387" class="Argument">γ</a> <a id="9389" class="Symbol">=</a> <a id="9391" href="../BigStep/#9391" class="Bound">γ</a><a id="9392" class="Symbol">}</a> <a id="9394" class="Symbol">(</a><a id="9395" href="../BigStep/#3078" class="InductiveConstructor">⇓-var</a><a id="9400" class="Symbol">{</a><a id="9401" class="Argument">x</a> <a id="9403" class="Symbol">=</a> <a id="9405" href="../BigStep/#9405" class="Bound">x</a><a id="9406" class="Symbol">}</a> <a id="9408" href="../BigStep/#9408" class="Bound">γx≡Lδ</a> <a id="9414" href="../BigStep/#9414" class="Bound">δ⊢L⇓V</a><a id="9419" class="Symbol">)</a> <a id="9421" href="../BigStep/#9421" class="Bound">γ≈ₑσ</a>
    <a id="9430" class="Keyword">with</a> <a id="9435" href="../BigStep/#9391" class="Bound">γ</a> <a id="9437" href="../BigStep/#9405" class="Bound">x</a> <a id="9439" class="Symbol">|</a> <a id="9441" href="../BigStep/#9421" class="Bound">γ≈ₑσ</a> <a id="9446" class="Symbol">{</a><a id="9447" href="../BigStep/#9405" class="Bound">x</a><a id="9448" class="Symbol">}</a> <a id="9450" class="Symbol">|</a> <a id="9452" href="../BigStep/#9408" class="Bound">γx≡Lδ</a>
<a id="9458" class="Symbol">...</a> <a id="9462" class="Symbol">|</a> <a id="9464" href="../BigStep/#2486" class="InductiveConstructor">clos</a> <a id="9469" href="../BigStep/#9469" class="Bound">L</a> <a id="9471" href="../BigStep/#9471" class="Bound">δ</a> <a id="9473" class="Symbol">|</a> <a id="9475" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="9477" href="../BigStep/#9477" class="Bound">τ</a> <a id="9479" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="9481" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="9483" href="../BigStep/#9483" class="Bound">δ≈ₑτ</a> <a id="9488" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="9490" href="../BigStep/#9490" class="Bound">σx≡τL</a> <a id="9496" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="9498" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="9500" class="Symbol">|</a> <a id="9502" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
      <a id="9513" class="Keyword">with</a> <a id="9518" href="../BigStep/#9186" class="Function">⇓→—↠×≈</a><a id="9524" class="Symbol">{</a><a id="9525" class="Argument">σ</a> <a id="9527" class="Symbol">=</a> <a id="9529" href="../BigStep/#9477" class="Bound">τ</a><a id="9530" class="Symbol">}</a> <a id="9532" class="Bound">δ⊢L⇓V</a> <a id="9538" href="../BigStep/#9483" class="Bound">δ≈ₑτ</a>
<a id="9543" class="Symbol">...</a>   <a id="9549" class="Symbol">|</a> <a id="9551" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="9553" href="../BigStep/#9553" class="Bound">N</a> <a id="9555" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="9557" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="9559" href="../BigStep/#9559" class="Bound">τL—↠N</a> <a id="9565" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="9567" href="../BigStep/#9567" class="Bound">V≈N</a> <a id="9571" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="9573" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="9575" class="Keyword">rewrite</a> <a id="9583" class="Bound">σx≡τL</a> <a id="9589" class="Symbol">=</a>
        <a id="9599" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="9601" href="../BigStep/#9553" class="Bound">N</a> <a id="9603" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="9605" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="9607" href="../BigStep/#9559" class="Bound">τL—↠N</a> <a id="9613" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="9615" href="../BigStep/#9567" class="Bound">V≈N</a> <a id="9619" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="9621" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a>
<a id="9623" href="../BigStep/#9186" class="Function">⇓→—↠×≈</a> <a id="9630" class="Symbol">{</a><a id="9631" class="Argument">σ</a> <a id="9633" class="Symbol">=</a> <a id="9635" href="../BigStep/#9635" class="Bound">σ</a><a id="9636" class="Symbol">}</a> <a id="9638" class="Symbol">{</a><a id="9639" class="Argument">V</a> <a id="9641" class="Symbol">=</a> <a id="9643" href="../BigStep/#2486" class="InductiveConstructor">clos</a> <a id="9648" class="Symbol">(</a><a id="9649" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="9651" href="../BigStep/#9651" class="Bound">N</a><a id="9652" class="Symbol">)</a> <a id="9654" href="../BigStep/#9654" class="Bound">γ</a><a id="9655" class="Symbol">}</a> <a id="9657" class="Symbol">(</a><a id="9658" href="../BigStep/#3225" class="InductiveConstructor">⇓-lam</a><a id="9663" class="Symbol">)</a> <a id="9665" href="../BigStep/#9665" class="Bound">γ≈ₑσ</a> <a id="9670" class="Symbol">=</a>
    <a id="9676" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="9678" href="../Untyped/#6945" class="Function">subst</a> <a id="9684" href="../BigStep/#9635" class="Bound">σ</a> <a id="9686" class="Symbol">(</a><a id="9687" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="9689" href="../BigStep/#9651" class="Bound">N</a><a id="9690" class="Symbol">)</a> <a id="9692" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="9694" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="9696" href="../Untyped/#6945" class="Function">subst</a> <a id="9702" href="../BigStep/#9635" class="Bound">σ</a> <a id="9704" class="Symbol">(</a><a id="9705" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="9707" href="../BigStep/#9651" class="Bound">N</a><a id="9708" class="Symbol">)</a> <a id="9710" href="../Untyped/#11100" class="InductiveConstructor Operator">∎</a> <a id="9712" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="9714" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="9716" href="../BigStep/#9635" class="Bound">σ</a> <a id="9718" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="9720" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="9722" href="../BigStep/#9665" class="Bound">γ≈ₑσ</a> <a id="9727" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="9729" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="9734" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="9736" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="9738" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="9740" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a>
<a id="9742" href="../BigStep/#9186" class="Function">⇓→—↠×≈</a><a id="9748" class="Symbol">{</a><a id="9749" href="../BigStep/#9749" class="Bound">Γ</a><a id="9750" class="Symbol">}{</a><a id="9752" href="../BigStep/#9752" class="Bound">γ</a><a id="9753" class="Symbol">}</a> <a id="9755" class="Symbol">{</a><a id="9756" class="Argument">σ</a> <a id="9758" class="Symbol">=</a> <a id="9760" href="../BigStep/#9760" class="Bound">σ</a><a id="9761" class="Symbol">}</a> <a id="9763" class="Symbol">{</a><a id="9764" href="../BigStep/#9764" class="Bound">L</a> <a id="9766" href="../Untyped/#4424" class="InductiveConstructor Operator">·</a> <a id="9768" href="../BigStep/#9768" class="Bound">M</a><a id="9769" class="Symbol">}</a> <a id="9771" class="Symbol">{</a><a id="9772" href="../BigStep/#9772" class="Bound">V</a><a id="9773" class="Symbol">}</a> <a id="9775" class="Symbol">(</a><a id="9776" href="../BigStep/#3300" class="InductiveConstructor">⇓-app</a> <a id="9782" class="Symbol">{</a><a id="9783" class="Argument">N</a> <a id="9785" class="Symbol">=</a> <a id="9787" href="../BigStep/#9787" class="Bound">N</a><a id="9788" class="Symbol">}</a> <a id="9790" href="../BigStep/#9790" class="Bound">L⇓ƛNδ</a> <a id="9796" href="../BigStep/#9796" class="Bound">N⇓V</a><a id="9799" class="Symbol">)</a> <a id="9801" href="../BigStep/#9801" class="Bound">γ≈ₑσ</a>
    <a id="9810" class="Keyword">with</a> <a id="9815" href="../BigStep/#9186" class="Function">⇓→—↠×≈</a><a id="9821" class="Symbol">{</a><a id="9822" class="Argument">σ</a> <a id="9824" class="Symbol">=</a> <a id="9826" href="../BigStep/#9760" class="Bound">σ</a><a id="9827" class="Symbol">}</a> <a id="9829" href="../BigStep/#9790" class="Bound">L⇓ƛNδ</a> <a id="9835" href="../BigStep/#9801" class="Bound">γ≈ₑσ</a>
<a id="9840" class="Symbol">...</a> <a id="9844" class="Symbol">|</a> <a id="9846" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="9848" class="Symbol">_</a> <a id="9850" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="9852" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="9854" href="../BigStep/#9854" class="Bound">σL—↠ƛτN</a> <a id="9862" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="9864" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="9866" href="../BigStep/#9866" class="Bound">τ</a> <a id="9868" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="9870" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="9872" href="../BigStep/#9872" class="Bound">δ≈ₑτ</a> <a id="9877" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="9879" href="../BigStep/#9879" class="Bound">≡ƛτN</a> <a id="9884" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="9886" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="9888" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="9890" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="9892" class="Keyword">rewrite</a> <a id="9900" href="../BigStep/#9879" class="Bound">≡ƛτN</a>
      <a id="9911" class="Keyword">with</a> <a id="9916" href="../BigStep/#9186" class="Function">⇓→—↠×≈</a> <a id="9923" class="Symbol">{</a><a id="9924" class="Argument">σ</a> <a id="9926" class="Symbol">=</a> <a id="9928" href="../BigStep/#7075" class="Function">ext-subst</a> <a id="9938" href="../BigStep/#9866" class="Bound">τ</a> <a id="9940" class="Symbol">(</a><a id="9941" href="../Untyped/#6945" class="Function">subst</a> <a id="9947" class="Bound">σ</a> <a id="9949" class="Bound">M</a><a id="9950" class="Symbol">)}</a> <a id="9953" class="Bound">N⇓V</a>
             <a id="9970" class="Symbol">(λ</a> <a id="9973" class="Symbol">{</a><a id="9974" href="../BigStep/#9974" class="Bound">x</a><a id="9975" class="Symbol">}</a> <a id="9977" class="Symbol">→</a> <a id="9979" href="../BigStep/#8080" class="Function">≈ₑ-ext</a><a id="9985" class="Symbol">{</a><a id="9986" class="Argument">σ</a> <a id="9988" class="Symbol">=</a> <a id="9990" href="../BigStep/#9866" class="Bound">τ</a><a id="9991" class="Symbol">}</a> <a id="9993" href="../BigStep/#9872" class="Bound">δ≈ₑτ</a> <a id="9998" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="10000" class="Bound">σ</a> <a id="10002" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="10004" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="10006" class="Bound">γ≈ₑσ</a> <a id="10011" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="10013" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="10018" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="10020" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="10022" class="Symbol">{</a><a id="10023" href="../BigStep/#9974" class="Bound">x</a><a id="10024" class="Symbol">})</a>
           <a id="10038" class="Symbol">|</a> <a id="10040" href="../Untyped/#10160" class="InductiveConstructor">β</a><a id="10041" class="Symbol">{</a><a id="10042" href="../Untyped/#3157" class="InductiveConstructor">∅</a><a id="10043" class="Symbol">}{</a><a id="10045" href="../Untyped/#6945" class="Function">subst</a> <a id="10051" class="Symbol">(</a><a id="10052" href="../Untyped/#6653" class="Function">exts</a> <a id="10057" href="../BigStep/#9866" class="Bound">τ</a><a id="10058" class="Symbol">)</a> <a id="10060" class="Bound">N</a><a id="10061" class="Symbol">}{</a><a id="10063" href="../Untyped/#6945" class="Function">subst</a> <a id="10069" class="Bound">σ</a> <a id="10071" class="Bound">M</a><a id="10072" class="Symbol">}</a>
<a id="10074" class="Symbol">...</a>   <a id="10080" class="Symbol">|</a> <a id="10082" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="10084" href="../BigStep/#10084" class="Bound">N'</a> <a id="10087" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="10089" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="10091" href="../BigStep/#10091" class="Bound">—↠N'</a> <a id="10096" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="10098" href="../BigStep/#10098" class="Bound">V≈N'</a> <a id="10103" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="10105" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="10107" class="Symbol">|</a> <a id="10109" href="../BigStep/#10109" class="Bound">ƛτN·σM—→</a>
        <a id="10126" class="Keyword">rewrite</a> <a id="10134" href="../BigStep/#8803" class="Function">sub-sub</a><a id="10141" class="Symbol">{</a><a id="10142" class="Argument">M</a> <a id="10144" class="Symbol">=</a> <a id="10146" class="Bound">N</a><a id="10147" class="Symbol">}{</a><a id="10149" class="Argument">σ₁</a> <a id="10152" class="Symbol">=</a> <a id="10154" href="../Untyped/#6653" class="Function">exts</a> <a id="10159" class="Bound">τ</a><a id="10160" class="Symbol">}{</a><a id="10162" class="Argument">σ₂</a> <a id="10165" class="Symbol">=</a> <a id="10167" href="../Untyped/#7357" class="Function">subst-zero</a> <a id="10178" class="Symbol">(</a><a id="10179" href="../Untyped/#6945" class="Function">subst</a> <a id="10185" class="Bound">σ</a> <a id="10187" class="Bound">M</a><a id="10188" class="Symbol">)}</a> <a id="10191" class="Symbol">=</a>
        <a id="10201" class="Keyword">let</a> <a id="10205" href="../BigStep/#10205" class="Bound">rs</a> <a id="10208" class="Symbol">=</a> <a id="10210" class="Symbol">(</a><a id="10211" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="10213" href="../Untyped/#6945" class="Function">subst</a> <a id="10219" class="Symbol">(</a><a id="10220" href="../Untyped/#6653" class="Function">exts</a> <a id="10225" class="Bound">τ</a><a id="10226" class="Symbol">)</a> <a id="10228" class="Bound">N</a><a id="10229" class="Symbol">)</a> <a id="10231" href="../Untyped/#4424" class="InductiveConstructor Operator">·</a> <a id="10233" href="../Untyped/#6945" class="Function">subst</a> <a id="10239" class="Bound">σ</a> <a id="10241" class="Bound">M</a> <a id="10243" href="../Untyped/#11156" class="InductiveConstructor Operator">—→⟨</a> <a id="10247" href="../BigStep/#10109" class="Bound">ƛτN·σM—→</a> <a id="10256" href="../Untyped/#11156" class="InductiveConstructor Operator">⟩</a> <a id="10258" href="../BigStep/#10091" class="Bound">—↠N'</a> <a id="10263" class="Keyword">in</a>
        <a id="10274" class="Keyword">let</a> <a id="10278" href="../BigStep/#10278" class="Bound">g</a> <a id="10280" class="Symbol">=</a> <a id="10282" href="../Untyped/#21711" class="Function">—↠-trans</a> <a id="10291" class="Symbol">(</a><a id="10292" href="../Untyped/#22877" class="Function">appL-cong</a> <a id="10302" class="Bound">σL—↠ƛτN</a><a id="10309" class="Symbol">)</a> <a id="10311" href="../BigStep/#10205" class="Bound">rs</a> <a id="10314" class="Keyword">in</a>
        <a id="10325" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="10327" href="../BigStep/#10084" class="Bound">N'</a> <a id="10330" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="10332" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="10334" href="../BigStep/#10278" class="Bound">g</a> <a id="10336" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="10338" href="../BigStep/#10098" class="Bound">V≈N'</a> <a id="10343" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="10345" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a>
</pre>
<p>The proof is by induction on <code>γ ⊢ M ⇓ V</code>. We have three cases to consider.</p>
<ul>
<li><p>Case <code>⇓-var</code>. So we have <code>γ x ≡ clos L δ</code> and <code>δ ⊢ L ⇓ V</code>. We need to show that <code>subst σ x —↠ N</code> and <code>V ≈ N</code> for some <code>N</code>. The premise <code>γ ≈ₑ σ</code> tells us that <code>γ x ≈ σ x</code>, so <code>clos L δ ≈ σ x</code>. By the definition of <code>≈</code>, there exists a <code>τ</code> such that <code>δ ≈ₑ τ</code> and <code>σ x ≡ subst τ L</code>. Using <code>δ ⊢ L ⇓ V</code> and <code>δ ≈ₑ τ</code>, the induction hypothesis gives us <code>subst τ L —↠ N</code> and <code>V ≈ N</code> for some <code>N</code>. So we have shown that <code>subst σ x —↠ N</code> and <code>V ≈ N</code> for some <code>N</code>.</p></li>
<li><p>Case <code>⇓-lam</code>. We immediately have <code>subst σ (ƛ N) —↠ subst σ (ƛ N)</code> and <code>clos (subst σ (ƛ N)) γ ≈ subst σ (ƛ N)</code>.</p></li>
<li><p>Case <code>⇓-app</code>. Using <code>γ ⊢ L ⇓ clos N δ</code> and <code>γ ≈ₑ σ</code>, the induction hypothesis gives us</p>
<pre><code>  subst σ L —↠ ƛ subst (exts τ) N                                     (1)</code></pre>
<p>and <code>δ ≈ₑ τ</code> for some <code>τ</code>. From <code>γ≈ₑσ</code> we have <code>clos M γ ≈ subst σ M</code>. Then with <code>(δ ,' clos M γ) ⊢ N ⇓ V</code>, the induction hypothesis gives us <code>V ≈ N'</code> and</p>
<pre><code>  subst (subst (subst-zero (subst σ M)) ∘ (exts τ)) N —↠ N'         (2)</code></pre>
<p>Meanwhile, by <code>β</code>, we have</p>
<pre><code>  (ƛ subst (exts τ) N) · subst σ M
  —→ subst (subst-zero (subst σ M)) (subst (exts τ) N)</code></pre>
<p>which is the same as the following, by <code>sub-sub</code>.</p>
<pre><code>  (ƛ subst (exts τ) N) · subst σ M
  —→ subst (subst (subst-zero (subst σ M)) ∘ exts τ) N              (3)</code></pre>
<p>Using (3) and (2) we have</p>
<pre><code>  (ƛ subst (exts τ) N) · subst σ M —↠ N'                             (4)</code></pre>
<p>From (1) we have</p>
<pre><code>  subst σ L · subst σ M —↠ (ƛ subst (exts τ) N) · subst σ M</code></pre>
<p>which we combine with (4) to conclude that</p>
<pre><code>  subst σ L · subst σ M —↠ N'</code></pre></li>
</ul>
<p>With the main lemma complete, we establish the forward direction of the equivalence between the big-step semantics and beta reduction.</p>
<pre class="Agda"><a id="cbn→reduce"></a><a id="12167" href="../BigStep/#12167" class="Function">cbn→reduce</a> <a id="12178" class="Symbol">:</a>  <a id="12181" class="Symbol">∀{</a><a id="12183" href="../BigStep/#12183" class="Bound">M</a> <a id="12185" class="Symbol">:</a> <a id="12187" href="../Untyped/#3157" class="InductiveConstructor">∅</a> <a id="12189" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="12191" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="12192" class="Symbol">}{</a><a id="12194" href="../BigStep/#12194" class="Bound">Δ</a><a id="12195" class="Symbol">}{</a><a id="12197" href="../BigStep/#12197" class="Bound">δ</a> <a id="12199" class="Symbol">:</a> <a id="12201" href="../BigStep/#2437" class="Function">ClosEnv</a> <a id="12209" href="../BigStep/#12194" class="Bound">Δ</a><a id="12210" class="Symbol">}{</a><a id="12212" href="../BigStep/#12212" class="Bound">N′</a> <a id="12215" class="Symbol">:</a> <a id="12217" href="../BigStep/#12194" class="Bound">Δ</a> <a id="12219" href="../Untyped/#3173" class="InductiveConstructor Operator">,</a> <a id="12221" href="../Untyped/#2870" class="InductiveConstructor">★</a> <a id="12223" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="12225" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="12226" class="Symbol">}</a>
  <a id="12230" class="Symbol">→</a> <a id="12232" href="../BigStep/#2650" class="Function">∅'</a> <a id="12235" href="../BigStep/#3021" class="Datatype Operator">⊢</a> <a id="12237" href="../BigStep/#12183" class="Bound">M</a> <a id="12239" href="../BigStep/#3021" class="Datatype Operator">⇓</a> <a id="12241" href="../BigStep/#2486" class="InductiveConstructor">clos</a> <a id="12246" class="Symbol">(</a><a id="12247" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="12249" href="../BigStep/#12212" class="Bound">N′</a><a id="12251" class="Symbol">)</a> <a id="12253" href="../BigStep/#12197" class="Bound">δ</a>
    <a id="12259" class="Comment">-----------------------------</a>
  <a id="12291" class="Symbol">→</a> <a id="12293" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">Σ[</a> <a id="12296" href="../BigStep/#12296" class="Bound">N</a> <a id="12298" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">∈</a> <a id="12300" href="../Untyped/#3157" class="InductiveConstructor">∅</a> <a id="12302" href="../Untyped/#3173" class="InductiveConstructor Operator">,</a> <a id="12304" href="../Untyped/#2870" class="InductiveConstructor">★</a> <a id="12306" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="12308" href="../Untyped/#2870" class="InductiveConstructor">★</a> <a id="12310" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">]</a> <a id="12312" class="Symbol">(</a><a id="12313" href="../BigStep/#12183" class="Bound">M</a> <a id="12315" href="../Untyped/#11050" class="Datatype Operator">—↠</a> <a id="12318" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="12320" href="../BigStep/#12296" class="Bound">N</a><a id="12321" class="Symbol">)</a>
<a id="12323" href="../BigStep/#12167" class="Function">cbn→reduce</a> <a id="12334" class="Symbol">{</a><a id="12335" href="../BigStep/#12335" class="Bound">M</a><a id="12336" class="Symbol">}{</a><a id="12338" href="../BigStep/#12338" class="Bound">Δ</a><a id="12339" class="Symbol">}{</a><a id="12341" href="../BigStep/#12341" class="Bound">δ</a><a id="12342" class="Symbol">}{</a><a id="12344" href="../BigStep/#12344" class="Bound">N′</a><a id="12346" class="Symbol">}</a> <a id="12348" href="../BigStep/#12348" class="Bound">M⇓c</a>
    <a id="12356" class="Keyword">with</a> <a id="12361" href="../BigStep/#9186" class="Function">⇓→—↠×≈</a><a id="12367" class="Symbol">{</a><a id="12368" class="Argument">σ</a> <a id="12370" class="Symbol">=</a> <a id="12372" href="../Substitution/#3046" class="Function">ids</a><a id="12375" class="Symbol">}</a> <a id="12377" href="../BigStep/#12348" class="Bound">M⇓c</a> <a id="12381" href="../BigStep/#6796" class="Function">≈ₑ-id</a>
<a id="12387" class="Symbol">...</a> <a id="12391" class="Symbol">|</a> <a id="12393" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="12395" href="../BigStep/#12395" class="Bound">N</a> <a id="12397" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="12399" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="12401" href="../BigStep/#12401" class="Bound">rs</a> <a id="12404" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="12406" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="12408" href="../BigStep/#12408" class="Bound">σ</a> <a id="12410" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="12412" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="12414" href="../BigStep/#12414" class="Bound">h</a> <a id="12416" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="12418" href="../BigStep/#12418" class="Bound">eq2</a> <a id="12422" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="12424" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="12426" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="12428" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a> <a id="12430" class="Keyword">rewrite</a> <a id="12438" href="../BigStep/#6914" class="Function">sub-id</a><a id="12444" class="Symbol">{</a><a id="12445" class="Argument">M</a> <a id="12447" class="Symbol">=</a> <a id="12449" class="Bound">M</a><a id="12450" class="Symbol">}</a> <a id="12452" class="Symbol">|</a> <a id="12454" href="../BigStep/#12418" class="Bound">eq2</a> <a id="12458" class="Symbol">=</a>
      <a id="12466" href="../BigStep/#1520" class="InductiveConstructor Operator">⟨</a> <a id="12468" href="../Untyped/#6945" class="Function">subst</a> <a id="12474" class="Symbol">(</a><a id="12475" href="../Untyped/#6653" class="Function">exts</a> <a id="12480" href="../BigStep/#12408" class="Bound">σ</a><a id="12481" class="Symbol">)</a> <a id="12483" class="Bound">N′</a> <a id="12486" href="../BigStep/#1520" class="InductiveConstructor Operator">,</a> <a id="12488" href="../BigStep/#12401" class="Bound">rs</a> <a id="12491" href="../BigStep/#1520" class="InductiveConstructor Operator">⟩</a>
</pre>
<h4 id="exercise-big-alt-implies-multi-practice">Exercise <code>big-alt-implies-multi</code> (practice)</h4>
<p>Formulate an alternative big-step semantics, of the form <code>M ↓ N</code>, for call-by-name that uses substitution instead of environments. That is, the analogue of the application rule <code>⇓-app</code> should perform substitution, as in <code>N [ M ]</code>, instead of extending the environment with <code>M</code>. Prove that <code>M ↓ N</code> implies <code>M —↠ N</code>.</p>
<pre class="Agda"><a id="12869" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="beta-reduction-to-a-lambda-implies-big-step-evaluation">Beta reduction to a lambda implies big-step evaluation</h2>
<p>The proof of the backward direction, that beta reduction to a lambda implies that the call-by-name semantics produces a result, is more difficult to prove. The difficulty stems from reduction proceeding underneath lambda abstractions via the <code>ζ</code> rule. The call-by-name semantics does not reduce under lambda, so a straightforward proof by induction on the reduction sequence is impossible. In the article <em>Call-by-name, call-by-value, and the λ-calculus</em>, Plotkin proves the theorem in two steps, using two auxiliary reduction relations. The first step uses a classic technique called Curry-Feys standardisation. It relies on the notion of <em>standard reduction sequence</em>, which acts as a half-way point between full beta reduction and call-by-name by expanding call-by-name to also include reduction underneath lambda. Plotkin proves that <code>M</code> reduces to <code>L</code> if and only if <code>M</code> is related to <code>L</code> by a standard reduction sequence.</p>
<pre><code>Theorem 1 (Standardisation)
`M —↠ L` if and only if `M` goes to `L` via a standard reduction sequence.</code></pre>
<p>Plotkin then introduces <em>left reduction</em>, a small-step version of call-by-name and uses the above theorem to prove that beta reduction and left reduction are equivalent in the following sense.</p>
<pre><code>Corollary 1
`M —↠ ƛ N` if and only if `M` goes to `ƛ N′`, for some `N′`, by left reduction.</code></pre>
<p>The second step of the proof connects left reduction to call-by-name evaluation.</p>
<pre><code>Theorem 2
`M` left reduces to `ƛ N` if and only if `⊢ M ⇓ ƛ N`.</code></pre>
<p>(Plotkin’s call-by-name evaluator uses substitution instead of environments, which explains why the environment is omitted in <code>⊢ M ⇓ ƛ N</code> in the above theorem statement.)</p>
<p>Putting Corollary 1 and Theorem 2 together, Plotkin proves that call-by-name evaluation is equivalent to beta reduction.</p>
<pre><code>Corollary 2
`M —↠ ƛ N` if and only if `⊢ M ⇓ ƛ N′` for some `N′`.</code></pre>
<p>Plotkin also proves an analogous result for the λᵥ calculus, relating it to call-by-value evaluation. For a nice exposition of that proof, we recommend Chapter 5 of <em>Semantics Engineering with PLT Redex</em> by Felleisen, Findler, and Flatt.</p>
<p>Instead of proving the backwards direction via standardisation, as sketched above, we defer the proof until after we define a denotational semantics for the lambda calculus, at which point the proof of the backwards direction will fall out as a corollary to the soundness and adequacy of the denotational semantics.</p>
<h2 id="unicode">Unicode</h2>
<p>This chapter uses the following unicode:</p>
<pre><code>≈  U+2248  ALMOST EQUAL TO (\~~ or \approx)
ₑ  U+2091  LATIN SUBSCRIPT SMALL LETTER E (\_e)
⊢  U+22A2  RIGHT TACK (\|- or \vdash)
⇓  U+21DB  DOWNWARDS DOUBLE ARROW (\d= or \Downarrow)</code></pre>
    </div>
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Confluence/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part2/BigStep.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Denotational/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

</article>

            </div>
        </main>
        <footer class="site-footer h-card">
    <data class="u-url" href="../"></data>
    <div class="wrapper">
        <h2 class="footer-heading">编程语言基础：Agda 语言描述</h2>
        
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Philip Wadler</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wadler" title="wadler"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wadler</a></li>
    
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Wen Kokke</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wenkokke</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;wenkokke</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Jeremy G. Siek</li>
                    <li>
                        
                        <a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/jsiek" title="jsiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;jsiek</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;jeremysiek</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        
        This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
    </div>
</footer>

    </body>
</html>
