<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../public/css/style.css">
  
  <title>编程语言基础：Agda 语言描述 – BigStep</title>
  
  
  
</head>

    <body>
        <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="../">编程语言基础：Agda 语言描述</a>
        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="../">主页</a>
                <a class="page-link" href="../Announcements/">公告</a>
                <a class="page-link" href="../GettingStarted/">使用说明</a>
                <a class="page-link" href="../Citing/">引用</a>
                <a class="page-link" href="https://plfa.github.io/">English</a>
            </div>
        </nav>
    </div>
</header>

        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Confluence/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part2/BigStep.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Denotational/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

    <header class="post-header">
        <h1 class="post-title" id="bigstep">BigStep: 无类型 λ-演算的大步语义</h1>
    </header>
    <div class="post-content">
        <pre class="Agda"><a id="190" class="Keyword">module</a> <a id="197" href="../BigStep/" class="Module">plfa.part2.BigStep</a> <a id="216" class="Keyword">where</a>
</pre>
<!--
## Introduction
-->
<h2 id="简介">简介</h2>
<!--
The call-by-name evaluation strategy is a deterministic method for
computing the value of a program in the lambda calculus.  That is,
call-by-name produces a value if and only if beta reduction can reduce
the program to a lambda abstraction. In this chapter we define
call-by-name evaluation and prove the forward direction of this
if-and-only-if. The backward direction is traditionally proved via
Curry-Feys standardisation, which is quite complex.  We give a sketch
of that proof, due to Plotkin, but postpone the proof in Agda until
after we have developed a denotational semantics for the lambda
calculus, at which point the proof is an easy corollary of properties
of the denotational semantics.
-->
<p>传名调用求值策略（Call-by-name Evaluation Strategy）是在 λ-演算中计算程序值的一种确定性方法。 也就是说，传名调用能够求出值当且仅当 β-规约能将程序规约为一个 λ-抽象。 在这一章节，我们将定义传名调用求值并且证明这个等价命题的必要性。 充分性的部分较为复杂，通常通过 Curry-Feys 标准化证明。 根据 Plotkin 的工作，我们给出这个证明的概要， 但是由于这是指称语义的一个简单性质， 我们将在为 λ-演算发展出指称语义后在 Agda 中完整地证明它。</p>
<!--
We present the call-by-name strategy as a relation between an input
term and an output value. Such a relation is often called a _big-step
semantics_, written `M ⇓ V`, as it relates the input term `M` directly
to the final result `V`, in contrast to the small-step reduction
relation, `M —→ M′`, that maps `M` to another term `M′` in which a
single sub-computation has been completed.
-->
<p>我们将传名调用策略表示为一个输入表达式与输出值间的关系。 因为这样的关系将输入表达式 <code>M</code> 和最终结果 <code>V</code> 直接相联系， 它通常被叫做<strong>大步语义（Big-stepsemantics）</strong>，写做 <code>M ⇓ V</code>。 而小步规约关系则被写做 <code>M —→ M′</code>，它仅通过一步子计算来将 <code>M</code> 规约为另一个表达式 <code>M′</code>。</p>
<!--
## Imports
-->
<h2 id="导入">导入</h2>
<pre class="Agda"><a id="1816" class="Keyword">open</a> <a id="1821" class="Keyword">import</a> <a id="1828" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="1868" class="Keyword">using</a> <a id="1874" class="Symbol">(</a><a id="1875" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="1878" class="Symbol">;</a> <a id="1880" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1884" class="Symbol">;</a> <a id="1886" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1025" class="Function">trans</a><a id="1891" class="Symbol">;</a> <a id="1893" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a><a id="1896" class="Symbol">;</a> <a id="1898" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html#1396" class="Function">cong-app</a><a id="1906" class="Symbol">)</a>
<a id="1908" class="Keyword">open</a> <a id="1913" class="Keyword">import</a> <a id="1920" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html" class="Module">Data.Product</a> <a id="1933" class="Keyword">using</a> <a id="1939" class="Symbol">(</a><a id="1940" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">_×_</a><a id="1943" class="Symbol">;</a> <a id="1945" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#166" class="Record">Σ</a><a id="1946" class="Symbol">;</a> <a id="1948" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">Σ-syntax</a><a id="1956" class="Symbol">;</a> <a id="1958" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1369" class="Function">∃</a><a id="1959" class="Symbol">;</a> <a id="1961" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1788" class="Function">∃-syntax</a><a id="1969" class="Symbol">;</a> <a id="1971" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="1976" class="Symbol">;</a> <a id="1978" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="1983" class="Symbol">)</a>
  <a id="1987" class="Keyword">renaming</a> <a id="1996" class="Symbol">(</a><a id="1997" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="2001" class="Symbol">to</a> <a id="_,_"></a><a id="2004" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="2009" class="Symbol">)</a>
<a id="2011" class="Keyword">open</a> <a id="2016" class="Keyword">import</a> <a id="2023" href="https://agda.github.io/agda-stdlib/v1.3/Function.html" class="Module">Function</a> <a id="2032" class="Keyword">using</a> <a id="2038" class="Symbol">(</a><a id="2039" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">_∘_</a><a id="2042" class="Symbol">)</a>
<a id="2044" class="Keyword">open</a> <a id="2049" class="Keyword">import</a> <a id="2056" href="../Untyped/" class="Module">plfa.part2.Untyped</a>
  <a id="2077" class="Keyword">using</a> <a id="2083" class="Symbol">(</a><a id="2084" href="../Untyped/#3135" class="Datatype">Context</a><a id="2091" class="Symbol">;</a> <a id="2093" href="../Untyped/#4276" class="Datatype Operator">_⊢_</a><a id="2096" class="Symbol">;</a> <a id="2098" href="../Untyped/#3503" class="Datatype Operator">_∋_</a><a id="2101" class="Symbol">;</a> <a id="2103" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="2104" class="Symbol">;</a> <a id="2106" href="../Untyped/#3157" class="InductiveConstructor">∅</a><a id="2107" class="Symbol">;</a> <a id="2109" href="../Untyped/#3173" class="InductiveConstructor Operator">_,_</a><a id="2112" class="Symbol">;</a> <a id="2114" href="../Untyped/#3539" class="InductiveConstructor">Z</a><a id="2115" class="Symbol">;</a> <a id="2117" href="../Untyped/#3584" class="InductiveConstructor Operator">S_</a><a id="2119" class="Symbol">;</a> <a id="2121" href="../Untyped/#4312" class="InductiveConstructor Operator">`_</a><a id="2123" class="Symbol">;</a> <a id="2125" href="../Untyped/#5093" class="Function Operator">#_</a><a id="2127" class="Symbol">;</a> <a id="2129" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ_</a><a id="2131" class="Symbol">;</a> <a id="2133" href="../Untyped/#4424" class="InductiveConstructor Operator">_·_</a><a id="2136" class="Symbol">;</a>
  <a id="2140" href="../Untyped/#6945" class="Function">subst</a><a id="2145" class="Symbol">;</a> <a id="2147" href="../Untyped/#7357" class="Function">subst-zero</a><a id="2157" class="Symbol">;</a> <a id="2159" href="../Untyped/#6653" class="Function">exts</a><a id="2163" class="Symbol">;</a> <a id="2165" href="../Untyped/#6217" class="Function">rename</a><a id="2171" class="Symbol">;</a> <a id="2173" href="../Untyped/#10160" class="InductiveConstructor">β</a><a id="2174" class="Symbol">;</a> <a id="2176" href="../Untyped/#9980" class="InductiveConstructor">ξ₁</a><a id="2178" class="Symbol">;</a> <a id="2180" href="../Untyped/#10070" class="InductiveConstructor">ξ₂</a><a id="2182" class="Symbol">;</a> <a id="2184" href="../Untyped/#10268" class="InductiveConstructor">ζ</a><a id="2185" class="Symbol">;</a> <a id="2187" href="../Untyped/#9930" class="Datatype Operator">_—→_</a><a id="2191" class="Symbol">;</a> <a id="2193" href="../Untyped/#11050" class="Datatype Operator">_—↠_</a><a id="2197" class="Symbol">;</a> <a id="2199" href="../Untyped/#11156" class="InductiveConstructor Operator">_—→⟨_⟩_</a><a id="2206" class="Symbol">;</a> <a id="2208" href="../Untyped/#11100" class="InductiveConstructor Operator">_∎</a><a id="2210" class="Symbol">;</a>
  <a id="2214" href="../Untyped/#21711" class="Function">—↠-trans</a><a id="2222" class="Symbol">;</a> <a id="2224" href="../Untyped/#22877" class="Function">appL-cong</a><a id="2233" class="Symbol">)</a>
<a id="2235" class="Keyword">open</a> <a id="2240" class="Keyword">import</a> <a id="2247" href="../Substitution/" class="Module">plfa.part2.Substitution</a> <a id="2271" class="Keyword">using</a> <a id="2277" class="Symbol">(</a><a id="2278" href="../Substitution/#2405" class="Function">Subst</a><a id="2283" class="Symbol">;</a> <a id="2285" href="../Substitution/#3046" class="Function">ids</a><a id="2288" class="Symbol">)</a>
</pre>
<!--
## Environments
-->
<h2 id="环境">环境</h2>
<!--
To handle variables and function applications, there is the choice
between using substitution, as in `—→`, or to use an _environment_.
An environment in call-by-name is a map from variables to closures,
that is, to terms paired with their environments. We choose to use
environments instead of substitution because the point of the
call-by-name strategy is to be closer to an implementation of the
language. Also, the denotational semantics introduced in later
chapters uses environments and the proof of adequacy
is made easier by aligning these choices.
-->
<p>为了处理变量和函数应用，我们要么像在 <code>—→</code> 中一样使用替换，要么使用一个<strong>环境（Environment）</strong>。 传名调用中的环境是一个从变量到闭包（即项与其对应的环境）的映射。 我们之所以使用环境取代替换是因为传名调用的核心更接近于语言的实现。 在后续章节中介绍的指称语义也会用到环境，而且对 adequacy 的证明也会变得更加容易。</p>
<!--
We define environments and closures as follows.
-->
<p>我们如下定义环境和闭包。</p>
<pre class="Agda"><a id="ClosEnv"></a><a id="3143" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="3151" class="Symbol">:</a> <a id="3153" href="../Untyped/#3135" class="Datatype">Context</a> <a id="3161" class="Symbol">→</a> <a id="3163" class="PrimitiveType">Set</a>

<a id="3168" class="Keyword">data</a> <a id="Clos"></a><a id="3173" href="../BigStep/#3173" class="Datatype">Clos</a> <a id="3178" class="Symbol">:</a> <a id="3180" class="PrimitiveType">Set</a> <a id="3184" class="Keyword">where</a>
  <a id="Clos.clos"></a><a id="3192" href="../BigStep/#3192" class="InductiveConstructor">clos</a> <a id="3197" class="Symbol">:</a> <a id="3199" class="Symbol">∀{</a><a id="3201" href="../BigStep/#3201" class="Bound">Γ</a><a id="3202" class="Symbol">}</a> <a id="3204" class="Symbol">→</a> <a id="3206" class="Symbol">(</a><a id="3207" href="../BigStep/#3207" class="Bound">M</a> <a id="3209" class="Symbol">:</a> <a id="3211" href="../BigStep/#3201" class="Bound">Γ</a> <a id="3213" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="3215" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="3216" class="Symbol">)</a> <a id="3218" class="Symbol">→</a> <a id="3220" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="3228" href="../BigStep/#3201" class="Bound">Γ</a> <a id="3230" class="Symbol">→</a> <a id="3232" href="../BigStep/#3173" class="Datatype">Clos</a>

<a id="3238" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="3246" href="../BigStep/#3246" class="Bound">Γ</a> <a id="3248" class="Symbol">=</a> <a id="3250" class="Symbol">∀</a> <a id="3252" class="Symbol">(</a><a id="3253" href="../BigStep/#3253" class="Bound">x</a> <a id="3255" class="Symbol">:</a> <a id="3257" href="../BigStep/#3246" class="Bound">Γ</a> <a id="3259" href="../Untyped/#3503" class="Datatype Operator">∋</a> <a id="3261" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="3262" class="Symbol">)</a> <a id="3264" class="Symbol">→</a> <a id="3266" href="../BigStep/#3173" class="Datatype">Clos</a>
</pre>
<!--
As usual, we have the empty environment, and we can extend an
environment.
-->
<p>通常，我们有空环境，也可以扩展一个环境。</p>
<pre class="Agda"><a id="∅'"></a><a id="3387" href="../BigStep/#3387" class="Function">∅'</a> <a id="3390" class="Symbol">:</a> <a id="3392" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="3400" href="../Untyped/#3157" class="InductiveConstructor">∅</a>
<a id="3402" href="../BigStep/#3387" class="Function">∅'</a> <a id="3405" class="Symbol">()</a>

<a id="_,'_"></a><a id="3409" href="../BigStep/#3409" class="Function Operator">_,'_</a> <a id="3414" class="Symbol">:</a> <a id="3416" class="Symbol">∀</a> <a id="3418" class="Symbol">{</a><a id="3419" href="../BigStep/#3419" class="Bound">Γ</a><a id="3420" class="Symbol">}</a> <a id="3422" class="Symbol">→</a> <a id="3424" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="3432" href="../BigStep/#3419" class="Bound">Γ</a> <a id="3434" class="Symbol">→</a> <a id="3436" href="../BigStep/#3173" class="Datatype">Clos</a> <a id="3441" class="Symbol">→</a> <a id="3443" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="3451" class="Symbol">(</a><a id="3452" href="../BigStep/#3419" class="Bound">Γ</a> <a id="3454" href="../Untyped/#3173" class="InductiveConstructor Operator">,</a> <a id="3456" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="3457" class="Symbol">)</a>
<a id="3459" class="Symbol">(</a><a id="3460" href="../BigStep/#3460" class="Bound">γ</a> <a id="3462" href="../BigStep/#3409" class="Function Operator">,'</a> <a id="3465" href="../BigStep/#3465" class="Bound">c</a><a id="3466" class="Symbol">)</a> <a id="3468" href="../Untyped/#3539" class="InductiveConstructor">Z</a> <a id="3470" class="Symbol">=</a> <a id="3472" href="../BigStep/#3465" class="Bound">c</a>
<a id="3474" class="Symbol">(</a><a id="3475" href="../BigStep/#3475" class="Bound">γ</a> <a id="3477" href="../BigStep/#3409" class="Function Operator">,'</a> <a id="3480" href="../BigStep/#3480" class="Bound">c</a><a id="3481" class="Symbol">)</a> <a id="3483" class="Symbol">(</a><a id="3484" href="../Untyped/#3584" class="InductiveConstructor Operator">S</a> <a id="3486" href="../BigStep/#3486" class="Bound">x</a><a id="3487" class="Symbol">)</a> <a id="3489" class="Symbol">=</a> <a id="3491" href="../BigStep/#3475" class="Bound">γ</a> <a id="3493" href="../BigStep/#3486" class="Bound">x</a>
</pre>
<!--
## Big-step evaluation
-->
<h2 id="大步求值">大步求值</h2>
<!--
The big-step semantics is represented as a ternary relation,
written `γ ⊢ M ⇓ V`, where `γ` is the environment, `M` is the input
term, and `V` is the result value.  A _value_ is a closure whose term
is a lambda abstraction.
-->
<p>大步语义被表现为一个三元关系，写作 <code>γ ⊢ M ⇓ V</code>， 其中 <code>γ</code> 是环境，<code>M</code>是输入项，<code>V</code> 是结果值。 <strong>值（Value）</strong> 是一个项是 λ-抽象的闭包。</p>
<pre class="Agda"><a id="3869" class="Keyword">data</a> <a id="_⊢_⇓_"></a><a id="3874" href="../BigStep/#3874" class="Datatype Operator">_⊢_⇓_</a> <a id="3880" class="Symbol">:</a> <a id="3882" class="Symbol">∀{</a><a id="3884" href="../BigStep/#3884" class="Bound">Γ</a><a id="3885" class="Symbol">}</a> <a id="3887" class="Symbol">→</a> <a id="3889" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="3897" href="../BigStep/#3884" class="Bound">Γ</a> <a id="3899" class="Symbol">→</a> <a id="3901" class="Symbol">(</a><a id="3902" href="../BigStep/#3884" class="Bound">Γ</a> <a id="3904" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="3906" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="3907" class="Symbol">)</a> <a id="3909" class="Symbol">→</a> <a id="3911" href="../BigStep/#3173" class="Datatype">Clos</a> <a id="3916" class="Symbol">→</a> <a id="3918" class="PrimitiveType">Set</a> <a id="3922" class="Keyword">where</a>

  <a id="_⊢_⇓_.⇓-var"></a><a id="3931" href="../BigStep/#3931" class="InductiveConstructor">⇓-var</a> <a id="3937" class="Symbol">:</a> <a id="3939" class="Symbol">∀{</a><a id="3941" href="../BigStep/#3941" class="Bound">Γ</a><a id="3942" class="Symbol">}{</a><a id="3944" href="../BigStep/#3944" class="Bound">γ</a> <a id="3946" class="Symbol">:</a> <a id="3948" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="3956" href="../BigStep/#3941" class="Bound">Γ</a><a id="3957" class="Symbol">}{</a><a id="3959" href="../BigStep/#3959" class="Bound">x</a> <a id="3961" class="Symbol">:</a> <a id="3963" href="../BigStep/#3941" class="Bound">Γ</a> <a id="3965" href="../Untyped/#3503" class="Datatype Operator">∋</a> <a id="3967" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="3968" class="Symbol">}{</a><a id="3970" href="../BigStep/#3970" class="Bound">Δ</a><a id="3971" class="Symbol">}{</a><a id="3973" href="../BigStep/#3973" class="Bound">δ</a> <a id="3975" class="Symbol">:</a> <a id="3977" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="3985" href="../BigStep/#3970" class="Bound">Δ</a><a id="3986" class="Symbol">}{</a><a id="3988" href="../BigStep/#3988" class="Bound">M</a> <a id="3990" class="Symbol">:</a> <a id="3992" href="../BigStep/#3970" class="Bound">Δ</a> <a id="3994" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="3996" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="3997" class="Symbol">}{</a><a id="3999" href="../BigStep/#3999" class="Bound">V</a><a id="4000" class="Symbol">}</a>
    <a id="4006" class="Symbol">→</a> <a id="4008" href="../BigStep/#3944" class="Bound">γ</a> <a id="4010" href="../BigStep/#3959" class="Bound">x</a> <a id="4012" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4014" href="../BigStep/#3192" class="InductiveConstructor">clos</a> <a id="4019" href="../BigStep/#3988" class="Bound">M</a> <a id="4021" href="../BigStep/#3973" class="Bound">δ</a>
    <a id="4027" class="Symbol">→</a> <a id="4029" href="../BigStep/#3973" class="Bound">δ</a> <a id="4031" href="../BigStep/#3874" class="Datatype Operator">⊢</a> <a id="4033" href="../BigStep/#3988" class="Bound">M</a> <a id="4035" href="../BigStep/#3874" class="Datatype Operator">⇓</a> <a id="4037" href="../BigStep/#3999" class="Bound">V</a>
      <a id="4045" class="Comment">-----------</a>
    <a id="4061" class="Symbol">→</a> <a id="4063" href="../BigStep/#3944" class="Bound">γ</a> <a id="4065" href="../BigStep/#3874" class="Datatype Operator">⊢</a> <a id="4067" href="../Untyped/#4312" class="InductiveConstructor Operator">`</a> <a id="4069" href="../BigStep/#3959" class="Bound">x</a> <a id="4071" href="../BigStep/#3874" class="Datatype Operator">⇓</a> <a id="4073" href="../BigStep/#3999" class="Bound">V</a>

  <a id="_⊢_⇓_.⇓-lam"></a><a id="4078" href="../BigStep/#4078" class="InductiveConstructor">⇓-lam</a> <a id="4084" class="Symbol">:</a> <a id="4086" class="Symbol">∀{</a><a id="4088" href="../BigStep/#4088" class="Bound">Γ</a><a id="4089" class="Symbol">}{</a><a id="4091" href="../BigStep/#4091" class="Bound">γ</a> <a id="4093" class="Symbol">:</a> <a id="4095" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="4103" href="../BigStep/#4088" class="Bound">Γ</a><a id="4104" class="Symbol">}{</a><a id="4106" href="../BigStep/#4106" class="Bound">M</a> <a id="4108" class="Symbol">:</a> <a id="4110" href="../BigStep/#4088" class="Bound">Γ</a> <a id="4112" href="../Untyped/#3173" class="InductiveConstructor Operator">,</a> <a id="4114" href="../Untyped/#2870" class="InductiveConstructor">★</a> <a id="4116" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="4118" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="4119" class="Symbol">}</a>
    <a id="4125" class="Symbol">→</a> <a id="4127" href="../BigStep/#4091" class="Bound">γ</a> <a id="4129" href="../BigStep/#3874" class="Datatype Operator">⊢</a> <a id="4131" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="4133" href="../BigStep/#4106" class="Bound">M</a> <a id="4135" href="../BigStep/#3874" class="Datatype Operator">⇓</a> <a id="4137" href="../BigStep/#3192" class="InductiveConstructor">clos</a> <a id="4142" class="Symbol">(</a><a id="4143" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="4145" href="../BigStep/#4106" class="Bound">M</a><a id="4146" class="Symbol">)</a> <a id="4148" href="../BigStep/#4091" class="Bound">γ</a>

  <a id="_⊢_⇓_.⇓-app"></a><a id="4153" href="../BigStep/#4153" class="InductiveConstructor">⇓-app</a> <a id="4159" class="Symbol">:</a> <a id="4161" class="Symbol">∀{</a><a id="4163" href="../BigStep/#4163" class="Bound">Γ</a><a id="4164" class="Symbol">}{</a><a id="4166" href="../BigStep/#4166" class="Bound">γ</a> <a id="4168" class="Symbol">:</a> <a id="4170" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="4178" href="../BigStep/#4163" class="Bound">Γ</a><a id="4179" class="Symbol">}{</a><a id="4181" href="../BigStep/#4181" class="Bound">L</a> <a id="4183" href="../BigStep/#4183" class="Bound">M</a> <a id="4185" class="Symbol">:</a> <a id="4187" href="../BigStep/#4163" class="Bound">Γ</a> <a id="4189" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="4191" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="4192" class="Symbol">}{</a><a id="4194" href="../BigStep/#4194" class="Bound">Δ</a><a id="4195" class="Symbol">}{</a><a id="4197" href="../BigStep/#4197" class="Bound">δ</a> <a id="4199" class="Symbol">:</a> <a id="4201" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="4209" href="../BigStep/#4194" class="Bound">Δ</a><a id="4210" class="Symbol">}{</a><a id="4212" href="../BigStep/#4212" class="Bound">N</a> <a id="4214" class="Symbol">:</a> <a id="4216" href="../BigStep/#4194" class="Bound">Δ</a> <a id="4218" href="../Untyped/#3173" class="InductiveConstructor Operator">,</a> <a id="4220" href="../Untyped/#2870" class="InductiveConstructor">★</a> <a id="4222" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="4224" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="4225" class="Symbol">}{</a><a id="4227" href="../BigStep/#4227" class="Bound">V</a><a id="4228" class="Symbol">}</a>
    <a id="4234" class="Symbol">→</a> <a id="4236" href="../BigStep/#4166" class="Bound">γ</a> <a id="4238" href="../BigStep/#3874" class="Datatype Operator">⊢</a> <a id="4240" href="../BigStep/#4181" class="Bound">L</a> <a id="4242" href="../BigStep/#3874" class="Datatype Operator">⇓</a> <a id="4244" href="../BigStep/#3192" class="InductiveConstructor">clos</a> <a id="4249" class="Symbol">(</a><a id="4250" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="4252" href="../BigStep/#4212" class="Bound">N</a><a id="4253" class="Symbol">)</a> <a id="4255" href="../BigStep/#4197" class="Bound">δ</a>   <a id="4259" class="Symbol">→</a>   <a id="4263" class="Symbol">(</a><a id="4264" href="../BigStep/#4197" class="Bound">δ</a> <a id="4266" href="../BigStep/#3409" class="Function Operator">,'</a> <a id="4269" href="../BigStep/#3192" class="InductiveConstructor">clos</a> <a id="4274" href="../BigStep/#4183" class="Bound">M</a> <a id="4276" href="../BigStep/#4166" class="Bound">γ</a><a id="4277" class="Symbol">)</a> <a id="4279" href="../BigStep/#3874" class="Datatype Operator">⊢</a> <a id="4281" href="../BigStep/#4212" class="Bound">N</a> <a id="4283" href="../BigStep/#3874" class="Datatype Operator">⇓</a> <a id="4285" href="../BigStep/#4227" class="Bound">V</a>
      <a id="4293" class="Comment">---------------------------------------------------</a>
    <a id="4349" class="Symbol">→</a> <a id="4351" href="../BigStep/#4166" class="Bound">γ</a> <a id="4353" href="../BigStep/#3874" class="Datatype Operator">⊢</a> <a id="4355" href="../BigStep/#4181" class="Bound">L</a> <a id="4357" href="../Untyped/#4424" class="InductiveConstructor Operator">·</a> <a id="4359" href="../BigStep/#4183" class="Bound">M</a> <a id="4361" href="../BigStep/#3874" class="Datatype Operator">⇓</a> <a id="4363" href="../BigStep/#4227" class="Bound">V</a>
</pre>
<!--
* The `⇓-var` rule evaluates a variable by finding the associated
  closure in the environment and then evaluating the closure.

* The `⇓-lam` rule turns a lambda abstraction into a closure
  by packaging it up with its environment.

* The `⇓-app` rule performs function application by first evaluating
  the term `L` in operator position. If that produces a closure containing
  a lambda abstraction `ƛ N`, then we evaluate the body `N` in an
  environment extended with the argument `M`. Note that `M` is not
  evaluated in rule `⇓-app` because this is call-by-name and not
  call-by-value.
-->
<ul>
<li><p><code>⇓-var</code> 规则通过对环境中找到的相关闭包求值，从而完成对变量的求值。</p></li>
<li><p><code>⇓-lam</code> 规则通过包装 λ-抽象与其环境，将其转变为一个闭包。</p></li>
<li><p><code>⇓-app</code> 规则分两步处理函数应用。首先对操作位的项 <code>L</code> 求值，如果产生了一个包含 λ-抽象 <code>ƛ N</code> 的闭包， 就在扩展了参数 <code>M</code> 的环境中对 <code>N</code> 求值。注意到 <code>M</code> 并未在 <code>⇓-app</code> 规则中被求值， 因为进行的是传名调用而不是传值调用。</p></li>
</ul>
<!--
#### Exercise `big-step-eg` (practice)
-->
<h4 id="练习-big-step-eg实践">练习 <code>big-step-eg</code>（实践）</h4>
<!--
Show that `(ƛ ƛ # 1) · ((ƛ # 0 · # 0) · (ƛ # 0 · # 0))`
terminates under big-step call-by-name evaluation.
-->
<p>证明 <code>(ƛ ƛ # 1) · ((ƛ # 0 · # 0) · (ƛ # 0 · # 0))</code> 能在大步传名调用求值下终止。</p>
<!--
<pre class="Agda"><a id="5462" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="5498" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
## The big-step semantics is deterministic
-->
<h2 id="大步语义是确定的">大步语义是确定的</h2>
<!--
If the big-step relation evaluates a term `M` to both `V` and
`V′`, then `V` and `V′` must be identical. In other words, the
call-by-name relation is a partial function. The proof is a
straightforward induction on the two big-step derivations.
-->
<p>如果大步关系将一个项 <code>M</code> 求值为 <code>V</code> 和 <code>V′</code>，则 <code>V</code> 和 <code>V′</code> 必然相同。 也就是说，传名调用关系是一个部分函数。该证明由两个大步语义的推论归纳得出。</p>
<pre class="Agda"><a id="⇓-determ"></a><a id="5928" href="../BigStep/#5928" class="Function">⇓-determ</a> <a id="5937" class="Symbol">:</a> <a id="5939" class="Symbol">∀{</a><a id="5941" href="../BigStep/#5941" class="Bound">Γ</a><a id="5942" class="Symbol">}{</a><a id="5944" href="../BigStep/#5944" class="Bound">γ</a> <a id="5946" class="Symbol">:</a> <a id="5948" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="5956" href="../BigStep/#5941" class="Bound">Γ</a><a id="5957" class="Symbol">}{</a><a id="5959" href="../BigStep/#5959" class="Bound">M</a> <a id="5961" class="Symbol">:</a> <a id="5963" href="../BigStep/#5941" class="Bound">Γ</a> <a id="5965" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="5967" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="5968" class="Symbol">}{</a><a id="5970" href="../BigStep/#5970" class="Bound">V</a> <a id="5972" href="../BigStep/#5972" class="Bound">V'</a> <a id="5975" class="Symbol">:</a> <a id="5977" href="../BigStep/#3173" class="Datatype">Clos</a><a id="5981" class="Symbol">}</a>
  <a id="5985" class="Symbol">→</a> <a id="5987" href="../BigStep/#5944" class="Bound">γ</a> <a id="5989" href="../BigStep/#3874" class="Datatype Operator">⊢</a> <a id="5991" href="../BigStep/#5959" class="Bound">M</a> <a id="5993" href="../BigStep/#3874" class="Datatype Operator">⇓</a> <a id="5995" href="../BigStep/#5970" class="Bound">V</a> <a id="5997" class="Symbol">→</a> <a id="5999" href="../BigStep/#5944" class="Bound">γ</a> <a id="6001" href="../BigStep/#3874" class="Datatype Operator">⊢</a> <a id="6003" href="../BigStep/#5959" class="Bound">M</a> <a id="6005" href="../BigStep/#3874" class="Datatype Operator">⇓</a> <a id="6007" href="../BigStep/#5972" class="Bound">V'</a>
  <a id="6012" class="Symbol">→</a> <a id="6014" href="../BigStep/#5970" class="Bound">V</a> <a id="6016" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="6018" href="../BigStep/#5972" class="Bound">V'</a>
<a id="6021" href="../BigStep/#5928" class="Function">⇓-determ</a> <a id="6030" class="Symbol">(</a><a id="6031" href="../BigStep/#3931" class="InductiveConstructor">⇓-var</a> <a id="6037" href="../BigStep/#6037" class="Bound">eq1</a> <a id="6041" href="../BigStep/#6041" class="Bound">mc</a><a id="6043" class="Symbol">)</a> <a id="6045" class="Symbol">(</a><a id="6046" href="../BigStep/#3931" class="InductiveConstructor">⇓-var</a> <a id="6052" href="../BigStep/#6052" class="Bound">eq2</a> <a id="6056" href="../BigStep/#6056" class="Bound">mc'</a><a id="6059" class="Symbol">)</a>
    <a id="6065" class="Keyword">with</a> <a id="6070" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1025" class="Function">trans</a> <a id="6076" class="Symbol">(</a><a id="6077" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a> <a id="6081" href="../BigStep/#6037" class="Bound">eq1</a><a id="6084" class="Symbol">)</a> <a id="6086" href="../BigStep/#6052" class="Bound">eq2</a>
<a id="6090" class="Symbol">...</a> <a id="6094" class="Symbol">|</a> <a id="6096" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="6101" class="Symbol">=</a> <a id="6103" href="../BigStep/#5928" class="Function">⇓-determ</a> <a id="6112" class="Bound">mc</a> <a id="6115" class="Bound">mc'</a>
<a id="6119" href="../BigStep/#5928" class="Function">⇓-determ</a> <a id="6128" href="../BigStep/#4078" class="InductiveConstructor">⇓-lam</a> <a id="6134" href="../BigStep/#4078" class="InductiveConstructor">⇓-lam</a> <a id="6140" class="Symbol">=</a> <a id="6142" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="6147" href="../BigStep/#5928" class="Function">⇓-determ</a> <a id="6156" class="Symbol">(</a><a id="6157" href="../BigStep/#4153" class="InductiveConstructor">⇓-app</a> <a id="6163" href="../BigStep/#6163" class="Bound">mc</a> <a id="6166" href="../BigStep/#6166" class="Bound">mc₁</a><a id="6169" class="Symbol">)</a> <a id="6171" class="Symbol">(</a><a id="6172" href="../BigStep/#4153" class="InductiveConstructor">⇓-app</a> <a id="6178" href="../BigStep/#6178" class="Bound">mc'</a> <a id="6182" href="../BigStep/#6182" class="Bound">mc''</a><a id="6186" class="Symbol">)</a>
    <a id="6192" class="Keyword">with</a> <a id="6197" href="../BigStep/#5928" class="Function">⇓-determ</a> <a id="6206" href="../BigStep/#6163" class="Bound">mc</a> <a id="6209" href="../BigStep/#6178" class="Bound">mc'</a>
<a id="6213" class="Symbol">...</a> <a id="6217" class="Symbol">|</a> <a id="6219" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="6224" class="Symbol">=</a> <a id="6226" href="../BigStep/#5928" class="Function">⇓-determ</a> <a id="6235" class="Bound">mc₁</a> <a id="6239" class="Bound">mc''</a>
</pre>
<!--
## Big-step evaluation implies beta reduction to a lambda
-->
<h2 id="大步求值蕴含-β-规约至-λ-抽象">大步求值蕴含 β-规约至 λ-抽象</h2>
<!--
If big-step evaluation produces a value, then the input term can
reduce to a lambda abstraction by beta reduction:
-->
<p>如果大步求值能够求出值，那么输入项能被 β-规约规约为一个 λ-抽象：</p>
<pre><code>  ∅' ⊢ M ⇓ clos (ƛ N′) δ
  -----------------------------
→ Σ[ N ∈ ∅ , ★ ⊢ ★ ] (M —↠ ƛ N)</code></pre>
<!--
The proof is by induction on the big-step derivation. As is often
necessary, one must generalize the statement to get the induction to
go through. In the case for `⇓-app` (function application), the
argument is added to the environment, so the environment becomes
non-empty. The corresponding β reduction substitutes the argument into
the body of the lambda abstraction.  So we generalize the lemma to
allow an arbitrary environment `γ` and we add a premise that relates
the environment `γ` to an equivalent substitution `σ`.
-->
<p>该证明通过对大步推导归纳来完成。通常，我们需要推广命题以完成归纳。 在 <code>⇓-app</code>（函数应用）的情况下，参数被添加到环境中，导致环境变得非空。 相应的 β-规约将参数替换进 λ-抽象的主体中。 所以我们将引理推广为允许任意环境 <code>γ</code> 并且添加一个前提将环境 <code>γ</code> 与等价的替代 <code>σ</code> 相关联。</p>
<!--
The case for `⇓-app` also requires that we strengthen the
conclusion. In the case for `⇓-app` we have `γ ⊢ L ⇓ clos (λ N) δ` and
the induction hypothesis gives us `L —↠ ƛ N′`, but we need to know
that `N` and `N′` are equivalent. In particular, that `N′ ≡ subst τ N`
where `τ` is the substitution that is equivalent to `δ`. Therefore we
expand the conclusion of the statement, stating that the results are
equivalent.
-->
<p><code>⇓-app</code> 的情况也要求我们加强结论。 对于 <code>⇓-app</code>，有 <code>γ ⊢ L ⇓ clos (λ N) δ</code> 以及归纳假设给我们 <code>L —↠ ƛ N′</code>， 但我们需要知道 <code>N</code> 和 <code>N′</code> 是等价的。 特别地，<code>N' ≡ subst τ N</code>，其中 <code>τ</code> 是等价于 <code>δ</code> 的替换。 因此我们扩展命题的结论，以说明这两个结果是等价的。</p>
<!--
We make the two notions of equivalence precise by defining the
following two mutually-recursive predicates `V ≈ M` and `γ ≈ₑ σ`.
-->
<p>我们通过定义以下两个相互递归的谓词 <code>V ≈ M</code> 和 <code>γ ≈ₑ σ</code> 来得到两个精确等价的概念</p>
<pre class="Agda"><a id="_≈_"></a><a id="8090" href="../BigStep/#8090" class="Function Operator">_≈_</a> <a id="8094" class="Symbol">:</a> <a id="8096" href="../BigStep/#3173" class="Datatype">Clos</a> <a id="8101" class="Symbol">→</a> <a id="8103" class="Symbol">(</a><a id="8104" href="../Untyped/#3157" class="InductiveConstructor">∅</a> <a id="8106" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="8108" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="8109" class="Symbol">)</a> <a id="8111" class="Symbol">→</a> <a id="8113" class="PrimitiveType">Set</a>
<a id="_≈ₑ_"></a><a id="8117" href="../BigStep/#8117" class="Function Operator">_≈ₑ_</a> <a id="8122" class="Symbol">:</a> <a id="8124" class="Symbol">∀{</a><a id="8126" href="../BigStep/#8126" class="Bound">Γ</a><a id="8127" class="Symbol">}</a> <a id="8129" class="Symbol">→</a> <a id="8131" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="8139" href="../BigStep/#8126" class="Bound">Γ</a> <a id="8141" class="Symbol">→</a> <a id="8143" href="../Substitution/#2405" class="Function">Subst</a> <a id="8149" href="../BigStep/#8126" class="Bound">Γ</a> <a id="8151" href="../Untyped/#3157" class="InductiveConstructor">∅</a> <a id="8153" class="Symbol">→</a> <a id="8155" class="PrimitiveType">Set</a>

<a id="8160" class="Symbol">(</a><a id="8161" href="../BigStep/#3192" class="InductiveConstructor">clos</a> <a id="8166" class="Symbol">{</a><a id="8167" href="../BigStep/#8167" class="Bound">Γ</a><a id="8168" class="Symbol">}</a> <a id="8170" href="../BigStep/#8170" class="Bound">M</a> <a id="8172" href="../BigStep/#8172" class="Bound">γ</a><a id="8173" class="Symbol">)</a> <a id="8175" href="../BigStep/#8090" class="Function Operator">≈</a> <a id="8177" href="../BigStep/#8177" class="Bound">N</a> <a id="8179" class="Symbol">=</a> <a id="8181" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">Σ[</a> <a id="8184" href="../BigStep/#8184" class="Bound">σ</a> <a id="8186" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">∈</a> <a id="8188" href="../Substitution/#2405" class="Function">Subst</a> <a id="8194" href="../BigStep/#8167" class="Bound">Γ</a> <a id="8196" href="../Untyped/#3157" class="InductiveConstructor">∅</a> <a id="8198" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">]</a> <a id="8200" href="../BigStep/#8172" class="Bound">γ</a> <a id="8202" href="../BigStep/#8117" class="Function Operator">≈ₑ</a> <a id="8205" href="../BigStep/#8184" class="Bound">σ</a> <a id="8207" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="8209" class="Symbol">(</a><a id="8210" href="../BigStep/#8177" class="Bound">N</a> <a id="8212" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="8214" href="../Untyped/#6945" class="Function">subst</a> <a id="8220" href="../BigStep/#8184" class="Bound">σ</a> <a id="8222" href="../BigStep/#8170" class="Bound">M</a><a id="8223" class="Symbol">)</a>

<a id="8226" href="../BigStep/#8226" class="Bound">γ</a> <a id="8228" href="../BigStep/#8117" class="Function Operator">≈ₑ</a> <a id="8231" href="../BigStep/#8231" class="Bound">σ</a> <a id="8233" class="Symbol">=</a> <a id="8235" class="Symbol">∀{</a><a id="8237" href="../BigStep/#8237" class="Bound">x</a><a id="8238" class="Symbol">}</a> <a id="8240" class="Symbol">→</a> <a id="8242" class="Symbol">(</a><a id="8243" href="../BigStep/#8226" class="Bound">γ</a> <a id="8245" href="../BigStep/#8237" class="Bound">x</a><a id="8246" class="Symbol">)</a> <a id="8248" href="../BigStep/#8090" class="Function Operator">≈</a> <a id="8250" class="Symbol">(</a><a id="8251" href="../BigStep/#8231" class="Bound">σ</a> <a id="8253" href="../BigStep/#8237" class="Bound">x</a><a id="8254" class="Symbol">)</a>
</pre>
<!--
We can now state the main lemma:
-->
<p>现在我们可以给出主要的引理。</p>
<!--
    If γ ⊢ M ⇓ V  and  γ ≈ₑ σ,
    then  subst σ M —↠ N  and  V ≈ N  for some N.
-->
<pre><code>如果 γ ⊢ M ⇓ V  且  γ ≈ₑ σ,
那么有  subst σ M —↠ N  以及  V ≈ N  对于某个 N。</code></pre>
<!--
Before starting the proof, we establish a couple lemmas
about equivalent environments and substitutions.
-->
<p>在开始证明之前，我们需要建立一些有关等价的环境和替换的引理。</p>
<!--
The empty environment is equivalent to the identity substitution
`ids`, which we import from Chapter [Substitution](/Substitution/).
-->
<p>空环境与我们从 <a href="../Substitution/">Substitution</a> 章中导入的恒等替换等价。</p>
<pre class="Agda"><a id="≈ₑ-id"></a><a id="8832" href="../BigStep/#8832" class="Function">≈ₑ-id</a> <a id="8838" class="Symbol">:</a> <a id="8840" href="../BigStep/#3387" class="Function">∅'</a> <a id="8843" href="../BigStep/#8117" class="Function Operator">≈ₑ</a> <a id="8846" href="../Substitution/#3046" class="Function">ids</a>
<a id="8850" href="../BigStep/#8832" class="Function">≈ₑ-id</a> <a id="8856" class="Symbol">{()}</a>
</pre>
<!--
Of course, applying the identity substitution to a term returns
the same term.
-->
<p>显然，对项应用恒等替换会得到相同的项。</p>
<pre class="Agda"><a id="sub-id"></a><a id="8980" href="../BigStep/#8980" class="Function">sub-id</a> <a id="8987" class="Symbol">:</a> <a id="8989" class="Symbol">∀{</a><a id="8991" href="../BigStep/#8991" class="Bound">Γ</a><a id="8992" class="Symbol">}</a> <a id="8994" class="Symbol">{</a><a id="8995" href="../BigStep/#8995" class="Bound">A</a><a id="8996" class="Symbol">}</a> <a id="8998" class="Symbol">{</a><a id="8999" href="../BigStep/#8999" class="Bound">M</a> <a id="9001" class="Symbol">:</a> <a id="9003" href="../BigStep/#8991" class="Bound">Γ</a> <a id="9005" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="9007" href="../BigStep/#8995" class="Bound">A</a><a id="9008" class="Symbol">}</a> <a id="9010" class="Symbol">→</a> <a id="9012" href="../Untyped/#6945" class="Function">subst</a> <a id="9018" href="../Substitution/#3046" class="Function">ids</a> <a id="9022" href="../BigStep/#8999" class="Bound">M</a> <a id="9024" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="9026" href="../BigStep/#8999" class="Bound">M</a>
<a id="9028" href="../BigStep/#8980" class="Function">sub-id</a> <a id="9035" class="Symbol">=</a> <a id="9037" href="../Substitution/#16936" class="Function">plfa.part2.Substitution.sub-id</a>
</pre>
<!--
We define an auxiliary function for extending a substitution.
-->
<p>我们定义一个辅助函数来扩展替换。</p>
<pre class="Agda"><a id="ext-subst"></a><a id="9167" href="../BigStep/#9167" class="Function">ext-subst</a> <a id="9177" class="Symbol">:</a> <a id="9179" class="Symbol">∀{</a><a id="9181" href="../BigStep/#9181" class="Bound">Γ</a> <a id="9183" href="../BigStep/#9183" class="Bound">Δ</a><a id="9184" class="Symbol">}</a> <a id="9186" class="Symbol">→</a> <a id="9188" href="../Substitution/#2405" class="Function">Subst</a> <a id="9194" href="../BigStep/#9181" class="Bound">Γ</a> <a id="9196" href="../BigStep/#9183" class="Bound">Δ</a> <a id="9198" class="Symbol">→</a> <a id="9200" href="../BigStep/#9183" class="Bound">Δ</a> <a id="9202" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="9204" href="../Untyped/#2870" class="InductiveConstructor">★</a> <a id="9206" class="Symbol">→</a> <a id="9208" href="../Substitution/#2405" class="Function">Subst</a> <a id="9214" class="Symbol">(</a><a id="9215" href="../BigStep/#9181" class="Bound">Γ</a> <a id="9217" href="../Untyped/#3173" class="InductiveConstructor Operator">,</a> <a id="9219" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="9220" class="Symbol">)</a> <a id="9222" href="../BigStep/#9183" class="Bound">Δ</a>
<a id="9224" href="../BigStep/#9167" class="Function">ext-subst</a><a id="9233" class="Symbol">{</a><a id="9234" href="../BigStep/#9234" class="Bound">Γ</a><a id="9235" class="Symbol">}{</a><a id="9237" href="../BigStep/#9237" class="Bound">Δ</a><a id="9238" class="Symbol">}</a> <a id="9240" href="../BigStep/#9240" class="Bound">σ</a> <a id="9242" href="../BigStep/#9242" class="Bound">N</a> <a id="9244" class="Symbol">{</a><a id="9245" href="../BigStep/#9245" class="Bound">A</a><a id="9246" class="Symbol">}</a> <a id="9248" class="Symbol">=</a> <a id="9250" href="../Untyped/#6945" class="Function">subst</a> <a id="9256" class="Symbol">(</a><a id="9257" href="../Untyped/#7357" class="Function">subst-zero</a> <a id="9268" href="../BigStep/#9242" class="Bound">N</a><a id="9269" class="Symbol">)</a> <a id="9271" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="9273" href="../Untyped/#6653" class="Function">exts</a> <a id="9278" href="../BigStep/#9240" class="Bound">σ</a>
</pre>
<!--
The next lemma we need to prove states that if you start with an
equivalent environment and substitution `γ ≈ₑ σ`, extending them with
an equivalent closure and term `c ≈ N` produces an equivalent
environment and substitution: `(γ ,' V) ≈ₑ (ext-subst σ N)`,
or equivalently, `(γ ,' V) x ≈ (ext-subst σ N) x` for any
variable `x`. The proof will be by induction on `x` and
for the induction step we need the following lemma,
which states that applying the composition of `exts σ`
and `subst-zero` to `S x` is the same as just `σ x`,
which is a corollary of a theorem in
Chapter [Substitution](/Substitution/).
-->
<p>下一个需要证明的引理声称如果从等价的环境和替换 <code>γ ≈ₑ σ</code> 开始， 将它们用等价的闭包和项 <code>c ≈ N</code> 扩展， 将得到等价的环境和替换 <code>(γ ,' V) ≈ₑ (ext-subst σ N)</code>， 即对于任何变量 <code>x</code> 有 <code>(γ ,' V) x ≈ₑ (ext-subst σ N) x</code>。 证明将通过归纳 <code>x</code> 完成，并且我们需要如下引理。 该引理声称将<code>exts σ</code> 和 <code>subst-zero</code> 的组合应用至 <code>S x</code> 等同于 <code>σ x</code>。 这是 <a href="../Substitution/">Substitution</a> 章节中一个定理的推论。</p>
<pre class="Agda"><a id="subst-zero-exts"></a><a id="10189" href="../BigStep/#10189" class="Function">subst-zero-exts</a> <a id="10205" class="Symbol">:</a> <a id="10207" class="Symbol">∀{</a><a id="10209" href="../BigStep/#10209" class="Bound">Γ</a> <a id="10211" href="../BigStep/#10211" class="Bound">Δ</a><a id="10212" class="Symbol">}{</a><a id="10214" href="../BigStep/#10214" class="Bound">σ</a> <a id="10216" class="Symbol">:</a> <a id="10218" href="../Substitution/#2405" class="Function">Subst</a> <a id="10224" href="../BigStep/#10209" class="Bound">Γ</a> <a id="10226" href="../BigStep/#10211" class="Bound">Δ</a><a id="10227" class="Symbol">}{</a><a id="10229" href="../BigStep/#10229" class="Bound">B</a><a id="10230" class="Symbol">}{</a><a id="10232" href="../BigStep/#10232" class="Bound">M</a> <a id="10234" class="Symbol">:</a> <a id="10236" href="../BigStep/#10211" class="Bound">Δ</a> <a id="10238" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="10240" href="../BigStep/#10229" class="Bound">B</a><a id="10241" class="Symbol">}{</a><a id="10243" href="../BigStep/#10243" class="Bound">x</a> <a id="10245" class="Symbol">:</a> <a id="10247" href="../BigStep/#10209" class="Bound">Γ</a> <a id="10249" href="../Untyped/#3503" class="Datatype Operator">∋</a> <a id="10251" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="10252" class="Symbol">}</a>
  <a id="10256" class="Symbol">→</a> <a id="10258" class="Symbol">(</a><a id="10259" href="../Untyped/#6945" class="Function">subst</a> <a id="10265" class="Symbol">(</a><a id="10266" href="../Untyped/#7357" class="Function">subst-zero</a> <a id="10277" href="../BigStep/#10232" class="Bound">M</a><a id="10278" class="Symbol">)</a> <a id="10280" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="10282" href="../Untyped/#6653" class="Function">exts</a> <a id="10287" href="../BigStep/#10214" class="Bound">σ</a><a id="10288" class="Symbol">)</a> <a id="10290" class="Symbol">(</a><a id="10291" href="../Untyped/#3584" class="InductiveConstructor Operator">S</a> <a id="10293" href="../BigStep/#10243" class="Bound">x</a><a id="10294" class="Symbol">)</a> <a id="10296" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="10298" href="../BigStep/#10214" class="Bound">σ</a> <a id="10300" href="../BigStep/#10243" class="Bound">x</a>
<a id="10302" href="../BigStep/#10189" class="Function">subst-zero-exts</a> <a id="10318" class="Symbol">{</a><a id="10319" href="../BigStep/#10319" class="Bound">Γ</a><a id="10320" class="Symbol">}{</a><a id="10322" href="../BigStep/#10322" class="Bound">Δ</a><a id="10323" class="Symbol">}{</a><a id="10325" href="../BigStep/#10325" class="Bound">σ</a><a id="10326" class="Symbol">}{</a><a id="10328" href="../BigStep/#10328" class="Bound">B</a><a id="10329" class="Symbol">}{</a><a id="10331" href="../BigStep/#10331" class="Bound">M</a><a id="10332" class="Symbol">}{</a><a id="10334" href="../BigStep/#10334" class="Bound">x</a><a id="10335" class="Symbol">}</a> <a id="10337" class="Symbol">=</a>
   <a id="10342" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html#1396" class="Function">cong-app</a> <a id="10351" class="Symbol">(</a><a id="10352" href="../Substitution/#25159" class="Function">plfa.part2.Substitution.subst-zero-exts-cons</a><a id="10396" class="Symbol">{</a><a id="10397" class="Argument">σ</a> <a id="10399" class="Symbol">=</a> <a id="10401" href="../BigStep/#10325" class="Bound">σ</a><a id="10402" class="Symbol">})</a> <a id="10405" class="Symbol">(</a><a id="10406" href="../Untyped/#3584" class="InductiveConstructor Operator">S</a> <a id="10408" href="../BigStep/#10334" class="Bound">x</a><a id="10409" class="Symbol">)</a>
</pre>
<!--
So the proof of `≈ₑ-ext` is as follows.
-->
<p>所以 <code>≈ₑ-ext</code> 的证明如下。</p>
<pre class="Agda"><a id="≈ₑ-ext"></a><a id="10490" href="../BigStep/#10490" class="Function">≈ₑ-ext</a> <a id="10497" class="Symbol">:</a> <a id="10499" class="Symbol">∀</a> <a id="10501" class="Symbol">{</a><a id="10502" href="../BigStep/#10502" class="Bound">Γ</a><a id="10503" class="Symbol">}</a> <a id="10505" class="Symbol">{</a><a id="10506" href="../BigStep/#10506" class="Bound">γ</a> <a id="10508" class="Symbol">:</a> <a id="10510" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="10518" href="../BigStep/#10502" class="Bound">Γ</a><a id="10519" class="Symbol">}</a> <a id="10521" class="Symbol">{</a><a id="10522" href="../BigStep/#10522" class="Bound">σ</a> <a id="10524" class="Symbol">:</a> <a id="10526" href="../Substitution/#2405" class="Function">Subst</a> <a id="10532" href="../BigStep/#10502" class="Bound">Γ</a> <a id="10534" href="../Untyped/#3157" class="InductiveConstructor">∅</a><a id="10535" class="Symbol">}</a> <a id="10537" class="Symbol">{</a><a id="10538" href="../BigStep/#10538" class="Bound">V</a><a id="10539" class="Symbol">}</a> <a id="10541" class="Symbol">{</a><a id="10542" href="../BigStep/#10542" class="Bound">N</a> <a id="10544" class="Symbol">:</a> <a id="10546" href="../Untyped/#3157" class="InductiveConstructor">∅</a> <a id="10548" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="10550" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="10551" class="Symbol">}</a>
  <a id="10555" class="Symbol">→</a> <a id="10557" href="../BigStep/#10506" class="Bound">γ</a> <a id="10559" href="../BigStep/#8117" class="Function Operator">≈ₑ</a> <a id="10562" href="../BigStep/#10522" class="Bound">σ</a>  <a id="10565" class="Symbol">→</a>  <a id="10568" href="../BigStep/#10538" class="Bound">V</a> <a id="10570" href="../BigStep/#8090" class="Function Operator">≈</a> <a id="10572" href="../BigStep/#10542" class="Bound">N</a>
    <a id="10578" class="Comment">--------------------------</a>
  <a id="10607" class="Symbol">→</a> <a id="10609" class="Symbol">(</a><a id="10610" href="../BigStep/#10506" class="Bound">γ</a> <a id="10612" href="../BigStep/#3409" class="Function Operator">,'</a> <a id="10615" href="../BigStep/#10538" class="Bound">V</a><a id="10616" class="Symbol">)</a> <a id="10618" href="../BigStep/#8117" class="Function Operator">≈ₑ</a> <a id="10621" class="Symbol">(</a><a id="10622" href="../BigStep/#9167" class="Function">ext-subst</a> <a id="10632" href="../BigStep/#10522" class="Bound">σ</a> <a id="10634" href="../BigStep/#10542" class="Bound">N</a><a id="10635" class="Symbol">)</a>
<a id="10637" href="../BigStep/#10490" class="Function">≈ₑ-ext</a> <a id="10644" class="Symbol">{</a><a id="10645" href="../BigStep/#10645" class="Bound">Γ</a><a id="10646" class="Symbol">}</a> <a id="10648" class="Symbol">{</a><a id="10649" href="../BigStep/#10649" class="Bound">γ</a><a id="10650" class="Symbol">}</a> <a id="10652" class="Symbol">{</a><a id="10653" href="../BigStep/#10653" class="Bound">σ</a><a id="10654" class="Symbol">}</a> <a id="10656" class="Symbol">{</a><a id="10657" href="../BigStep/#10657" class="Bound">V</a><a id="10658" class="Symbol">}</a> <a id="10660" class="Symbol">{</a><a id="10661" href="../BigStep/#10661" class="Bound">N</a><a id="10662" class="Symbol">}</a> <a id="10664" href="../BigStep/#10664" class="Bound">γ≈ₑσ</a> <a id="10669" href="../BigStep/#10669" class="Bound">V≈N</a> <a id="10673" class="Symbol">{</a><a id="10674" href="../Untyped/#3539" class="InductiveConstructor">Z</a><a id="10675" class="Symbol">}</a> <a id="10677" class="Symbol">=</a> <a id="10679" href="../BigStep/#10669" class="Bound">V≈N</a>
<a id="10683" href="../BigStep/#10490" class="Function">≈ₑ-ext</a> <a id="10690" class="Symbol">{</a><a id="10691" href="../BigStep/#10691" class="Bound">Γ</a><a id="10692" class="Symbol">}</a> <a id="10694" class="Symbol">{</a><a id="10695" href="../BigStep/#10695" class="Bound">γ</a><a id="10696" class="Symbol">}</a> <a id="10698" class="Symbol">{</a><a id="10699" href="../BigStep/#10699" class="Bound">σ</a><a id="10700" class="Symbol">}</a> <a id="10702" class="Symbol">{</a><a id="10703" href="../BigStep/#10703" class="Bound">V</a><a id="10704" class="Symbol">}</a> <a id="10706" class="Symbol">{</a><a id="10707" href="../BigStep/#10707" class="Bound">N</a><a id="10708" class="Symbol">}</a> <a id="10710" href="../BigStep/#10710" class="Bound">γ≈ₑσ</a> <a id="10715" href="../BigStep/#10715" class="Bound">V≈N</a> <a id="10719" class="Symbol">{</a><a id="10720" href="../Untyped/#3584" class="InductiveConstructor Operator">S</a> <a id="10722" href="../BigStep/#10722" class="Bound">x</a><a id="10723" class="Symbol">}</a>
  <a id="10727" class="Keyword">rewrite</a> <a id="10735" href="../BigStep/#10189" class="Function">subst-zero-exts</a> <a id="10751" class="Symbol">{</a><a id="10752" class="Argument">σ</a> <a id="10754" class="Symbol">=</a> <a id="10756" href="../BigStep/#10699" class="Bound">σ</a><a id="10757" class="Symbol">}{</a><a id="10759" class="Argument">M</a> <a id="10761" class="Symbol">=</a> <a id="10763" href="../BigStep/#10707" class="Bound">N</a><a id="10764" class="Symbol">}{</a><a id="10766" href="../BigStep/#10722" class="Bound">x</a><a id="10767" class="Symbol">}</a> <a id="10769" class="Symbol">=</a> <a id="10771" href="../BigStep/#10710" class="Bound">γ≈ₑσ</a>
</pre>
<!--
We proceed by induction on the input variable.
-->
<p>我们通过对输入项进行归纳来证明。</p>
<!--
* If it is `Z`, then we immediately conclude using the
  premise `V ≈ N`.

* If it is `S x`, then we rewrite using the
  `subst-zero-exts` lemma and use the premise `γ ≈ₑ σ`
  to conclude.
-->
<ul>
<li><p>如果它是 <code>Z</code>，那么我们使用前提 <code>V ≈ N</code> 立即得出结论。</p></li>
<li><p>如果它是 <code>S x</code>，那么我们使用 <code>subst-zero-exts</code> 引理来重写，并使用前提 <code>γ ≈ₑ σ</code> 来得出结论。</p></li>
</ul>
<!--
To prove the main lemma, we need another technical lemma about
substitution. Applying one substitution after another is the same as
composing the two substitutions and then applying them.
-->
<p>为了证明主要的引理，我们需要另一个关于替换的技术性的引理。 接连应用两个替换与先将两个替换连接起来再应用等价。</p>
<pre class="Agda"><a id="sub-sub"></a><a id="11419" href="../BigStep/#11419" class="Function">sub-sub</a> <a id="11427" class="Symbol">:</a> <a id="11429" class="Symbol">∀{</a><a id="11431" href="../BigStep/#11431" class="Bound">Γ</a> <a id="11433" href="../BigStep/#11433" class="Bound">Δ</a> <a id="11435" href="../BigStep/#11435" class="Bound">Σ</a><a id="11436" class="Symbol">}{</a><a id="11438" href="../BigStep/#11438" class="Bound">A</a><a id="11439" class="Symbol">}{</a><a id="11441" href="../BigStep/#11441" class="Bound">M</a> <a id="11443" class="Symbol">:</a> <a id="11445" href="../BigStep/#11431" class="Bound">Γ</a> <a id="11447" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="11449" href="../BigStep/#11438" class="Bound">A</a><a id="11450" class="Symbol">}</a> <a id="11452" class="Symbol">{</a><a id="11453" href="../BigStep/#11453" class="Bound">σ₁</a> <a id="11456" class="Symbol">:</a> <a id="11458" href="../Substitution/#2405" class="Function">Subst</a> <a id="11464" href="../BigStep/#11431" class="Bound">Γ</a> <a id="11466" href="../BigStep/#11433" class="Bound">Δ</a><a id="11467" class="Symbol">}{</a><a id="11469" href="../BigStep/#11469" class="Bound">σ₂</a> <a id="11472" class="Symbol">:</a> <a id="11474" href="../Substitution/#2405" class="Function">Subst</a> <a id="11480" href="../BigStep/#11433" class="Bound">Δ</a> <a id="11482" href="../BigStep/#11435" class="Bound">Σ</a><a id="11483" class="Symbol">}</a>
  <a id="11487" class="Symbol">→</a> <a id="11489" href="../Untyped/#6945" class="Function">subst</a> <a id="11495" href="../BigStep/#11469" class="Bound">σ₂</a> <a id="11498" class="Symbol">(</a><a id="11499" href="../Untyped/#6945" class="Function">subst</a> <a id="11505" href="../BigStep/#11453" class="Bound">σ₁</a> <a id="11508" href="../BigStep/#11441" class="Bound">M</a><a id="11509" class="Symbol">)</a> <a id="11511" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="11513" href="../Untyped/#6945" class="Function">subst</a> <a id="11519" class="Symbol">(</a><a id="11520" href="../Untyped/#6945" class="Function">subst</a> <a id="11526" href="../BigStep/#11469" class="Bound">σ₂</a> <a id="11529" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="11531" href="../BigStep/#11453" class="Bound">σ₁</a><a id="11533" class="Symbol">)</a> <a id="11535" href="../BigStep/#11441" class="Bound">M</a>
<a id="11537" href="../BigStep/#11419" class="Function">sub-sub</a> <a id="11545" class="Symbol">{</a><a id="11546" class="Argument">M</a> <a id="11548" class="Symbol">=</a> <a id="11550" href="../BigStep/#11550" class="Bound">M</a><a id="11551" class="Symbol">}</a> <a id="11553" class="Symbol">=</a> <a id="11555" href="../Substitution/#22929" class="Function">plfa.part2.Substitution.sub-sub</a> <a id="11587" class="Symbol">{</a><a id="11588" class="Argument">M</a> <a id="11590" class="Symbol">=</a> <a id="11592" href="../BigStep/#11550" class="Bound">M</a><a id="11593" class="Symbol">}</a>
</pre>
<!--
We arrive at the main lemma: if `M` big steps to a
closure `V` in environment `γ`, and if `γ ≈ₑ σ`, then `subst σ M` reduces
to some term `N` that is equivalent to `V`. We describe the proof
below.
-->
<p>我们到达了主要引理：如果 <code>M</code> 在环境 <code>γ</code> 中大步求值为闭包 <code>V</code>，并且 <code>γ ≈ₑ σ</code>， 那么 <code>subst σ M</code> 将规约为某个等价于 <code>V</code> 的项 <code>N</code>。我们如下叙述该证明。</p>
<pre class="Agda"><a id="⇓→—↠×≈"></a><a id="11911" href="../BigStep/#11911" class="Function">⇓→—↠×≈</a> <a id="11918" class="Symbol">:</a> <a id="11920" class="Symbol">∀{</a><a id="11922" href="../BigStep/#11922" class="Bound">Γ</a><a id="11923" class="Symbol">}{</a><a id="11925" href="../BigStep/#11925" class="Bound">γ</a> <a id="11927" class="Symbol">:</a> <a id="11929" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="11937" href="../BigStep/#11922" class="Bound">Γ</a><a id="11938" class="Symbol">}{</a><a id="11940" href="../BigStep/#11940" class="Bound">σ</a> <a id="11942" class="Symbol">:</a> <a id="11944" href="../Substitution/#2405" class="Function">Subst</a> <a id="11950" href="../BigStep/#11922" class="Bound">Γ</a> <a id="11952" href="../Untyped/#3157" class="InductiveConstructor">∅</a><a id="11953" class="Symbol">}{</a><a id="11955" href="../BigStep/#11955" class="Bound">M</a> <a id="11957" class="Symbol">:</a> <a id="11959" href="../BigStep/#11922" class="Bound">Γ</a> <a id="11961" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="11963" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="11964" class="Symbol">}{</a><a id="11966" href="../BigStep/#11966" class="Bound">V</a> <a id="11968" class="Symbol">:</a> <a id="11970" href="../BigStep/#3173" class="Datatype">Clos</a><a id="11974" class="Symbol">}</a>
       <a id="11983" class="Symbol">→</a> <a id="11985" href="../BigStep/#11925" class="Bound">γ</a> <a id="11987" href="../BigStep/#3874" class="Datatype Operator">⊢</a> <a id="11989" href="../BigStep/#11955" class="Bound">M</a> <a id="11991" href="../BigStep/#3874" class="Datatype Operator">⇓</a> <a id="11993" href="../BigStep/#11966" class="Bound">V</a>  <a id="11996" class="Symbol">→</a>  <a id="11999" href="../BigStep/#11925" class="Bound">γ</a> <a id="12001" href="../BigStep/#8117" class="Function Operator">≈ₑ</a> <a id="12004" href="../BigStep/#11940" class="Bound">σ</a>
         <a id="12015" class="Comment">---------------------------------------</a>
       <a id="12062" class="Symbol">→</a> <a id="12064" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">Σ[</a> <a id="12067" href="../BigStep/#12067" class="Bound">N</a> <a id="12069" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">∈</a> <a id="12071" href="../Untyped/#3157" class="InductiveConstructor">∅</a> <a id="12073" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="12075" href="../Untyped/#2870" class="InductiveConstructor">★</a> <a id="12077" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">]</a> <a id="12079" class="Symbol">(</a><a id="12080" href="../Untyped/#6945" class="Function">subst</a> <a id="12086" href="../BigStep/#11940" class="Bound">σ</a> <a id="12088" href="../BigStep/#11955" class="Bound">M</a> <a id="12090" href="../Untyped/#11050" class="Datatype Operator">—↠</a> <a id="12093" href="../BigStep/#12067" class="Bound">N</a><a id="12094" class="Symbol">)</a> <a id="12096" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="12098" href="../BigStep/#11966" class="Bound">V</a> <a id="12100" href="../BigStep/#8090" class="Function Operator">≈</a> <a id="12102" href="../BigStep/#12067" class="Bound">N</a>
<a id="12104" href="../BigStep/#11911" class="Function">⇓→—↠×≈</a> <a id="12111" class="Symbol">{</a><a id="12112" class="Argument">γ</a> <a id="12114" class="Symbol">=</a> <a id="12116" href="../BigStep/#12116" class="Bound">γ</a><a id="12117" class="Symbol">}</a> <a id="12119" class="Symbol">(</a><a id="12120" href="../BigStep/#3931" class="InductiveConstructor">⇓-var</a><a id="12125" class="Symbol">{</a><a id="12126" class="Argument">x</a> <a id="12128" class="Symbol">=</a> <a id="12130" href="../BigStep/#12130" class="Bound">x</a><a id="12131" class="Symbol">}</a> <a id="12133" href="../BigStep/#12133" class="Bound">γx≡Lδ</a> <a id="12139" href="../BigStep/#12139" class="Bound">δ⊢L⇓V</a><a id="12144" class="Symbol">)</a> <a id="12146" href="../BigStep/#12146" class="Bound">γ≈ₑσ</a>
    <a id="12155" class="Keyword">with</a> <a id="12160" href="../BigStep/#12116" class="Bound">γ</a> <a id="12162" href="../BigStep/#12130" class="Bound">x</a> <a id="12164" class="Symbol">|</a> <a id="12166" href="../BigStep/#12146" class="Bound">γ≈ₑσ</a> <a id="12171" class="Symbol">{</a><a id="12172" href="../BigStep/#12130" class="Bound">x</a><a id="12173" class="Symbol">}</a> <a id="12175" class="Symbol">|</a> <a id="12177" href="../BigStep/#12133" class="Bound">γx≡Lδ</a>
<a id="12183" class="Symbol">...</a> <a id="12187" class="Symbol">|</a> <a id="12189" href="../BigStep/#3192" class="InductiveConstructor">clos</a> <a id="12194" href="../BigStep/#12194" class="Bound">L</a> <a id="12196" href="../BigStep/#12196" class="Bound">δ</a> <a id="12198" class="Symbol">|</a> <a id="12200" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12202" href="../BigStep/#12202" class="Bound">τ</a> <a id="12204" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12206" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12208" href="../BigStep/#12208" class="Bound">δ≈ₑτ</a> <a id="12213" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12215" href="../BigStep/#12215" class="Bound">σx≡τL</a> <a id="12221" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12223" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12225" class="Symbol">|</a> <a id="12227" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
      <a id="12238" class="Keyword">with</a> <a id="12243" href="../BigStep/#11911" class="Function">⇓→—↠×≈</a><a id="12249" class="Symbol">{</a><a id="12250" class="Argument">σ</a> <a id="12252" class="Symbol">=</a> <a id="12254" href="../BigStep/#12202" class="Bound">τ</a><a id="12255" class="Symbol">}</a> <a id="12257" class="Bound">δ⊢L⇓V</a> <a id="12263" href="../BigStep/#12208" class="Bound">δ≈ₑτ</a>
<a id="12268" class="Symbol">...</a>   <a id="12274" class="Symbol">|</a> <a id="12276" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12278" href="../BigStep/#12278" class="Bound">N</a> <a id="12280" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12282" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12284" href="../BigStep/#12284" class="Bound">τL—↠N</a> <a id="12290" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12292" href="../BigStep/#12292" class="Bound">V≈N</a> <a id="12296" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12298" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12300" class="Keyword">rewrite</a> <a id="12308" class="Bound">σx≡τL</a> <a id="12314" class="Symbol">=</a>
        <a id="12324" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12326" href="../BigStep/#12278" class="Bound">N</a> <a id="12328" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12330" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12332" href="../BigStep/#12284" class="Bound">τL—↠N</a> <a id="12338" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12340" href="../BigStep/#12292" class="Bound">V≈N</a> <a id="12344" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12346" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a>
<a id="12348" href="../BigStep/#11911" class="Function">⇓→—↠×≈</a> <a id="12355" class="Symbol">{</a><a id="12356" class="Argument">σ</a> <a id="12358" class="Symbol">=</a> <a id="12360" href="../BigStep/#12360" class="Bound">σ</a><a id="12361" class="Symbol">}</a> <a id="12363" class="Symbol">{</a><a id="12364" class="Argument">V</a> <a id="12366" class="Symbol">=</a> <a id="12368" href="../BigStep/#3192" class="InductiveConstructor">clos</a> <a id="12373" class="Symbol">(</a><a id="12374" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="12376" href="../BigStep/#12376" class="Bound">N</a><a id="12377" class="Symbol">)</a> <a id="12379" href="../BigStep/#12379" class="Bound">γ</a><a id="12380" class="Symbol">}</a> <a id="12382" class="Symbol">(</a><a id="12383" href="../BigStep/#4078" class="InductiveConstructor">⇓-lam</a><a id="12388" class="Symbol">)</a> <a id="12390" href="../BigStep/#12390" class="Bound">γ≈ₑσ</a> <a id="12395" class="Symbol">=</a>
    <a id="12401" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12403" href="../Untyped/#6945" class="Function">subst</a> <a id="12409" href="../BigStep/#12360" class="Bound">σ</a> <a id="12411" class="Symbol">(</a><a id="12412" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="12414" href="../BigStep/#12376" class="Bound">N</a><a id="12415" class="Symbol">)</a> <a id="12417" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12419" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12421" href="../Untyped/#6945" class="Function">subst</a> <a id="12427" href="../BigStep/#12360" class="Bound">σ</a> <a id="12429" class="Symbol">(</a><a id="12430" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="12432" href="../BigStep/#12376" class="Bound">N</a><a id="12433" class="Symbol">)</a> <a id="12435" href="../Untyped/#11100" class="InductiveConstructor Operator">∎</a> <a id="12437" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12439" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12441" href="../BigStep/#12360" class="Bound">σ</a> <a id="12443" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12445" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12447" href="../BigStep/#12390" class="Bound">γ≈ₑσ</a> <a id="12452" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12454" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="12459" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12461" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12463" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12465" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a>
<a id="12467" href="../BigStep/#11911" class="Function">⇓→—↠×≈</a><a id="12473" class="Symbol">{</a><a id="12474" href="../BigStep/#12474" class="Bound">Γ</a><a id="12475" class="Symbol">}{</a><a id="12477" href="../BigStep/#12477" class="Bound">γ</a><a id="12478" class="Symbol">}</a> <a id="12480" class="Symbol">{</a><a id="12481" class="Argument">σ</a> <a id="12483" class="Symbol">=</a> <a id="12485" href="../BigStep/#12485" class="Bound">σ</a><a id="12486" class="Symbol">}</a> <a id="12488" class="Symbol">{</a><a id="12489" href="../BigStep/#12489" class="Bound">L</a> <a id="12491" href="../Untyped/#4424" class="InductiveConstructor Operator">·</a> <a id="12493" href="../BigStep/#12493" class="Bound">M</a><a id="12494" class="Symbol">}</a> <a id="12496" class="Symbol">{</a><a id="12497" href="../BigStep/#12497" class="Bound">V</a><a id="12498" class="Symbol">}</a> <a id="12500" class="Symbol">(</a><a id="12501" href="../BigStep/#4153" class="InductiveConstructor">⇓-app</a> <a id="12507" class="Symbol">{</a><a id="12508" class="Argument">N</a> <a id="12510" class="Symbol">=</a> <a id="12512" href="../BigStep/#12512" class="Bound">N</a><a id="12513" class="Symbol">}</a> <a id="12515" href="../BigStep/#12515" class="Bound">L⇓ƛNδ</a> <a id="12521" href="../BigStep/#12521" class="Bound">N⇓V</a><a id="12524" class="Symbol">)</a> <a id="12526" href="../BigStep/#12526" class="Bound">γ≈ₑσ</a>
    <a id="12535" class="Keyword">with</a> <a id="12540" href="../BigStep/#11911" class="Function">⇓→—↠×≈</a><a id="12546" class="Symbol">{</a><a id="12547" class="Argument">σ</a> <a id="12549" class="Symbol">=</a> <a id="12551" href="../BigStep/#12485" class="Bound">σ</a><a id="12552" class="Symbol">}</a> <a id="12554" href="../BigStep/#12515" class="Bound">L⇓ƛNδ</a> <a id="12560" href="../BigStep/#12526" class="Bound">γ≈ₑσ</a>
<a id="12565" class="Symbol">...</a> <a id="12569" class="Symbol">|</a> <a id="12571" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12573" class="Symbol">_</a> <a id="12575" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12577" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12579" href="../BigStep/#12579" class="Bound">σL—↠ƛτN</a> <a id="12587" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12589" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12591" href="../BigStep/#12591" class="Bound">τ</a> <a id="12593" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12595" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12597" href="../BigStep/#12597" class="Bound">δ≈ₑτ</a> <a id="12602" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12604" href="../BigStep/#12604" class="Bound">≡ƛτN</a> <a id="12609" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12611" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12613" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12615" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12617" class="Keyword">rewrite</a> <a id="12625" href="../BigStep/#12604" class="Bound">≡ƛτN</a>
      <a id="12636" class="Keyword">with</a> <a id="12641" href="../BigStep/#11911" class="Function">⇓→—↠×≈</a> <a id="12648" class="Symbol">{</a><a id="12649" class="Argument">σ</a> <a id="12651" class="Symbol">=</a> <a id="12653" href="../BigStep/#9167" class="Function">ext-subst</a> <a id="12663" href="../BigStep/#12591" class="Bound">τ</a> <a id="12665" class="Symbol">(</a><a id="12666" href="../Untyped/#6945" class="Function">subst</a> <a id="12672" class="Bound">σ</a> <a id="12674" class="Bound">M</a><a id="12675" class="Symbol">)}</a> <a id="12678" class="Bound">N⇓V</a>
             <a id="12695" class="Symbol">(λ</a> <a id="12698" class="Symbol">{</a><a id="12699" href="../BigStep/#12699" class="Bound">x</a><a id="12700" class="Symbol">}</a> <a id="12702" class="Symbol">→</a> <a id="12704" href="../BigStep/#10490" class="Function">≈ₑ-ext</a><a id="12710" class="Symbol">{</a><a id="12711" class="Argument">σ</a> <a id="12713" class="Symbol">=</a> <a id="12715" href="../BigStep/#12591" class="Bound">τ</a><a id="12716" class="Symbol">}</a> <a id="12718" href="../BigStep/#12597" class="Bound">δ≈ₑτ</a> <a id="12723" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12725" class="Bound">σ</a> <a id="12727" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12729" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12731" class="Bound">γ≈ₑσ</a> <a id="12736" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12738" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="12743" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12745" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12747" class="Symbol">{</a><a id="12748" href="../BigStep/#12699" class="Bound">x</a><a id="12749" class="Symbol">})</a>
           <a id="12763" class="Symbol">|</a> <a id="12765" href="../Untyped/#10160" class="InductiveConstructor">β</a><a id="12766" class="Symbol">{</a><a id="12767" href="../Untyped/#3157" class="InductiveConstructor">∅</a><a id="12768" class="Symbol">}{</a><a id="12770" href="../Untyped/#6945" class="Function">subst</a> <a id="12776" class="Symbol">(</a><a id="12777" href="../Untyped/#6653" class="Function">exts</a> <a id="12782" href="../BigStep/#12591" class="Bound">τ</a><a id="12783" class="Symbol">)</a> <a id="12785" class="Bound">N</a><a id="12786" class="Symbol">}{</a><a id="12788" href="../Untyped/#6945" class="Function">subst</a> <a id="12794" class="Bound">σ</a> <a id="12796" class="Bound">M</a><a id="12797" class="Symbol">}</a>
<a id="12799" class="Symbol">...</a>   <a id="12805" class="Symbol">|</a> <a id="12807" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12809" href="../BigStep/#12809" class="Bound">N'</a> <a id="12812" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12814" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="12816" href="../BigStep/#12816" class="Bound">—↠N'</a> <a id="12821" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="12823" href="../BigStep/#12823" class="Bound">V≈N'</a> <a id="12828" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12830" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="12832" class="Symbol">|</a> <a id="12834" href="../BigStep/#12834" class="Bound">ƛτN·σM—→</a>
        <a id="12851" class="Keyword">rewrite</a> <a id="12859" href="../BigStep/#11419" class="Function">sub-sub</a><a id="12866" class="Symbol">{</a><a id="12867" class="Argument">M</a> <a id="12869" class="Symbol">=</a> <a id="12871" class="Bound">N</a><a id="12872" class="Symbol">}{</a><a id="12874" class="Argument">σ₁</a> <a id="12877" class="Symbol">=</a> <a id="12879" href="../Untyped/#6653" class="Function">exts</a> <a id="12884" class="Bound">τ</a><a id="12885" class="Symbol">}{</a><a id="12887" class="Argument">σ₂</a> <a id="12890" class="Symbol">=</a> <a id="12892" href="../Untyped/#7357" class="Function">subst-zero</a> <a id="12903" class="Symbol">(</a><a id="12904" href="../Untyped/#6945" class="Function">subst</a> <a id="12910" class="Bound">σ</a> <a id="12912" class="Bound">M</a><a id="12913" class="Symbol">)}</a> <a id="12916" class="Symbol">=</a>
        <a id="12926" class="Keyword">let</a> <a id="12930" href="../BigStep/#12930" class="Bound">rs</a> <a id="12933" class="Symbol">=</a> <a id="12935" class="Symbol">(</a><a id="12936" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="12938" href="../Untyped/#6945" class="Function">subst</a> <a id="12944" class="Symbol">(</a><a id="12945" href="../Untyped/#6653" class="Function">exts</a> <a id="12950" class="Bound">τ</a><a id="12951" class="Symbol">)</a> <a id="12953" class="Bound">N</a><a id="12954" class="Symbol">)</a> <a id="12956" href="../Untyped/#4424" class="InductiveConstructor Operator">·</a> <a id="12958" href="../Untyped/#6945" class="Function">subst</a> <a id="12964" class="Bound">σ</a> <a id="12966" class="Bound">M</a> <a id="12968" href="../Untyped/#11156" class="InductiveConstructor Operator">—→⟨</a> <a id="12972" href="../BigStep/#12834" class="Bound">ƛτN·σM—→</a> <a id="12981" href="../Untyped/#11156" class="InductiveConstructor Operator">⟩</a> <a id="12983" href="../BigStep/#12816" class="Bound">—↠N'</a> <a id="12988" class="Keyword">in</a>
        <a id="12999" class="Keyword">let</a> <a id="13003" href="../BigStep/#13003" class="Bound">g</a> <a id="13005" class="Symbol">=</a> <a id="13007" href="../Untyped/#21711" class="Function">—↠-trans</a> <a id="13016" class="Symbol">(</a><a id="13017" href="../Untyped/#22877" class="Function">appL-cong</a> <a id="13027" class="Bound">σL—↠ƛτN</a><a id="13034" class="Symbol">)</a> <a id="13036" href="../BigStep/#12930" class="Bound">rs</a> <a id="13039" class="Keyword">in</a>
        <a id="13050" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="13052" href="../BigStep/#12809" class="Bound">N'</a> <a id="13055" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="13057" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="13059" href="../BigStep/#13003" class="Bound">g</a> <a id="13061" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="13063" href="../BigStep/#12823" class="Bound">V≈N'</a> <a id="13068" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="13070" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a>
</pre>
<!--
The proof is by induction on `γ ⊢ M ⇓ V`. We have three cases
to consider.
-->
<p>该证明对 <code>γ ⊢ M ⇓ V</code> 进行归纳。我们有三种情况需要考虑。</p>
<!--
* Case `⇓-var`.
  So we have `γ x ≡ clos L δ` and `δ ⊢ L ⇓ V`.
  We need to show that ``subst σ (` x) —↠ N`` and `V ≈ N` for some `N`.
  The premise `γ ≈ₑ σ` tells us that `γ x ≈ σ x`, so `clos L δ ≈ σ x`.
  By the definition of `≈`, there exists a `τ` such that
  `δ ≈ₑ τ` and `σ x ≡ subst τ L `.
  Using `δ ⊢ L ⇓ V` and `δ ≈ₑ τ`,
  the induction hypothesis gives us
  `subst τ L —↠ N` and `V ≈ N` for some `N`.
  So we have shown that `subst σ x —↠ N` and `V ≈ N` for some `N`.
-->
<ul>
<li>情况 <code>⇓-var</code>： 此时我们有 <code>γ x ≡ clos L δ</code> 和 <code>δ ⊢ L ⇓ V</code>。 我们需要证明对于某个 <code>N</code> 有<code>subst σ x —↠ N</code> 和 <code>V ≈ N</code>。 前提 <code>γ ≈ₑ σ</code> 告诉我们 <code>γ x ≈ σ x</code>，所以有 <code>clos L δ ≈ σ x</code>。 根据 <code>≈</code> 的定义， 存在一个 <code>τ</code> 使得 <code>δ ≈ₑ τ</code> 且 <code>σ x ≡ subst τ L</code>。 使用 <code>δ ⊢ L ⇓ V</code> 和 <code>δ ≈ₑ τ</code>， 归纳假设使得对于某个 <code>N</code> 有 <code>subst τ L —↠ N</code> 和 <code>V ≈ N</code>。 所以我们证明了对于某个 <code>N</code>，有 <code>subst σ x —↠ N</code> 和 <code>V ≈ N</code>。</li>
</ul>
<!--
* Case `⇓-lam`.
  We immediately have `subst σ (ƛ N) —↠ subst σ (ƛ N)`
  and `clos (subst σ (ƛ N)) γ ≈ subst σ (ƛ N)`.
-->
<ul>
<li>情况 <code>⇓-lam</code>： 我们立刻获得 <code>subst σ (ƛ N) —↠ subst σ (ƛ N)</code> 和 <code>clos (subst σ (ƛ N)) γ ≈ subst σ (ƛ N)</code>。</li>
</ul>
<!--
* Case `⇓-app`.
  Using `γ ⊢ L ⇓ clos (ƛ N) δ` and `γ ≈ₑ σ`,
  the induction hypothesis gives us

        subst σ L —↠ ƛ subst (exts τ) N                                     (1)

  and `δ ≈ₑ τ` for some `τ`.
  From `γ≈ₑσ` we have `clos M γ ≈ subst σ M`.
  Then with `(δ ,' clos M γ) ⊢ N ⇓ V`,
  the induction hypothesis gives us `V ≈ N'` and

        subst (subst (subst-zero (subst σ M)) ∘ (exts τ)) N —↠ N'         (2)

  Meanwhile, by `β`, we have

        (ƛ subst (exts τ) N) · subst σ M
        —→ subst (subst-zero (subst σ M)) (subst (exts τ) N)

  which is the same as the following, by `sub-sub`.

        (ƛ subst (exts τ) N) · subst σ M
        —→ subst (subst (subst-zero (subst σ M)) ∘ exts τ) N              (3)

  Using (3) and (2) we have

        (ƛ subst (exts τ) N) · subst σ M —↠ N'                             (4)

  From (1) we have

        subst σ L · subst σ M —↠ (ƛ subst (exts τ) N) · subst σ M

  which we combine with (4) to conclude that

        subst σ L · subst σ M —↠ N'
-->
<ul>
<li><p>情况 <code>⇓-app</code>： 使用 <code>γ ⊢ L ⇓ clos N δ</code> 和 <code>γ ≈ₑ σ</code>， 归纳假设给我们</p>
<pre><code>  subst σ L —↠ ƛ subst (exts τ) N                                     (1)</code></pre>
<p>并且对于某个 <code>τ</code> 有 <code>δ ≈ₑ τ</code>。 根据 <code>γ≈ₑσ</code> 我们有 <code>clos M γ ≈ subst σ M</code>。 与 <code>(δ ,' clos M γ) ⊢ N ⇓ V</code> 一同， 归纳假设给我们 <code>V ≈ N'</code> 和</p>
<pre><code>  subst (subst (subst-zero (subst σ M)) ∘ (exts τ)) N —↠ N'         (2)</code></pre>
<p>同时根据 <code>β</code>，我们有</p>
<pre><code>  (ƛ subst (exts τ) N) · subst σ M
  —→ subst (subst-zero (subst σ M)) (subst (exts τ) N)</code></pre>
<p>通过 <code>sub-sub</code>，这等价于</p>
<pre><code>  (ƛ subst (exts τ) N) · subst σ M
  —→ subst (subst (subst-zero (subst σ M)) ∘ exts τ) N              (3)</code></pre>
<p>使用 (3) 和 (2) 我们有</p>
<pre><code>  (ƛ subst (exts τ) N) · subst σ M —↠ N'                             (4)</code></pre>
<p>根据 (1) 我们有</p>
<pre><code>  subst σ L · subst σ M —↠ (ƛ subst (exts τ) N) · subst σ M</code></pre>
<p>与 (4) 相结合，我们得出结论</p>
<pre><code>  subst σ L · subst σ M —↠ N'</code></pre></li>
</ul>
<!--
With the main lemma complete, we establish the forward direction
of the equivalence between the big-step semantics and beta reduction.
-->
<p>证明了主要引理后，我们便建立起大步语义与 β-规约等价关系的必要性。</p>
<pre class="Agda"><a id="cbn→reduce"></a><a id="16296" href="../BigStep/#16296" class="Function">cbn→reduce</a> <a id="16307" class="Symbol">:</a>  <a id="16310" class="Symbol">∀{</a><a id="16312" href="../BigStep/#16312" class="Bound">M</a> <a id="16314" class="Symbol">:</a> <a id="16316" href="../Untyped/#3157" class="InductiveConstructor">∅</a> <a id="16318" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="16320" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="16321" class="Symbol">}{</a><a id="16323" href="../BigStep/#16323" class="Bound">Δ</a><a id="16324" class="Symbol">}{</a><a id="16326" href="../BigStep/#16326" class="Bound">δ</a> <a id="16328" class="Symbol">:</a> <a id="16330" href="../BigStep/#3143" class="Function">ClosEnv</a> <a id="16338" href="../BigStep/#16323" class="Bound">Δ</a><a id="16339" class="Symbol">}{</a><a id="16341" href="../BigStep/#16341" class="Bound">N′</a> <a id="16344" class="Symbol">:</a> <a id="16346" href="../BigStep/#16323" class="Bound">Δ</a> <a id="16348" href="../Untyped/#3173" class="InductiveConstructor Operator">,</a> <a id="16350" href="../Untyped/#2870" class="InductiveConstructor">★</a> <a id="16352" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="16354" href="../Untyped/#2870" class="InductiveConstructor">★</a><a id="16355" class="Symbol">}</a>
  <a id="16359" class="Symbol">→</a> <a id="16361" href="../BigStep/#3387" class="Function">∅'</a> <a id="16364" href="../BigStep/#3874" class="Datatype Operator">⊢</a> <a id="16366" href="../BigStep/#16312" class="Bound">M</a> <a id="16368" href="../BigStep/#3874" class="Datatype Operator">⇓</a> <a id="16370" href="../BigStep/#3192" class="InductiveConstructor">clos</a> <a id="16375" class="Symbol">(</a><a id="16376" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="16378" href="../BigStep/#16341" class="Bound">N′</a><a id="16380" class="Symbol">)</a> <a id="16382" href="../BigStep/#16326" class="Bound">δ</a>
    <a id="16388" class="Comment">-----------------------------</a>
  <a id="16420" class="Symbol">→</a> <a id="16422" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">Σ[</a> <a id="16425" href="../BigStep/#16425" class="Bound">N</a> <a id="16427" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">∈</a> <a id="16429" href="../Untyped/#3157" class="InductiveConstructor">∅</a> <a id="16431" href="../Untyped/#3173" class="InductiveConstructor Operator">,</a> <a id="16433" href="../Untyped/#2870" class="InductiveConstructor">★</a> <a id="16435" href="../Untyped/#4276" class="Datatype Operator">⊢</a> <a id="16437" href="../Untyped/#2870" class="InductiveConstructor">★</a> <a id="16439" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#916" class="Function">]</a> <a id="16441" class="Symbol">(</a><a id="16442" href="../BigStep/#16312" class="Bound">M</a> <a id="16444" href="../Untyped/#11050" class="Datatype Operator">—↠</a> <a id="16447" href="../Untyped/#4364" class="InductiveConstructor Operator">ƛ</a> <a id="16449" href="../BigStep/#16425" class="Bound">N</a><a id="16450" class="Symbol">)</a>
<a id="16452" href="../BigStep/#16296" class="Function">cbn→reduce</a> <a id="16463" class="Symbol">{</a><a id="16464" href="../BigStep/#16464" class="Bound">M</a><a id="16465" class="Symbol">}{</a><a id="16467" href="../BigStep/#16467" class="Bound">Δ</a><a id="16468" class="Symbol">}{</a><a id="16470" href="../BigStep/#16470" class="Bound">δ</a><a id="16471" class="Symbol">}{</a><a id="16473" href="../BigStep/#16473" class="Bound">N′</a><a id="16475" class="Symbol">}</a> <a id="16477" href="../BigStep/#16477" class="Bound">M⇓c</a>
    <a id="16485" class="Keyword">with</a> <a id="16490" href="../BigStep/#11911" class="Function">⇓→—↠×≈</a><a id="16496" class="Symbol">{</a><a id="16497" class="Argument">σ</a> <a id="16499" class="Symbol">=</a> <a id="16501" href="../Substitution/#3046" class="Function">ids</a><a id="16504" class="Symbol">}</a> <a id="16506" href="../BigStep/#16477" class="Bound">M⇓c</a> <a id="16510" href="../BigStep/#8832" class="Function">≈ₑ-id</a>
<a id="16516" class="Symbol">...</a> <a id="16520" class="Symbol">|</a> <a id="16522" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="16524" href="../BigStep/#16524" class="Bound">N</a> <a id="16526" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="16528" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="16530" href="../BigStep/#16530" class="Bound">rs</a> <a id="16533" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="16535" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="16537" href="../BigStep/#16537" class="Bound">σ</a> <a id="16539" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="16541" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="16543" href="../BigStep/#16543" class="Bound">h</a> <a id="16545" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="16547" href="../BigStep/#16547" class="Bound">eq2</a> <a id="16551" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="16553" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="16555" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="16557" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a> <a id="16559" class="Keyword">rewrite</a> <a id="16567" href="../BigStep/#8980" class="Function">sub-id</a><a id="16573" class="Symbol">{</a><a id="16574" class="Argument">M</a> <a id="16576" class="Symbol">=</a> <a id="16578" class="Bound">M</a><a id="16579" class="Symbol">}</a> <a id="16581" class="Symbol">|</a> <a id="16583" href="../BigStep/#16547" class="Bound">eq2</a> <a id="16587" class="Symbol">=</a>
      <a id="16595" href="../BigStep/#2004" class="InductiveConstructor Operator">⟨</a> <a id="16597" href="../Untyped/#6945" class="Function">subst</a> <a id="16603" class="Symbol">(</a><a id="16604" href="../Untyped/#6653" class="Function">exts</a> <a id="16609" href="../BigStep/#16537" class="Bound">σ</a><a id="16610" class="Symbol">)</a> <a id="16612" class="Bound">N′</a> <a id="16615" href="../BigStep/#2004" class="InductiveConstructor Operator">,</a> <a id="16617" href="../BigStep/#16530" class="Bound">rs</a> <a id="16620" href="../BigStep/#2004" class="InductiveConstructor Operator">⟩</a>
</pre>
<!--
#### Exercise `big-alt-implies-multi` (practice)
-->
<h4 id="练习-big-alt-implies-multi实践">练习 <code>big-alt-implies-multi</code>（实践）</h4>
<!--
Formulate an alternative big-step semantics, of the form `M ↓ N`, for
call-by-name that uses substitution instead of environments.  That is,
the analogue of the application rule `⇓-app` should perform
substitution, as in `N [ M ]`, instead of extending the environment
with `M`. Prove that `M ↓ N` implies `M —↠ N`.
-->
<p>为使用替换而不是环境的传名调用表达另一种大步语义，形式为 <code>M ↓ N</code>。 即应用规则 <code>⇓-app</code> 应像在 <code>N [ M ]</code> 中一样执行替换而不是用 <code>M</code> 扩展环境。 证明 <code>M ↓ N</code> 蕴含 <code>M —↠ N</code>。</p>
<!--
<pre class="Agda"><a id="17171" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="17207" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
## Beta reduction to a lambda implies big-step evaluation
-->
<h2 id="β-规约至-λ-抽象蕴含大步求值">β-规约至 λ-抽象蕴含大步求值</h2>
<!--
The proof of the backward direction, that beta reduction to a lambda
implies that the call-by-name semantics produces a result, is more
difficult to prove. The difficulty stems from reduction proceeding
underneath lambda abstractions via the `ζ` rule. The call-by-name
semantics does not reduce under lambda, so a straightforward proof by
induction on the reduction sequence is impossible.  In the article
_Call-by-name, call-by-value, and the λ-calculus_, Plotkin proves the
theorem in two steps, using two auxiliary reduction relations. The
first step uses a classic technique called Curry-Feys standardisation.
It relies on the notion of _standard reduction sequence_, which acts
as a half-way point between full beta reduction and call-by-name by
expanding call-by-name to also include reduction underneath
lambda. Plotkin proves that `M` reduces to `L` if and only if `M` is
related to `L` by a standard reduction sequence.
-->
<p>充分性的证明，也就是 β-规约至 λ-抽象蕴含大步语义求值是更困难的。 困难源于通过 <code>ζ</code> 规则在 λ-抽象下的规约过程。 传名调用语义在 λ-演算中并不会规约，因此直接通过归纳规约序列来证明是不可能的。 在文章 <strong>Call-by-name, call-by-value, and the λ-calculus</strong> 中， Plotkin使用两个辅助规约关系分两步完成了证明。 第一步使用了 Curry-Feys 标准化这一经典方法， 它依赖于 <strong>标准规约序列（Standard Reduction Sequence）</strong> 的概念， 通过在 λ-演算下将传名调用扩展以包括规约， 标准规约序列充当了完整 β-规约与传名调用求值的中间点。 Plotkin证明了 <code>M</code> 能被规约为 <code>L</code> 当且仅当 <code>M</code> 与 <code>L</code> 通过一个标准规约序列相关。</p>
<!--
    Theorem 1 (Standardisation)
    `M —↠ L` if and only if `M` goes to `L` via a standard reduction sequence.
-->
<pre><code>定理 1（标准化）
`M —↠ L` 当且仅当 `M` 能通过一个标准规约序列规约成 `L`。</code></pre>
<!--
Plotkin then introduces _left reduction_, a small-step version of
call-by-name and uses the above theorem to prove that beta reduction
and left reduction are equivalent in the following sense.
-->
<p>Plotkin 接着引入了<strong>左规约（Left Reduction）</strong> 作为传名调用的小步描述， 并且用上方的定理证明了 β-规约与左规约在下述情况下等价。</p>
<!--
    Corollary 1
    `M —↠ ƛ N` if and only if `M` goes to `ƛ N′`, for some `N′`, by left reduction.
-->
<pre><code>推论 1
`M —↠ ƛ N` 当且仅当对于某个 `N′`，`M`能通过左规约成 `ƛ N′`。</code></pre>
<!--
The second step of the proof connects left reduction to call-by-name
evaluation.
-->
<p>证明的下一步将左规约与传名调用求值联系起来。</p>
<!--
    Theorem 2
    `M` left reduces to `ƛ N` if and only if `⊢ M ⇓ ƛ N`。
-->
<pre><code>定理 2
`M` 左规约成 `ƛ N` 当且仅当 `⊢ M ⇓ ƛ N`。</code></pre>
<!--
(Plotkin's call-by-name evaluator uses substitution instead of
environments, which explains why the environment is omitted in `⊢ M ⇓
ƛ N` in the above theorem statement.)
-->
<p>（Plotkin 的传名调用求值使用替换而不是环境， 这解释了为何在上文定理的描述中环境被隐去了。）</p>
<!--
Putting Corollary 1 and Theorem 2 together, Plotkin proves that
call-by-name evaluation is equivalent to beta reduction.
-->
<p>将推论 1 和定理 2 相结合，Plotkin 证明了传名调用求值与 β-规约等价。</p>
<!--
    Corollary 2
    `M —↠ ƛ N` if and only if `⊢ M ⇓ ƛ N′` for some `N′`.
-->
<pre><code>推论 2
`M —↠ ƛ N` 当且仅当对某个 `N′`，`⊢ M ⇓ ƛ N′`。</code></pre>
<!--
Plotkin also proves an analogous result for the λᵥ calculus, relating
it to call-by-value evaluation. For a nice exposition of that proof,
we recommend Chapter 5 of _Semantics Engineering with PLT Redex_ by
Felleisen, Findler, and Flatt.
-->
<p>Plotkin 还证明了 λᵥ-演算中的类似结果，将其与传值调用求值相联系。 为了更好阐述该证明，我们推荐阅读由 Felleisen、Findler 和 Flatt 所著的 <em>Semantics Engineering with PLT Redex</em> 的第五章。</p>
<!--
Instead of proving the backwards direction via standardisation, as
sketched above, we defer the proof until after we define a
denotational semantics for the lambda calculus, at which point the
proof of the backwards direction will fall out as a corollary to the
soundness and adequacy of the denotational semantics.
-->
<p>我们不通过上文描述的标准化方式来完成充分性的证明， 而是将其推迟到发展出 λ-演算的指称语义后， 此时该证明是指称语义中 soundness 和 adequacy 的推论。</p>
<h2 id="unicode">Unicode</h2>
<!--
This chapter uses the following unicode:
-->
<p>本章中使用了以下 Unicode：</p>
<pre><code>≈  U+2248  ALMOST EQUAL TO (\~~ or \approx)
ₑ  U+2091  LATIN SUBSCRIPT SMALL LETTER E (\_e)
⊢  U+22A2  RIGHT TACK (\|- or \vdash)
⇓  U+21DB  DOWNWARDS DOUBLE ARROW (\d= or \Downarrow)</code></pre>
    </div>
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Confluence/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part2/BigStep.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Denotational/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

</article>

            </div>
        </main>
        <footer class="site-footer h-card">
    <data class="u-url" href="../"></data>
    <div class="wrapper">
        <h2 class="footer-heading">编程语言基础：Agda 语言描述</h2>
        
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Philip Wadler</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wadler" title="wadler"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wadler</a></li>
    
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Wen Kokke</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wenkokke</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;wenkokke</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Jeremy G. Siek</li>
                    <li>
                        
                        <a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/jsiek" title="jsiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;jsiek</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;jeremysiek</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        
        This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
    </div>
</footer>

    </body>
</html>
