<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../public/css/style.css">
  
  <title>编程语言基础：Agda 语言描述 – Connectives</title>
  
  
  
</head>

    <body>
        <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="../">编程语言基础：Agda 语言描述</a>
        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="../">主页</a>
                <a class="page-link" href="../Announcements/">公告</a>
                <a class="page-link" href="../GettingStarted/">使用说明</a>
                <a class="page-link" href="../Citing/">引用</a>
                <a class="page-link" href="https://plfa.github.io/">English</a>
            </div>
        </nav>
    </div>
</header>

        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Isomorphism/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Connectives.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Negation/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

    <header class="post-header">
        <h1 class="post-title" id="connectives">Connectives: 合取、析取与蕴涵</h1>
    </header>
    <div class="post-content">
        <pre class="Agda"><a id="188" class="Keyword">module</a> <a id="195" href="../Connectives/" class="Module">plfa.part1.Connectives</a> <a id="218" class="Keyword">where</a>
</pre>
<!-- The ⊥ ⊎ A ≅ A exercise requires a (inj₁ ()) pattern,
     which the reader will not have seen. Restore this
     exercise, and possibly also associativity? Take the
     exercises from the final sections on distributivity
     and exponentials? -->
<!--
This chapter introduces the basic logical connectives, by observing a
correspondence between connectives of logic and data types, a
principle known as _Propositions as Types_:
-->
<p>本章节介绍基础的逻辑运算符。我们使用逻辑运算符与数据类型之间的对应关系， 即<strong>命题即类型（Propositions as Types）</strong>原理。</p>
<!--
  * _conjunction_ is _product_,
  * _disjunction_ is _sum_,
  * _true_ is _unit type_,
  * _false_ is _empty type_,
  * _implication_ is _function space_.
-->
<ul>
<li><strong>合取（Conjunction）</strong>即是<strong>积（Product）</strong></li>
<li><strong>析取（Disjunction）</strong>即是<strong>和（Sum）</strong></li>
<li><strong>真（True）</strong>即是<strong>单元类型（Unit Type）</strong></li>
<li><strong>假（False）</strong>即是<strong>空类型（Empty Type）</strong></li>
<li><strong>蕴涵（Implication）</strong>即是<strong>函数空间（Function Space）</strong></li>
</ul>
<!--
## Imports
-->
<h2 id="导入">导入</h2>
<pre class="Agda"><a id="1144" class="Keyword">import</a> <a id="1151" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1189" class="Symbol">as</a> <a id="1192" class="Module">Eq</a>
<a id="1195" class="Keyword">open</a> <a id="1200" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="1203" class="Keyword">using</a> <a id="1209" class="Symbol">(</a><a id="1210" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="1213" class="Symbol">;</a> <a id="1215" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1219" class="Symbol">)</a>
<a id="1221" class="Keyword">open</a> <a id="1226" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2419" class="Module">Eq.≡-Reasoning</a>
<a id="1241" class="Keyword">open</a> <a id="1246" class="Keyword">import</a> <a id="1253" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.html" class="Module">Data.Nat</a> <a id="1262" class="Keyword">using</a> <a id="1268" class="Symbol">(</a><a id="1269" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="1270" class="Symbol">)</a>
<a id="1272" class="Keyword">open</a> <a id="1277" class="Keyword">import</a> <a id="1284" href="https://agda.github.io/agda-stdlib/v1.3/Function.html" class="Module">Function</a> <a id="1293" class="Keyword">using</a> <a id="1299" class="Symbol">(</a><a id="1300" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">_∘_</a><a id="1303" class="Symbol">)</a>
<a id="1305" class="Keyword">open</a> <a id="1310" class="Keyword">import</a> <a id="1317" href="../Isomorphism/" class="Module">plfa.part1.Isomorphism</a> <a id="1340" class="Keyword">using</a> <a id="1346" class="Symbol">(</a><a id="1347" href="../Isomorphism/#5610" class="Record Operator">_≃_</a><a id="1350" class="Symbol">;</a> <a id="1352" href="../Isomorphism/#11725" class="Record Operator">_≲_</a><a id="1355" class="Symbol">;</a> <a id="1357" href="../Isomorphism/#3602" class="Postulate">extensionality</a><a id="1371" class="Symbol">)</a>
<a id="1373" class="Keyword">open</a> <a id="1378" href="../Isomorphism/#10815" class="Module">plfa.part1.Isomorphism.≃-Reasoning</a>
</pre>
<!--
## Conjunction is product
-->
<h2 id="合取即是积">合取即是积</h2>
<!--
Given two propositions `A` and `B`, the conjunction `A × B` holds
if both `A` holds and `B` holds.  We formalise this idea by
declaring a suitable datatype:
-->
<p>给定两个命题 <code>A</code> 和 <code>B</code>，其合取 <code>A × B</code> 成立当 <code>A</code> 成立和 <code>B</code> 成立。 我们用一个合适的数据类型将这样的概念形式化：</p>
<pre class="Agda"><a id="1709" class="Keyword">data</a> <a id="_×_"></a><a id="1714" href="../Connectives/#1714" class="Datatype Operator">_×_</a> <a id="1718" class="Symbol">(</a><a id="1719" href="../Connectives/#1719" class="Bound">A</a> <a id="1721" href="../Connectives/#1721" class="Bound">B</a> <a id="1723" class="Symbol">:</a> <a id="1725" class="PrimitiveType">Set</a><a id="1728" class="Symbol">)</a> <a id="1730" class="Symbol">:</a> <a id="1732" class="PrimitiveType">Set</a> <a id="1736" class="Keyword">where</a>

  <a id="_×_.⟨_,_⟩"></a><a id="1745" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨_,_⟩</a> <a id="1751" class="Symbol">:</a>
      <a id="1759" href="../Connectives/#1719" class="Bound">A</a>
    <a id="1765" class="Symbol">→</a> <a id="1767" href="../Connectives/#1721" class="Bound">B</a>
      <a id="1775" class="Comment">-----</a>
    <a id="1785" class="Symbol">→</a> <a id="1787" href="../Connectives/#1719" class="Bound">A</a> <a id="1789" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="1791" href="../Connectives/#1721" class="Bound">B</a>
</pre>
<!--
Evidence that `A × B` holds is of the form `⟨ M , N ⟩`, where `M`
provides evidence that `A` holds and `N` provides evidence that `B`
holds.
-->
<p><code>A × B</code> 成立的证明由 <code>⟨ M , N ⟩</code> 的形式表现，其中 <code>M</code> 是 <code>A</code> 成立的证明， <code>N</code> 是 <code>B</code> 成立的证明。</p>
<!--
Given evidence that `A × B` holds, we can conclude that both
`A` holds and `B` holds:
-->
<p>给定 <code>A × B</code> 成立的证明，我们可以得出 <code>A</code> 成立和 <code>B</code> 成立。</p>
<pre class="Agda"><a id="proj₁"></a><a id="2161" href="../Connectives/#2161" class="Function">proj₁</a> <a id="2167" class="Symbol">:</a> <a id="2169" class="Symbol">∀</a> <a id="2171" class="Symbol">{</a><a id="2172" href="../Connectives/#2172" class="Bound">A</a> <a id="2174" href="../Connectives/#2174" class="Bound">B</a> <a id="2176" class="Symbol">:</a> <a id="2178" class="PrimitiveType">Set</a><a id="2181" class="Symbol">}</a>
  <a id="2185" class="Symbol">→</a> <a id="2187" href="../Connectives/#2172" class="Bound">A</a> <a id="2189" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="2191" href="../Connectives/#2174" class="Bound">B</a>
    <a id="2197" class="Comment">-----</a>
  <a id="2205" class="Symbol">→</a> <a id="2207" href="../Connectives/#2172" class="Bound">A</a>
<a id="2209" href="../Connectives/#2161" class="Function">proj₁</a> <a id="2215" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="2217" href="../Connectives/#2217" class="Bound">x</a> <a id="2219" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="2221" href="../Connectives/#2221" class="Bound">y</a> <a id="2223" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="2225" class="Symbol">=</a> <a id="2227" href="../Connectives/#2217" class="Bound">x</a>

<a id="proj₂"></a><a id="2230" href="../Connectives/#2230" class="Function">proj₂</a> <a id="2236" class="Symbol">:</a> <a id="2238" class="Symbol">∀</a> <a id="2240" class="Symbol">{</a><a id="2241" href="../Connectives/#2241" class="Bound">A</a> <a id="2243" href="../Connectives/#2243" class="Bound">B</a> <a id="2245" class="Symbol">:</a> <a id="2247" class="PrimitiveType">Set</a><a id="2250" class="Symbol">}</a>
  <a id="2254" class="Symbol">→</a> <a id="2256" href="../Connectives/#2241" class="Bound">A</a> <a id="2258" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="2260" href="../Connectives/#2243" class="Bound">B</a>
    <a id="2266" class="Comment">-----</a>
  <a id="2274" class="Symbol">→</a> <a id="2276" href="../Connectives/#2243" class="Bound">B</a>
<a id="2278" href="../Connectives/#2230" class="Function">proj₂</a> <a id="2284" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="2286" href="../Connectives/#2286" class="Bound">x</a> <a id="2288" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="2290" href="../Connectives/#2290" class="Bound">y</a> <a id="2292" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="2294" class="Symbol">=</a> <a id="2296" href="../Connectives/#2290" class="Bound">y</a>
</pre>
<!--
If `L` provides evidence that `A × B` holds, then `proj₁ L` provides evidence
that `A` holds, and `proj₂ L` provides evidence that `B` holds.
-->
<p>如果 <code>L</code> 是 <code>A × B</code> 成立的证据, 那么 <code>proj₁ L</code> 是 <code>A</code> 成立的证据， <code>proj₂ L</code> 是 <code>B</code> 成立的证据。</p>
<!--
When `⟨_,_⟩` appears in a term on the right-hand side of an equation
we refer to it as a _constructor_, and when it appears in a pattern on
the left-hand side of an equation we refer to it as a _destructor_.
We may also refer to `proj₁` and `proj₂` as destructors, since they
play a similar role.
-->
<p>当 <code>⟨_,_⟩</code> 在等式右手边的项中出现的时候，我们将其称作<strong>构造子（Constructor）</strong>， 当它出现在等式左边时，我们将其称作<strong>析构器（Destructor）</strong>。我们亦可将 <code>proj₁</code> 和 <code>proj₂</code> 称作析构器，因为它们起到相似的效果。</p>
<!--
Other terminology refers to `⟨_,_⟩` as _introducing_ a conjunction, and
to `proj₁` and `proj₂` as _eliminating_ a conjunction; indeed, the
former is sometimes given the name `×-I` and the latter two the names
`×-E₁` and `×-E₂`.  As we read the rules from top to bottom,
introduction and elimination do what they say on the tin: the first
_introduces_ a formula for the connective, which appears in the
conclusion but not in the hypotheses; the second _eliminates_ a
formula for the connective, which appears in a hypothesis but not in
the conclusion. An introduction rule describes under what conditions
we say the connective holds---how to _define_ the connective. An
elimination rule describes what we may conclude when the connective
holds---how to _use_ the connective.[^from-wadler-2015]
-->
<p>其他的术语将 <code>⟨_,_⟩</code> 称作<strong>引入（Introduce）</strong>合取，将 <code>proj₁</code> 和 <code>proj₂</code> 称作<strong>消去（Eliminate）</strong>合取。 前者亦记作 <code>×-I</code>，后者 <code>×-E₁</code> 和 <code>×-E₂</code>。如果我们从上到下来阅读这些规则，引入和消去 正如其名字所说的那样：第一条<strong>引入</strong>一个运算符，所以运算符出现在结论中，而不是假设中； 第二条<strong>消去</strong>一个带有运算符的式子，而运算符出现在假设中，而不是结论中。引入规则描述了 运算符在什么情况下成立——即怎么样<strong>定义</strong>一个运算符。消去规则描述了运算符成立时，可以得出 什么样的结论——即怎么样<strong>使用</strong>一个运算符。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<!--
In this case, applying each destructor and reassembling the results with the
constructor is the identity over products:
-->
<p>在这样的情况下，先使用析构器，再使用构造子将结果重组，得到还是原来的积。</p>
<pre class="Agda"><a id="η-×"></a><a id="4263" href="../Connectives/#4263" class="Function">η-×</a> <a id="4267" class="Symbol">:</a> <a id="4269" class="Symbol">∀</a> <a id="4271" class="Symbol">{</a><a id="4272" href="../Connectives/#4272" class="Bound">A</a> <a id="4274" href="../Connectives/#4274" class="Bound">B</a> <a id="4276" class="Symbol">:</a> <a id="4278" class="PrimitiveType">Set</a><a id="4281" class="Symbol">}</a> <a id="4283" class="Symbol">(</a><a id="4284" href="../Connectives/#4284" class="Bound">w</a> <a id="4286" class="Symbol">:</a> <a id="4288" href="../Connectives/#4272" class="Bound">A</a> <a id="4290" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="4292" href="../Connectives/#4274" class="Bound">B</a><a id="4293" class="Symbol">)</a> <a id="4295" class="Symbol">→</a> <a id="4297" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="4299" href="../Connectives/#2161" class="Function">proj₁</a> <a id="4305" href="../Connectives/#4284" class="Bound">w</a> <a id="4307" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="4309" href="../Connectives/#2230" class="Function">proj₂</a> <a id="4315" href="../Connectives/#4284" class="Bound">w</a> <a id="4317" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="4319" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4321" href="../Connectives/#4284" class="Bound">w</a>
<a id="4323" href="../Connectives/#4263" class="Function">η-×</a> <a id="4327" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="4329" href="../Connectives/#4329" class="Bound">x</a> <a id="4331" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="4333" href="../Connectives/#4333" class="Bound">y</a> <a id="4335" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="4337" class="Symbol">=</a> <a id="4339" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<!--
The pattern matching on the left-hand side is essential, since
replacing `w` by `⟨ x , y ⟩` allows both sides of the
propositional equality to simplify to the same term.
-->
<p>左手边的模式匹配是必要的。用 <code>⟨ x , y ⟩</code> 来替换 <code>w</code> 让等式的两边可以化简成相同的项。</p>
<!--
We set the precedence of conjunction so that it binds less
tightly than anything save disjunction:
-->
<p>我们设置合取的优先级，使它与除了析取之外结合的都不紧密：</p>
<pre class="Agda"><a id="4725" class="Keyword">infixr</a> <a id="4732" class="Number">2</a> <a id="4734" href="../Connectives/#1714" class="Datatype Operator">_×_</a>
</pre>
<!--
Thus, `m ≤ n × n ≤ p` parses as `(m ≤ n) × (n ≤ p)`.
-->
<p>因此，<code>m ≤ n × n ≤ p</code> 解析为 <code>(m ≤ n) × (n ≤ p)</code>。</p>
<p>Alternatively, we can declare conjunction as a record type:</p>
<pre class="Agda"><a id="4916" class="Keyword">record</a> <a id="_×′_"></a><a id="4923" href="../Connectives/#4923" class="Record Operator">_×′_</a> <a id="4928" class="Symbol">(</a><a id="4929" href="../Connectives/#4929" class="Bound">A</a> <a id="4931" href="../Connectives/#4931" class="Bound">B</a> <a id="4933" class="Symbol">:</a> <a id="4935" class="PrimitiveType">Set</a><a id="4938" class="Symbol">)</a> <a id="4940" class="Symbol">:</a> <a id="4942" class="PrimitiveType">Set</a> <a id="4946" class="Keyword">where</a>
  <a id="4954" class="Keyword">constructor</a> <a id="⟨_,_⟩′"></a><a id="4966" href="../Connectives/#4966" class="InductiveConstructor Operator">⟨_,_⟩′</a>
  <a id="4975" class="Keyword">field</a>
    <a id="_×′_.proj₁′"></a><a id="4985" href="../Connectives/#4985" class="Field">proj₁′</a> <a id="4992" class="Symbol">:</a> <a id="4994" href="../Connectives/#4929" class="Bound">A</a>
    <a id="_×′_.proj₂′"></a><a id="5000" href="../Connectives/#5000" class="Field">proj₂′</a> <a id="5007" class="Symbol">:</a> <a id="5009" href="../Connectives/#4931" class="Bound">B</a>
<a id="5011" class="Keyword">open</a> <a id="5016" href="../Connectives/#4923" class="Module Operator">_×′_</a>
</pre>
<p>The record construction <code>record { proj₁′ = M ; proj₂′ = N }</code> corresponds to the term <code>⟨ M , N ⟩</code> where <code>M</code> is a term of type <code>A</code> and <code>N</code> is a term of type <code>B</code>. The constructor declaration allows us to write <code>⟨ M , N ⟩′</code> in place of the record construction.</p>
<p>The data type <code>_x_</code> and the record type <code>_×′_</code> behave similarly. One difference is that for data types we have to prove η-equality, but for record types, η-equality holds <em>by definition</em>. While proving <code>η-×′</code>, we do not have to pattern match on <code>w</code> to know that η-equality holds:</p>
<pre class="Agda"><a id="η-×′"></a><a id="5569" href="../Connectives/#5569" class="Function">η-×′</a> <a id="5574" class="Symbol">:</a> <a id="5576" class="Symbol">∀</a> <a id="5578" class="Symbol">{</a><a id="5579" href="../Connectives/#5579" class="Bound">A</a> <a id="5581" href="../Connectives/#5581" class="Bound">B</a> <a id="5583" class="Symbol">:</a> <a id="5585" class="PrimitiveType">Set</a><a id="5588" class="Symbol">}</a> <a id="5590" class="Symbol">(</a><a id="5591" href="../Connectives/#5591" class="Bound">w</a> <a id="5593" class="Symbol">:</a> <a id="5595" href="../Connectives/#5579" class="Bound">A</a> <a id="5597" href="../Connectives/#4923" class="Record Operator">×′</a> <a id="5600" href="../Connectives/#5581" class="Bound">B</a><a id="5601" class="Symbol">)</a> <a id="5603" class="Symbol">→</a> <a id="5605" href="../Connectives/#4966" class="InductiveConstructor Operator">⟨</a> <a id="5607" href="../Connectives/#4985" class="Field">proj₁′</a> <a id="5614" href="../Connectives/#5591" class="Bound">w</a> <a id="5616" href="../Connectives/#4966" class="InductiveConstructor Operator">,</a> <a id="5618" href="../Connectives/#5000" class="Field">proj₂′</a> <a id="5625" href="../Connectives/#5591" class="Bound">w</a> <a id="5627" href="../Connectives/#4966" class="InductiveConstructor Operator">⟩′</a> <a id="5630" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="5632" href="../Connectives/#5591" class="Bound">w</a>
<a id="5634" href="../Connectives/#5569" class="Function">η-×′</a> <a id="5639" href="../Connectives/#5639" class="Bound">w</a> <a id="5641" class="Symbol">=</a> <a id="5643" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>It can be very convenient to have η-equality <em>definitionally</em>, and so the standard library defines <code>_×_</code> as a record type. We use the definition from the standard library in later chapters.</p>
<!--
Given two types `A` and `B`, we refer to `A × B` as the
_product_ of `A` and `B`.  In set theory, it is also sometimes
called the _Cartesian product_, and in computing it corresponds
to a _record_ type. Among other reasons for
calling it the product, note that if type `A` has `m`
distinct members, and type `B` has `n` distinct members,
then the type `A × B` has `m * n` distinct members.
For instance, consider a type `Bool` with two members, and
a type `Tri` with three members:
-->
<p>给定两个类型 <code>A</code> 和 <code>B</code>，我们将 <code>A × B</code> 称为 <code>A</code> 与 <code>B</code> 的<strong>积</strong>。 在集合论中它也被称作<strong>笛卡尔积（Cartesian Product）</strong>，在计算机科学中它对应<strong>记录</strong>类型。 如果类型 <code>A</code> 有 <code>m</code> 个不同的成员，类型 <code>B</code> 有 <code>n</code> 个不同的成员， 那么类型 <code>A × B</code> 有 <code>m * n</code> 个不同的成员。这也是它被称为积的原因之一。 例如，考虑有两个成员的 <code>Bool</code> 类型，和有三个成员的 <code>Tri</code> 类型：</p>
<pre class="Agda"><a id="6577" class="Keyword">data</a> <a id="Bool"></a><a id="6582" href="../Connectives/#6582" class="Datatype">Bool</a> <a id="6587" class="Symbol">:</a> <a id="6589" class="PrimitiveType">Set</a> <a id="6593" class="Keyword">where</a>
  <a id="Bool.true"></a><a id="6601" href="../Connectives/#6601" class="InductiveConstructor">true</a>  <a id="6607" class="Symbol">:</a> <a id="6609" href="../Connectives/#6582" class="Datatype">Bool</a>
  <a id="Bool.false"></a><a id="6616" href="../Connectives/#6616" class="InductiveConstructor">false</a> <a id="6622" class="Symbol">:</a> <a id="6624" href="../Connectives/#6582" class="Datatype">Bool</a>

<a id="6630" class="Keyword">data</a> <a id="Tri"></a><a id="6635" href="../Connectives/#6635" class="Datatype">Tri</a> <a id="6639" class="Symbol">:</a> <a id="6641" class="PrimitiveType">Set</a> <a id="6645" class="Keyword">where</a>
  <a id="Tri.aa"></a><a id="6653" href="../Connectives/#6653" class="InductiveConstructor">aa</a> <a id="6656" class="Symbol">:</a> <a id="6658" href="../Connectives/#6635" class="Datatype">Tri</a>
  <a id="Tri.bb"></a><a id="6664" href="../Connectives/#6664" class="InductiveConstructor">bb</a> <a id="6667" class="Symbol">:</a> <a id="6669" href="../Connectives/#6635" class="Datatype">Tri</a>
  <a id="Tri.cc"></a><a id="6675" href="../Connectives/#6675" class="InductiveConstructor">cc</a> <a id="6678" class="Symbol">:</a> <a id="6680" href="../Connectives/#6635" class="Datatype">Tri</a>
</pre>
<!--
Then the type `Bool × Tri` has six members:
-->
<p>那么，<code>Bool × Tri</code> 类型有如下的六个成员：</p>
<pre><code>⟨ true  , aa ⟩    ⟨ true  , bb ⟩    ⟨ true ,  cc ⟩
⟨ false , aa ⟩    ⟨ false , bb ⟩    ⟨ false , cc ⟩</code></pre>
<!--
For example, the following function enumerates all
possible arguments of type `Bool × Tri`:
-->
<p>下面的函数枚举了所有类型为 <code>Bool × Tri</code> 的参数：</p>
<pre class="Agda"><a id="×-count"></a><a id="7022" href="../Connectives/#7022" class="Function">×-count</a> <a id="7030" class="Symbol">:</a> <a id="7032" href="../Connectives/#6582" class="Datatype">Bool</a> <a id="7037" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="7039" href="../Connectives/#6635" class="Datatype">Tri</a> <a id="7043" class="Symbol">→</a> <a id="7045" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="7047" href="../Connectives/#7022" class="Function">×-count</a> <a id="7055" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="7057" href="../Connectives/#6601" class="InductiveConstructor">true</a>  <a id="7063" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="7065" href="../Connectives/#6653" class="InductiveConstructor">aa</a> <a id="7068" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a>  <a id="7071" class="Symbol">=</a>  <a id="7074" class="Number">1</a>
<a id="7076" href="../Connectives/#7022" class="Function">×-count</a> <a id="7084" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="7086" href="../Connectives/#6601" class="InductiveConstructor">true</a>  <a id="7092" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="7094" href="../Connectives/#6664" class="InductiveConstructor">bb</a> <a id="7097" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a>  <a id="7100" class="Symbol">=</a>  <a id="7103" class="Number">2</a>
<a id="7105" href="../Connectives/#7022" class="Function">×-count</a> <a id="7113" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="7115" href="../Connectives/#6601" class="InductiveConstructor">true</a>  <a id="7121" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="7123" href="../Connectives/#6675" class="InductiveConstructor">cc</a> <a id="7126" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a>  <a id="7129" class="Symbol">=</a>  <a id="7132" class="Number">3</a>
<a id="7134" href="../Connectives/#7022" class="Function">×-count</a> <a id="7142" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="7144" href="../Connectives/#6616" class="InductiveConstructor">false</a> <a id="7150" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="7152" href="../Connectives/#6653" class="InductiveConstructor">aa</a> <a id="7155" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a>  <a id="7158" class="Symbol">=</a>  <a id="7161" class="Number">4</a>
<a id="7163" href="../Connectives/#7022" class="Function">×-count</a> <a id="7171" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="7173" href="../Connectives/#6616" class="InductiveConstructor">false</a> <a id="7179" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="7181" href="../Connectives/#6664" class="InductiveConstructor">bb</a> <a id="7184" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a>  <a id="7187" class="Symbol">=</a>  <a id="7190" class="Number">5</a>
<a id="7192" href="../Connectives/#7022" class="Function">×-count</a> <a id="7200" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="7202" href="../Connectives/#6616" class="InductiveConstructor">false</a> <a id="7208" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="7210" href="../Connectives/#6675" class="InductiveConstructor">cc</a> <a id="7213" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a>  <a id="7216" class="Symbol">=</a>  <a id="7219" class="Number">6</a>
</pre>
<!--
Product on types also shares a property with product on numbers in
that there is a sense in which it is commutative and associative.  In
particular, product is commutative and associative _up to
isomorphism_.
-->
<p>类型上的积与数的积有相似的性质——它们满足交换律和结合律。 更确切地说，积在<strong>在同构意义下</strong>满足交换律和结合率。</p>
<!--
For commutativity, the `to` function swaps a pair, taking `⟨ x , y ⟩` to
`⟨ y , x ⟩`, and the `from` function does the same (up to renaming).
Instantiating the patterns correctly in `from∘to` and `to∘from` is essential.
Replacing the definition of `from∘to` by `λ w → refl` will not work;
and similarly for `to∘from`:
-->
<p>对于交换律，<code>to</code> 函数将有序对交换，将 <code>⟨ x , y ⟩</code> 变为 <code>⟨ y , x ⟩</code>，<code>from</code> 函数亦是如此（忽略命名）。 在 <code>from∘to</code> 和 <code>to∘from</code> 中正确地实例化要匹配的模式是很重要的。 使用 <code>λ w → refl</code> 作为 <code>from∘to</code> 的定义是不可行的，<code>to∘from</code> 同理。</p>
<pre class="Agda"><a id="×-comm"></a><a id="8004" href="../Connectives/#8004" class="Function">×-comm</a> <a id="8011" class="Symbol">:</a> <a id="8013" class="Symbol">∀</a> <a id="8015" class="Symbol">{</a><a id="8016" href="../Connectives/#8016" class="Bound">A</a> <a id="8018" href="../Connectives/#8018" class="Bound">B</a> <a id="8020" class="Symbol">:</a> <a id="8022" class="PrimitiveType">Set</a><a id="8025" class="Symbol">}</a> <a id="8027" class="Symbol">→</a> <a id="8029" href="../Connectives/#8016" class="Bound">A</a> <a id="8031" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="8033" href="../Connectives/#8018" class="Bound">B</a> <a id="8035" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="8037" href="../Connectives/#8018" class="Bound">B</a> <a id="8039" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="8041" href="../Connectives/#8016" class="Bound">A</a>
<a id="8043" href="../Connectives/#8004" class="Function">×-comm</a> <a id="8050" class="Symbol">=</a>
  <a id="8054" class="Keyword">record</a>
    <a id="8065" class="Symbol">{</a> <a id="8067" href="../Isomorphism/#5650" class="Field">to</a>       <a id="8076" class="Symbol">=</a>  <a id="8079" class="Symbol">λ{</a> <a id="8082" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="8084" href="../Connectives/#8084" class="Bound">x</a> <a id="8086" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="8088" href="../Connectives/#8088" class="Bound">y</a> <a id="8090" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="8092" class="Symbol">→</a> <a id="8094" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="8096" href="../Connectives/#8088" class="Bound">y</a> <a id="8098" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="8100" href="../Connectives/#8084" class="Bound">x</a> <a id="8102" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="8104" class="Symbol">}</a>
    <a id="8110" class="Symbol">;</a> <a id="8112" href="../Isomorphism/#5667" class="Field">from</a>     <a id="8121" class="Symbol">=</a>  <a id="8124" class="Symbol">λ{</a> <a id="8127" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="8129" href="../Connectives/#8129" class="Bound">y</a> <a id="8131" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="8133" href="../Connectives/#8133" class="Bound">x</a> <a id="8135" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="8137" class="Symbol">→</a> <a id="8139" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="8141" href="../Connectives/#8133" class="Bound">x</a> <a id="8143" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="8145" href="../Connectives/#8129" class="Bound">y</a> <a id="8147" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="8149" class="Symbol">}</a>
    <a id="8155" class="Symbol">;</a> <a id="8157" href="../Isomorphism/#5684" class="Field">from∘to</a>  <a id="8166" class="Symbol">=</a>  <a id="8169" class="Symbol">λ{</a> <a id="8172" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="8174" href="../Connectives/#8174" class="Bound">x</a> <a id="8176" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="8178" href="../Connectives/#8178" class="Bound">y</a> <a id="8180" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="8182" class="Symbol">→</a> <a id="8184" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="8189" class="Symbol">}</a>
    <a id="8195" class="Symbol">;</a> <a id="8197" href="../Isomorphism/#5726" class="Field">to∘from</a>  <a id="8206" class="Symbol">=</a>  <a id="8209" class="Symbol">λ{</a> <a id="8212" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="8214" href="../Connectives/#8214" class="Bound">y</a> <a id="8216" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="8218" href="../Connectives/#8218" class="Bound">x</a> <a id="8220" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="8222" class="Symbol">→</a> <a id="8224" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="8229" class="Symbol">}</a>
    <a id="8235" class="Symbol">}</a>
</pre>
<!--
Being _commutative_ is different from being _commutative up to
isomorphism_.  Compare the two statements:
-->
<p>满足<strong>交换律</strong>和<strong>在同构意义下满足交换律</strong>是不一样的。比较下列两个命题：</p>
<pre><code>m * n ≡ n * m
A × B ≃ B × A</code></pre>
<!--
In the first case, we might have that `m` is `2` and `n` is `3`, and
both `m * n` and `n * m` are equal to `6`.  In the second case, we
might have that `A` is `Bool` and `B` is `Tri`, and `Bool × Tri` is
_not_ the same as `Tri × Bool`.  But there is an isomorphism between
the two types.  For instance, `⟨ true , aa ⟩`, which is a member of the
former, corresponds to `⟨ aa , true ⟩`, which is a member of the latter.
-->
<p>在第一个情况下，我们可能有 <code>m</code> 是 <code>2</code>、<code>n</code> 是 <code>3</code>，那么 <code>m * n</code> 和 <code>n * m</code> 都是 <code>6</code>。 在第二个情况下，我们可能有 <code>A</code> 是 <code>Bool</code> 和 <code>B</code> 是 <code>Tri</code>，但是 <code>Bool × Tri</code> 和 <code>Tri × Bool</code> <strong>不是</strong>一样的。但是存在一个两者之间的同构。例如：<code>⟨ true , aa ⟩</code> 是前者的成员， 其对应后者的成员 <code>⟨ aa , true ⟩</code>。</p>
<!--
For associativity, the `to` function reassociates two uses of pairing,
taking `⟨ ⟨ x , y ⟩ , z ⟩` to `⟨ x , ⟨ y , z ⟩ ⟩`, and the `from` function does
the inverse.  Again, the evidence of left and right inverse requires
matching against a suitable pattern to enable simplification:
-->
<p>对于结合律来说，<code>to</code> 函数将两个有序对进行重组：将 <code>⟨ ⟨ x , y ⟩ , z ⟩</code> 转换为 <code>⟨ x , ⟨ y , z ⟩ ⟩</code>， <code>from</code> 函数则为其逆。同样，左逆和右逆的证明需要在一个合适的模式来匹配，从而可以直接化简：</p>
<pre class="Agda"><a id="×-assoc"></a><a id="9497" href="../Connectives/#9497" class="Function">×-assoc</a> <a id="9505" class="Symbol">:</a> <a id="9507" class="Symbol">∀</a> <a id="9509" class="Symbol">{</a><a id="9510" href="../Connectives/#9510" class="Bound">A</a> <a id="9512" href="../Connectives/#9512" class="Bound">B</a> <a id="9514" href="../Connectives/#9514" class="Bound">C</a> <a id="9516" class="Symbol">:</a> <a id="9518" class="PrimitiveType">Set</a><a id="9521" class="Symbol">}</a> <a id="9523" class="Symbol">→</a> <a id="9525" class="Symbol">(</a><a id="9526" href="../Connectives/#9510" class="Bound">A</a> <a id="9528" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="9530" href="../Connectives/#9512" class="Bound">B</a><a id="9531" class="Symbol">)</a> <a id="9533" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="9535" href="../Connectives/#9514" class="Bound">C</a> <a id="9537" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="9539" href="../Connectives/#9510" class="Bound">A</a> <a id="9541" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="9543" class="Symbol">(</a><a id="9544" href="../Connectives/#9512" class="Bound">B</a> <a id="9546" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="9548" href="../Connectives/#9514" class="Bound">C</a><a id="9549" class="Symbol">)</a>
<a id="9551" href="../Connectives/#9497" class="Function">×-assoc</a> <a id="9559" class="Symbol">=</a>
  <a id="9563" class="Keyword">record</a>
    <a id="9574" class="Symbol">{</a> <a id="9576" href="../Isomorphism/#5650" class="Field">to</a>      <a id="9584" class="Symbol">=</a> <a id="9586" class="Symbol">λ{</a> <a id="9589" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="9591" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="9593" href="../Connectives/#9593" class="Bound">x</a> <a id="9595" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="9597" href="../Connectives/#9597" class="Bound">y</a> <a id="9599" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="9601" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="9603" href="../Connectives/#9603" class="Bound">z</a> <a id="9605" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="9607" class="Symbol">→</a> <a id="9609" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="9611" href="../Connectives/#9593" class="Bound">x</a> <a id="9613" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="9615" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="9617" href="../Connectives/#9597" class="Bound">y</a> <a id="9619" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="9621" href="../Connectives/#9603" class="Bound">z</a> <a id="9623" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="9625" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="9627" class="Symbol">}</a>
    <a id="9633" class="Symbol">;</a> <a id="9635" href="../Isomorphism/#5667" class="Field">from</a>    <a id="9643" class="Symbol">=</a> <a id="9645" class="Symbol">λ{</a> <a id="9648" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="9650" href="../Connectives/#9650" class="Bound">x</a> <a id="9652" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="9654" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="9656" href="../Connectives/#9656" class="Bound">y</a> <a id="9658" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="9660" href="../Connectives/#9660" class="Bound">z</a> <a id="9662" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="9664" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="9666" class="Symbol">→</a> <a id="9668" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="9670" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="9672" href="../Connectives/#9650" class="Bound">x</a> <a id="9674" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="9676" href="../Connectives/#9656" class="Bound">y</a> <a id="9678" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="9680" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="9682" href="../Connectives/#9660" class="Bound">z</a> <a id="9684" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="9686" class="Symbol">}</a>
    <a id="9692" class="Symbol">;</a> <a id="9694" href="../Isomorphism/#5684" class="Field">from∘to</a> <a id="9702" class="Symbol">=</a> <a id="9704" class="Symbol">λ{</a> <a id="9707" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="9709" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="9711" href="../Connectives/#9711" class="Bound">x</a> <a id="9713" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="9715" href="../Connectives/#9715" class="Bound">y</a> <a id="9717" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="9719" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="9721" href="../Connectives/#9721" class="Bound">z</a> <a id="9723" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="9725" class="Symbol">→</a> <a id="9727" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="9732" class="Symbol">}</a>
    <a id="9738" class="Symbol">;</a> <a id="9740" href="../Isomorphism/#5726" class="Field">to∘from</a> <a id="9748" class="Symbol">=</a> <a id="9750" class="Symbol">λ{</a> <a id="9753" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="9755" href="../Connectives/#9755" class="Bound">x</a> <a id="9757" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="9759" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="9761" href="../Connectives/#9761" class="Bound">y</a> <a id="9763" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="9765" href="../Connectives/#9765" class="Bound">z</a> <a id="9767" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="9769" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="9771" class="Symbol">→</a> <a id="9773" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="9778" class="Symbol">}</a>
    <a id="9784" class="Symbol">}</a>
</pre>
<!--
Being _associative_ is not the same as being _associative
up to isomorphism_.  Compare the two statements:
-->
<p>满足<strong>结合律</strong>和<strong>在同构意义下满足结合律</strong>是不一样的。比较下列两个命题：</p>
<pre><code>(m * n) * p ≡ m * (n * p)
(A × B) × C ≃ A × (B × C)</code></pre>
<!--
For example, the type `(ℕ × Bool) × Tri` is _not_ the same as `ℕ ×
(Bool × Tri)`. But there is an isomorphism between the two types. For
instance `⟨ ⟨ 1 , true ⟩ , aa ⟩`, which is a member of the former,
corresponds to `⟨ 1 , ⟨ true , aa ⟩ ⟩`, which is a member of the latter.
-->
<p>举个例子，<code>(ℕ × Bool) × Tri</code> 与 <code>ℕ × (Bool × Tri)</code> <strong>不同</strong>，但是两个类型之间 存在同构。例如 <code>⟨ ⟨ 1 , true ⟩ , aa ⟩</code>，一个前者的成员，与 <code>⟨ 1 , ⟨ true , aa ⟩ ⟩</code>， 一个后者的成员，相对应。</p>
<!--
#### Exercise `⇔≃×` (recommended)
-->
<h4 id="练习-推荐">练习 <code>⇔≃×</code> （推荐）</h4>
<!--
Show that `A ⇔ B` as defined [earlier](/Isomorphism/#iff)
is isomorphic to `(A → B) × (B → A)`.
-->
<p>证明<a href="../Isomorphism/#iff">之前</a>定义的 <code>A ⇔ B</code> 与 <code>(A → B) × (B → A)</code> 同构。</p>
<!--
<pre class="Agda"><a id="10683" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="10719" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
## Truth is unit
-->
<h2 id="真即是单元类型">真即是单元类型</h2>
<!--
Truth `⊤` always holds. We formalise this idea by
declaring a suitable datatype:
-->
<p>恒真 <code>⊤</code> 恒成立。我们将这个概念用合适的数据类型来形式化：</p>
<pre class="Agda"><a id="10904" class="Keyword">data</a> <a id="⊤"></a><a id="10909" href="../Connectives/#10909" class="Datatype">⊤</a> <a id="10911" class="Symbol">:</a> <a id="10913" class="PrimitiveType">Set</a> <a id="10917" class="Keyword">where</a>

  <a id="⊤.tt"></a><a id="10926" href="../Connectives/#10926" class="InductiveConstructor">tt</a> <a id="10929" class="Symbol">:</a>
    <a id="10935" class="Comment">--</a>
    <a id="10942" href="../Connectives/#10909" class="Datatype">⊤</a>
</pre>
<!--
Evidence that `⊤` holds is of the form `tt`.
-->
<p><code>⊤</code> 成立的证明由 <code>tt</code> 的形式构成。</p>
<!--
There is an introduction rule, but no elimination rule.
Given evidence that `⊤` holds, there is nothing more of interest we
can conclude.  Since truth always holds, knowing that it holds tells
us nothing new.
-->
<p>恒真有引入规则，但没有消去规则。给定一个 <code>⊤</code> 成立的证明，我们不能得出任何有趣的结论。 因为恒真恒成立，知道恒真成立不会给我们带来新的知识。</p>
<!--
The nullary case of `η-×` is `η-⊤`, which asserts that any
value of type `⊤` must be equal to `tt`:
-->
<p><code>η-×</code> 的 零元形式是 <code>η-⊤</code>，其断言了任何 <code>⊤</code> 类型的值一定等于 <code>tt</code>：</p>
<pre class="Agda"><a id="η-⊤"></a><a id="11482" href="../Connectives/#11482" class="Function">η-⊤</a> <a id="11486" class="Symbol">:</a> <a id="11488" class="Symbol">∀</a> <a id="11490" class="Symbol">(</a><a id="11491" href="../Connectives/#11491" class="Bound">w</a> <a id="11493" class="Symbol">:</a> <a id="11495" href="../Connectives/#10909" class="Datatype">⊤</a><a id="11496" class="Symbol">)</a> <a id="11498" class="Symbol">→</a> <a id="11500" href="../Connectives/#10926" class="InductiveConstructor">tt</a> <a id="11503" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="11505" href="../Connectives/#11491" class="Bound">w</a>
<a id="11507" href="../Connectives/#11482" class="Function">η-⊤</a> <a id="11511" href="../Connectives/#10926" class="InductiveConstructor">tt</a> <a id="11514" class="Symbol">=</a> <a id="11516" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<!--
The pattern matching on the left-hand side is essential. Replacing
`w` by `tt` allows both sides of the propositional equality to
simplify to the same term.
-->
<p>左手边的模式匹配是必要的。将 <code>w</code> 替换为 <code>tt</code> 让等式两边可以化简为相同的值。</p>
Alternatively, we can declare truth as an empty record:
<pre class="Agda"><a id="11798" class="Keyword">record</a> <a id="⊤′"></a><a id="11805" href="../Connectives/#11805" class="Record">⊤′</a> <a id="11808" class="Symbol">:</a> <a id="11810" class="PrimitiveType">Set</a> <a id="11814" class="Keyword">where</a>
  <a id="11822" class="Keyword">constructor</a> <a id="tt′"></a><a id="11834" href="../Connectives/#11834" class="InductiveConstructor">tt′</a>
</pre>
<p>The record construction <code>record {}</code> corresponds to the term <code>tt</code>. The constructor declaration allows us to write <code>tt′</code>.</p>
As with the product, the data type <code>⊤</code> and the record type <code>⊤′</code> behave similarly, but η-equality holds <em>by definition</em> for the record type. While proving <code>η-⊤′</code>, we do not have to pattern match on <code>w</code>—Agda <em>knows</em> it is equal to <code>tt′</code>:
<pre class="Agda"><a id="η-⊤′"></a><a id="12205" href="../Connectives/#12205" class="Function">η-⊤′</a> <a id="12210" class="Symbol">:</a> <a id="12212" class="Symbol">∀</a> <a id="12214" class="Symbol">(</a><a id="12215" href="../Connectives/#12215" class="Bound">w</a> <a id="12217" class="Symbol">:</a> <a id="12219" href="../Connectives/#11805" class="Record">⊤′</a><a id="12221" class="Symbol">)</a> <a id="12223" class="Symbol">→</a> <a id="12225" href="../Connectives/#11834" class="InductiveConstructor">tt′</a> <a id="12229" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="12231" href="../Connectives/#12215" class="Bound">w</a>
<a id="12233" href="../Connectives/#12205" class="Function">η-⊤′</a> <a id="12238" href="../Connectives/#12238" class="Bound">w</a> <a id="12240" class="Symbol">=</a> <a id="12242" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
Agda knows that <em>any</em> value of type <code>⊤′</code> must be <code>tt′</code>, so any time we need a value of type <code>⊤′</code>, we can tell Agda to figure it out:
<pre class="Agda"><a id="truth′"></a><a id="12388" href="../Connectives/#12388" class="Function">truth′</a> <a id="12395" class="Symbol">:</a> <a id="12397" href="../Connectives/#11805" class="Record">⊤′</a>
<a id="12400" href="../Connectives/#12388" class="Function">truth′</a> <a id="12407" class="Symbol">=</a> <a id="12409" class="Symbol">_</a>
</pre>
<!--
We refer to `⊤` as the _unit_ type. And, indeed,
type `⊤` has exactly one member, `tt`.  For example, the following
function enumerates all possible arguments of type `⊤`:
-->
<p>我们将 <code>⊤</code> 称为<strong>单元（Unit Type）</strong>类型。实际上，<code>⊤</code> 类型只有一个成员 <code>tt</code>。 例如，下面的函数枚举了所有 <code>⊤</code> 类型的参数：</p>
–&gt;
<pre class="Agda"><a id="⊤-count"></a><a id="12685" href="../Connectives/#12685" class="Function">⊤-count</a> <a id="12693" class="Symbol">:</a> <a id="12695" href="../Connectives/#10909" class="Datatype">⊤</a> <a id="12697" class="Symbol">→</a> <a id="12699" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="12701" href="../Connectives/#12685" class="Function">⊤-count</a> <a id="12709" href="../Connectives/#10926" class="InductiveConstructor">tt</a> <a id="12712" class="Symbol">=</a> <a id="12714" class="Number">1</a>
</pre>
<!--
For numbers, one is the identity of multiplication. Correspondingly,
unit is the identity of product _up to isomorphism_.  For left
identity, the `to` function takes `⟨ tt , x ⟩` to `x`, and the `from`
function does the inverse.  The evidence of left inverse requires
matching against a suitable pattern to enable simplification:
-->
<p>对于数来说，1 是乘法的幺元。对应地，单元是积的幺元（<strong>在同构意义下</strong>）。对于左幺元来说， <code>to</code> 函数将 <code>⟨ tt , x ⟩</code> 转换成 <code>x</code>， <code>from</code> 函数则是其反函数。左逆的证明需要 匹配一个合适的模式来化简：</p>
<pre class="Agda"><a id="⊤-identityˡ"></a><a id="13183" href="../Connectives/#13183" class="Function">⊤-identityˡ</a> <a id="13195" class="Symbol">:</a> <a id="13197" class="Symbol">∀</a> <a id="13199" class="Symbol">{</a><a id="13200" href="../Connectives/#13200" class="Bound">A</a> <a id="13202" class="Symbol">:</a> <a id="13204" class="PrimitiveType">Set</a><a id="13207" class="Symbol">}</a> <a id="13209" class="Symbol">→</a> <a id="13211" href="../Connectives/#10909" class="Datatype">⊤</a> <a id="13213" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="13215" href="../Connectives/#13200" class="Bound">A</a> <a id="13217" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="13219" href="../Connectives/#13200" class="Bound">A</a>
<a id="13221" href="../Connectives/#13183" class="Function">⊤-identityˡ</a> <a id="13233" class="Symbol">=</a>
  <a id="13237" class="Keyword">record</a>
    <a id="13248" class="Symbol">{</a> <a id="13250" href="../Isomorphism/#5650" class="Field">to</a>      <a id="13258" class="Symbol">=</a> <a id="13260" class="Symbol">λ{</a> <a id="13263" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="13265" href="../Connectives/#10926" class="InductiveConstructor">tt</a> <a id="13268" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="13270" href="../Connectives/#13270" class="Bound">x</a> <a id="13272" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="13274" class="Symbol">→</a> <a id="13276" href="../Connectives/#13270" class="Bound">x</a> <a id="13278" class="Symbol">}</a>
    <a id="13284" class="Symbol">;</a> <a id="13286" href="../Isomorphism/#5667" class="Field">from</a>    <a id="13294" class="Symbol">=</a> <a id="13296" class="Symbol">λ{</a> <a id="13299" href="../Connectives/#13299" class="Bound">x</a> <a id="13301" class="Symbol">→</a> <a id="13303" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="13305" href="../Connectives/#10926" class="InductiveConstructor">tt</a> <a id="13308" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="13310" href="../Connectives/#13299" class="Bound">x</a> <a id="13312" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="13314" class="Symbol">}</a>
    <a id="13320" class="Symbol">;</a> <a id="13322" href="../Isomorphism/#5684" class="Field">from∘to</a> <a id="13330" class="Symbol">=</a> <a id="13332" class="Symbol">λ{</a> <a id="13335" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="13337" href="../Connectives/#10926" class="InductiveConstructor">tt</a> <a id="13340" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="13342" href="../Connectives/#13342" class="Bound">x</a> <a id="13344" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="13346" class="Symbol">→</a> <a id="13348" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="13353" class="Symbol">}</a>
    <a id="13359" class="Symbol">;</a> <a id="13361" href="../Isomorphism/#5726" class="Field">to∘from</a> <a id="13369" class="Symbol">=</a> <a id="13371" class="Symbol">λ{</a> <a id="13374" href="../Connectives/#13374" class="Bound">x</a> <a id="13376" class="Symbol">→</a> <a id="13378" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="13383" class="Symbol">}</a>
    <a id="13389" class="Symbol">}</a>
</pre>
<!--
Having an _identity_ is different from having an identity
_up to isomorphism_.  Compare the two statements:
-->
<p><strong>幺元</strong>和<strong>在同构意义下的幺元</strong>是不一样的。比较下列两个命题：</p>
<pre><code>1 * m ≡ m
⊤ × A ≃ A</code></pre>
<!--
In the first case, we might have that `m` is `2`, and both
`1 * m` and `m` are equal to `2`.  In the second
case, we might have that `A` is `Bool`, and `⊤ × Bool` is _not_ the
same as `Bool`.  But there is an isomorphism between the two types.
For instance, `⟨ tt , true ⟩`, which is a member of the former,
corresponds to `true`, which is a member of the latter.
-->
<p>在第一种情况下，我们可能有 <code>m</code> 是 <code>2</code>，那么 <code>1 * m</code> 和 <code>m</code> 都为 <code>2</code>。 在第二种情况下，我们可能有 <code>A</code> 是 <code>Bool</code>，但是 <code>⊤ × Bool</code> 和 <code>Bool</code> 是不同的。 例如：<code>⟨ tt , true ⟩</code> 是前者的成员，其对应后者的成员 <code>true</code>。</p>
<!--
Right identity follows from commutativity of product and left identity:
-->
<p>右幺元可以由积的交换律得来：</p>
<pre class="Agda"><a id="⊤-identityʳ"></a><a id="14205" href="../Connectives/#14205" class="Function">⊤-identityʳ</a> <a id="14217" class="Symbol">:</a> <a id="14219" class="Symbol">∀</a> <a id="14221" class="Symbol">{</a><a id="14222" href="../Connectives/#14222" class="Bound">A</a> <a id="14224" class="Symbol">:</a> <a id="14226" class="PrimitiveType">Set</a><a id="14229" class="Symbol">}</a> <a id="14231" class="Symbol">→</a> <a id="14233" class="Symbol">(</a><a id="14234" href="../Connectives/#14222" class="Bound">A</a> <a id="14236" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="14238" href="../Connectives/#10909" class="Datatype">⊤</a><a id="14239" class="Symbol">)</a> <a id="14241" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="14243" href="../Connectives/#14222" class="Bound">A</a>
<a id="14245" href="../Connectives/#14205" class="Function">⊤-identityʳ</a> <a id="14257" class="Symbol">{</a><a id="14258" href="../Connectives/#14258" class="Bound">A</a><a id="14259" class="Symbol">}</a> <a id="14261" class="Symbol">=</a>
  <a id="14265" href="../Isomorphism/#10891" class="Function Operator">≃-begin</a>
    <a id="14277" class="Symbol">(</a><a id="14278" href="../Connectives/#14258" class="Bound">A</a> <a id="14280" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="14282" href="../Connectives/#10909" class="Datatype">⊤</a><a id="14283" class="Symbol">)</a>
  <a id="14287" href="../Isomorphism/#10975" class="Function Operator">≃⟨</a> <a id="14290" href="../Connectives/#8004" class="Function">×-comm</a> <a id="14297" href="../Isomorphism/#10975" class="Function Operator">⟩</a>
    <a id="14303" class="Symbol">(</a><a id="14304" href="../Connectives/#10909" class="Datatype">⊤</a> <a id="14306" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="14308" href="../Connectives/#14258" class="Bound">A</a><a id="14309" class="Symbol">)</a>
  <a id="14313" href="../Isomorphism/#10975" class="Function Operator">≃⟨</a> <a id="14316" href="../Connectives/#13183" class="Function">⊤-identityˡ</a> <a id="14328" href="../Isomorphism/#10975" class="Function Operator">⟩</a>
    <a id="14334" href="../Connectives/#14258" class="Bound">A</a>
  <a id="14338" href="../Isomorphism/#11094" class="Function Operator">≃-∎</a>
</pre>
<!--
Here we have used a chain of isomorphisms, analogous to that used for
equality.
-->
<p>我们在此使用了同构链，与等式链相似。</p>
<!--
## Disjunction is sum
-->
<h2 id="析取即是和">析取即是和</h2>
<!--
Given two propositions `A` and `B`, the disjunction `A ⊎ B` holds
if either `A` holds or `B` holds.  We formalise this idea by
declaring a suitable inductive type:
-->
<p>给定两个命题 <code>A</code> 和 <code>B</code>，析取 <code>A ⊎ B</code> 在 <code>A</code> 成立或者 <code>B</code> 成立时成立。 我们将这个概念用合适的归纳类型来形式化：</p>
<pre class="Agda"><a id="14749" class="Keyword">data</a> <a id="_⊎_"></a><a id="14754" href="../Connectives/#14754" class="Datatype Operator">_⊎_</a> <a id="14758" class="Symbol">(</a><a id="14759" href="../Connectives/#14759" class="Bound">A</a> <a id="14761" href="../Connectives/#14761" class="Bound">B</a> <a id="14763" class="Symbol">:</a> <a id="14765" class="PrimitiveType">Set</a><a id="14768" class="Symbol">)</a> <a id="14770" class="Symbol">:</a> <a id="14772" class="PrimitiveType">Set</a> <a id="14776" class="Keyword">where</a>

  <a id="_⊎_.inj₁"></a><a id="14785" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="14790" class="Symbol">:</a>
      <a id="14798" href="../Connectives/#14759" class="Bound">A</a>
      <a id="14806" class="Comment">-----</a>
    <a id="14816" class="Symbol">→</a> <a id="14818" href="../Connectives/#14759" class="Bound">A</a> <a id="14820" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="14822" href="../Connectives/#14761" class="Bound">B</a>

  <a id="_⊎_.inj₂"></a><a id="14827" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="14832" class="Symbol">:</a>
      <a id="14840" href="../Connectives/#14761" class="Bound">B</a>
      <a id="14848" class="Comment">-----</a>
    <a id="14858" class="Symbol">→</a> <a id="14860" href="../Connectives/#14759" class="Bound">A</a> <a id="14862" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="14864" href="../Connectives/#14761" class="Bound">B</a>
</pre>
<!--
Evidence that `A ⊎ B` holds is either of the form `inj₁ M`, where `M`
provides evidence that `A` holds, or `inj₂ N`, where `N` provides
evidence that `B` holds.
-->
<p><code>A ⊎ B</code> 成立的证明有两个形式： <code>inj₁ M</code>，其中 <code>M</code> 是 <code>A</code> 成立的证明，或者 <code>inj₂ N</code>，其中 <code>N</code> 是 <code>B</code> 成立的证明。</p>
<!--
Given evidence that `A → C` and `B → C` both hold, then given
evidence that `A ⊎ B` holds we can conclude that `C` holds:
-->
<p>给定 <code>A → C</code> 和 <code>B → C</code> 成立的证明，那么给定一个 <code>A ⊎ B</code> 的证明，我们可以得出 <code>C</code> 成立：</p>
<pre class="Agda"><a id="case-⊎"></a><a id="15321" href="../Connectives/#15321" class="Function">case-⊎</a> <a id="15328" class="Symbol">:</a> <a id="15330" class="Symbol">∀</a> <a id="15332" class="Symbol">{</a><a id="15333" href="../Connectives/#15333" class="Bound">A</a> <a id="15335" href="../Connectives/#15335" class="Bound">B</a> <a id="15337" href="../Connectives/#15337" class="Bound">C</a> <a id="15339" class="Symbol">:</a> <a id="15341" class="PrimitiveType">Set</a><a id="15344" class="Symbol">}</a>
  <a id="15348" class="Symbol">→</a> <a id="15350" class="Symbol">(</a><a id="15351" href="../Connectives/#15333" class="Bound">A</a> <a id="15353" class="Symbol">→</a> <a id="15355" href="../Connectives/#15337" class="Bound">C</a><a id="15356" class="Symbol">)</a>
  <a id="15360" class="Symbol">→</a> <a id="15362" class="Symbol">(</a><a id="15363" href="../Connectives/#15335" class="Bound">B</a> <a id="15365" class="Symbol">→</a> <a id="15367" href="../Connectives/#15337" class="Bound">C</a><a id="15368" class="Symbol">)</a>
  <a id="15372" class="Symbol">→</a> <a id="15374" href="../Connectives/#15333" class="Bound">A</a> <a id="15376" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="15378" href="../Connectives/#15335" class="Bound">B</a>
    <a id="15384" class="Comment">-----------</a>
  <a id="15398" class="Symbol">→</a> <a id="15400" href="../Connectives/#15337" class="Bound">C</a>
<a id="15402" href="../Connectives/#15321" class="Function">case-⊎</a> <a id="15409" href="../Connectives/#15409" class="Bound">f</a> <a id="15411" href="../Connectives/#15411" class="Bound">g</a> <a id="15413" class="Symbol">(</a><a id="15414" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="15419" href="../Connectives/#15419" class="Bound">x</a><a id="15420" class="Symbol">)</a> <a id="15422" class="Symbol">=</a> <a id="15424" href="../Connectives/#15409" class="Bound">f</a> <a id="15426" href="../Connectives/#15419" class="Bound">x</a>
<a id="15428" href="../Connectives/#15321" class="Function">case-⊎</a> <a id="15435" href="../Connectives/#15435" class="Bound">f</a> <a id="15437" href="../Connectives/#15437" class="Bound">g</a> <a id="15439" class="Symbol">(</a><a id="15440" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="15445" href="../Connectives/#15445" class="Bound">y</a><a id="15446" class="Symbol">)</a> <a id="15448" class="Symbol">=</a> <a id="15450" href="../Connectives/#15437" class="Bound">g</a> <a id="15452" href="../Connectives/#15445" class="Bound">y</a>
</pre>
<!--
Pattern matching against `inj₁` and `inj₂` is typical of how we exploit
evidence that a disjunction holds.
-->
<p>对 <code>inj₁</code> 和 <code>inj₂</code> 进行模式匹配，是我们使用析取成立的证明的常见方法。</p>
<!--
When `inj₁` and `inj₂` appear on the right-hand side of an equation we
refer to them as _constructors_, and when they appear on the
left-hand side we refer to them as _destructors_.  We also refer to
`case-⊎` as a destructor, since it plays a similar role.  Other
terminology refers to `inj₁` and `inj₂` as _introducing_ a
disjunction, and to `case-⊎` as _eliminating_ a disjunction; indeed
the former are sometimes given the names `⊎-I₁` and `⊎-I₂` and the
latter the name `⊎-E`.
-->
<p>当 <code>inj₁</code> 和 <code>inj₂</code> 在等式右手边出现的时候，我们将其称作<strong>构造子</strong>， 当它出现在等式左边时，我们将其称作<strong>析构器</strong>。我们亦可将 <code>case-⊎</code> 称作析构器，因为它们起到相似的效果。其他术语将 <code>inj₁</code> 和 <code>inj₂</code> 称为<strong>引入</strong>析取， 将 <code>case-⊎</code> 称为<strong>消去</strong>析取。前者亦被称为 <code>⊎-I₁</code> 和 <code>⊎-I₂</code>，后者 <code>⊎-E</code>。</p>
<!--
Applying the destructor to each of the constructors is the identity:
-->
<p>对每个构造子使用析构器得到的是原来的值：</p>
<pre class="Agda"><a id="η-⊎"></a><a id="16410" href="../Connectives/#16410" class="Function">η-⊎</a> <a id="16414" class="Symbol">:</a> <a id="16416" class="Symbol">∀</a> <a id="16418" class="Symbol">{</a><a id="16419" href="../Connectives/#16419" class="Bound">A</a> <a id="16421" href="../Connectives/#16421" class="Bound">B</a> <a id="16423" class="Symbol">:</a> <a id="16425" class="PrimitiveType">Set</a><a id="16428" class="Symbol">}</a> <a id="16430" class="Symbol">(</a><a id="16431" href="../Connectives/#16431" class="Bound">w</a> <a id="16433" class="Symbol">:</a> <a id="16435" href="../Connectives/#16419" class="Bound">A</a> <a id="16437" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="16439" href="../Connectives/#16421" class="Bound">B</a><a id="16440" class="Symbol">)</a> <a id="16442" class="Symbol">→</a> <a id="16444" href="../Connectives/#15321" class="Function">case-⊎</a> <a id="16451" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="16456" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="16461" href="../Connectives/#16431" class="Bound">w</a> <a id="16463" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="16465" href="../Connectives/#16431" class="Bound">w</a>
<a id="16467" href="../Connectives/#16410" class="Function">η-⊎</a> <a id="16471" class="Symbol">(</a><a id="16472" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="16477" href="../Connectives/#16477" class="Bound">x</a><a id="16478" class="Symbol">)</a> <a id="16480" class="Symbol">=</a> <a id="16482" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="16487" href="../Connectives/#16410" class="Function">η-⊎</a> <a id="16491" class="Symbol">(</a><a id="16492" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="16497" href="../Connectives/#16497" class="Bound">y</a><a id="16498" class="Symbol">)</a> <a id="16500" class="Symbol">=</a> <a id="16502" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<!--
More generally, we can also throw in an arbitrary function from a disjunction:
-->
<p>更普遍地来说，我们亦可对于析取使用一个任意的函数：</p>
<pre class="Agda"><a id="uniq-⊎"></a><a id="16632" href="../Connectives/#16632" class="Function">uniq-⊎</a> <a id="16639" class="Symbol">:</a> <a id="16641" class="Symbol">∀</a> <a id="16643" class="Symbol">{</a><a id="16644" href="../Connectives/#16644" class="Bound">A</a> <a id="16646" href="../Connectives/#16646" class="Bound">B</a> <a id="16648" href="../Connectives/#16648" class="Bound">C</a> <a id="16650" class="Symbol">:</a> <a id="16652" class="PrimitiveType">Set</a><a id="16655" class="Symbol">}</a> <a id="16657" class="Symbol">(</a><a id="16658" href="../Connectives/#16658" class="Bound">h</a> <a id="16660" class="Symbol">:</a> <a id="16662" href="../Connectives/#16644" class="Bound">A</a> <a id="16664" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="16666" href="../Connectives/#16646" class="Bound">B</a> <a id="16668" class="Symbol">→</a> <a id="16670" href="../Connectives/#16648" class="Bound">C</a><a id="16671" class="Symbol">)</a> <a id="16673" class="Symbol">(</a><a id="16674" href="../Connectives/#16674" class="Bound">w</a> <a id="16676" class="Symbol">:</a> <a id="16678" href="../Connectives/#16644" class="Bound">A</a> <a id="16680" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="16682" href="../Connectives/#16646" class="Bound">B</a><a id="16683" class="Symbol">)</a> <a id="16685" class="Symbol">→</a>
  <a id="16689" href="../Connectives/#15321" class="Function">case-⊎</a> <a id="16696" class="Symbol">(</a><a id="16697" href="../Connectives/#16658" class="Bound">h</a> <a id="16699" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="16701" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a><a id="16705" class="Symbol">)</a> <a id="16707" class="Symbol">(</a><a id="16708" href="../Connectives/#16658" class="Bound">h</a> <a id="16710" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="16712" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a><a id="16716" class="Symbol">)</a> <a id="16718" href="../Connectives/#16674" class="Bound">w</a> <a id="16720" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="16722" href="../Connectives/#16658" class="Bound">h</a> <a id="16724" href="../Connectives/#16674" class="Bound">w</a>
<a id="16726" href="../Connectives/#16632" class="Function">uniq-⊎</a> <a id="16733" href="../Connectives/#16733" class="Bound">h</a> <a id="16735" class="Symbol">(</a><a id="16736" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="16741" href="../Connectives/#16741" class="Bound">x</a><a id="16742" class="Symbol">)</a> <a id="16744" class="Symbol">=</a> <a id="16746" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="16751" href="../Connectives/#16632" class="Function">uniq-⊎</a> <a id="16758" href="../Connectives/#16758" class="Bound">h</a> <a id="16760" class="Symbol">(</a><a id="16761" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="16766" href="../Connectives/#16766" class="Bound">y</a><a id="16767" class="Symbol">)</a> <a id="16769" class="Symbol">=</a> <a id="16771" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<!--
The pattern matching on the left-hand side is essential.  Replacing
`w` by `inj₁ x` allows both sides of the propositional equality to
simplify to the same term, and similarly for `inj₂ y`.
-->
<p>左手边的模式匹配是必要的。用 <code>inj₁ x</code> 来替换 <code>w</code> 让等式的两边可以化简成相同的项， <code>inj₂ y</code> 同理。</p>
<!--
We set the precedence of disjunction so that it binds less tightly
than any other declared operator:
-->
<p>我们设置析取的优先级，使它与任何已经定义的运算符都结合的不紧密：</p>
<pre class="Agda"><a id="17193" class="Keyword">infixr</a> <a id="17200" class="Number">1</a> <a id="17202" href="../Connectives/#14754" class="Datatype Operator">_⊎_</a>
</pre>
<!--
Thus, `A × C ⊎ B × C` parses as `(A × C) ⊎ (B × C)`.
-->
<p>因此 <code>A × C ⊎ B × C</code> 解析为 <code>(A × C) ⊎ (B × C)</code>。</p>
<!--
Given two types `A` and `B`, we refer to `A ⊎ B` as the
_sum_ of `A` and `B`.  In set theory, it is also sometimes
called the _disjoint union_, and in computing it corresponds
to a _variant record_ type. Among other reasons for
calling it the sum, note that if type `A` has `m`
distinct members, and type `B` has `n` distinct members,
then the type `A ⊎ B` has `m + n` distinct members.
For instance, consider a type `Bool` with two members, and
a type `Tri` with three members, as defined earlier.
Then the type `Bool ⊎ Tri` has five
members:
-->
<p>给定两个类型 <code>A</code> 和 <code>B</code>，我们将 <code>A ⊎ B</code> 称为 <code>A</code> 与 <code>B</code> 的<strong>和</strong>。 在集合论中它也被称作<strong>不交并（Disjoint Union）</strong>，在计算机科学中它对应<strong>变体记录</strong>类型。 如果类型 <code>A</code> 有 <code>m</code> 个不同的成员，类型 <code>B</code> 有 <code>n</code> 个不同的成员， 那么类型 <code>A ⊎ B</code> 有 <code>m + n</code> 个不同的成员。这也是它被称为和的原因之一。 例如，考虑有两个成员的 <code>Bool</code> 类型，和有三个成员的 <code>Tri</code> 类型，如之前的定义。 那么，<code>Bool ⊎ Tri</code> 类型有如下的五个成员：</p>
<pre><code>inj₁ true     inj₂ aa
inj₁ false    inj₂ bb
              inj₂ cc</code></pre>
<!--
For example, the following function enumerates all
possible arguments of type `Bool ⊎ Tri`:
-->
<p>下面的函数枚举了所有类型为 <code>Bool ⊎ Tri</code> 的参数：</p>
<pre class="Agda"><a id="⊎-count"></a><a id="18361" href="../Connectives/#18361" class="Function">⊎-count</a> <a id="18369" class="Symbol">:</a> <a id="18371" href="../Connectives/#6582" class="Datatype">Bool</a> <a id="18376" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="18378" href="../Connectives/#6635" class="Datatype">Tri</a> <a id="18382" class="Symbol">→</a> <a id="18384" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="18386" href="../Connectives/#18361" class="Function">⊎-count</a> <a id="18394" class="Symbol">(</a><a id="18395" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="18400" href="../Connectives/#6601" class="InductiveConstructor">true</a><a id="18404" class="Symbol">)</a>   <a id="18408" class="Symbol">=</a>  <a id="18411" class="Number">1</a>
<a id="18413" href="../Connectives/#18361" class="Function">⊎-count</a> <a id="18421" class="Symbol">(</a><a id="18422" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="18427" href="../Connectives/#6616" class="InductiveConstructor">false</a><a id="18432" class="Symbol">)</a>  <a id="18435" class="Symbol">=</a>  <a id="18438" class="Number">2</a>
<a id="18440" href="../Connectives/#18361" class="Function">⊎-count</a> <a id="18448" class="Symbol">(</a><a id="18449" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="18454" href="../Connectives/#6653" class="InductiveConstructor">aa</a><a id="18456" class="Symbol">)</a>     <a id="18462" class="Symbol">=</a>  <a id="18465" class="Number">3</a>
<a id="18467" href="../Connectives/#18361" class="Function">⊎-count</a> <a id="18475" class="Symbol">(</a><a id="18476" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="18481" href="../Connectives/#6664" class="InductiveConstructor">bb</a><a id="18483" class="Symbol">)</a>     <a id="18489" class="Symbol">=</a>  <a id="18492" class="Number">4</a>
<a id="18494" href="../Connectives/#18361" class="Function">⊎-count</a> <a id="18502" class="Symbol">(</a><a id="18503" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="18508" href="../Connectives/#6675" class="InductiveConstructor">cc</a><a id="18510" class="Symbol">)</a>     <a id="18516" class="Symbol">=</a>  <a id="18519" class="Number">5</a>
</pre>
<!--
Sum on types also shares a property with sum on numbers in that it is
commutative and associative _up to isomorphism_.
-->
<p>类型上的和与数的和有相似的性质——它们满足交换律和结合律。 更确切地说，和在<strong>在同构意义下</strong>是交换和结合的。</p>
<!--
#### Exercise `⊎-comm` (recommended)
-->
<h4 id="练习--comm-推荐">练习 <code>⊎-comm</code> （推荐）</h4>
<!--
Show sum is commutative up to isomorphism.
-->
<p>证明和类型在同构意义下满足交换律。</p>
<!--
<pre class="Agda"><a id="18864" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="18900" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
#### Exercise `⊎-assoc` (practice)
-->
<h4 id="练习--assoc实践">练习 <code>⊎-assoc</code>（实践）</h4>
<!--
Show sum is associative up to isomorphism.
-->
<p>证明和类型在同构意义下满足结合律。</p>
<!--
<pre class="Agda"><a id="19067" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="19103" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
## False is empty
-->
<h2 id="假即是空类型">假即是空类型</h2>
<!--
False `⊥` never holds.  We formalise this idea by declaring
a suitable inductive type:
-->
<p>恒假 <code>⊥</code> 从不成立。我们将这个概念用合适的归纳类型来形式化：</p>
<!--
FIXME: the code block is removed to make Agda not recognise this as code.
data ⊥ : Set where
  -- no clauses!
-->
<pre class="Agda"><a id="19415" class="Keyword">data</a> <a id="⊥"></a><a id="19420" href="../Connectives/#19420" class="Datatype">⊥</a> <a id="19422" class="Symbol">:</a> <a id="19424" class="PrimitiveType">Set</a> <a id="19428" class="Keyword">where</a>
  <a id="19436" class="Comment">-- 没有语句！</a>
</pre>
<!--
There is no possible evidence that `⊥` holds.
-->
<p>没有 <code>⊥</code> 成立的证明。</p>
<!--
Dual to `⊤`, for `⊥` there is no introduction rule but an elimination rule.
Since false never holds, knowing that it holds tells us we are in a
paradoxical situation.  Given evidence that `⊥` holds, we might
conclude anything!  This is a basic principle of logic, known in
medieval times by the Latin phrase _ex falso_, and known to children
through phrases such as "if pigs had wings, then I'd be the Queen of
Sheba".  We formalise it as follows:
-->
<p>与 <code>⊤</code> 相对偶，<code>⊥</code> 没有引入规则，但是有消去规则。因为恒假从不成立， 如果它一旦成立，我们就进入了矛盾之中。给定 <code>⊥</code> 成立的证明，我们可以得出任何结论！ 这是逻辑学的基本原理，又由中世纪的拉丁文词组 <em>ex falso</em> 为名。小孩子也由诸如 「如果猪有翅膀，那我就是示巴女王」的词组中知晓。我们如下将它形式化：</p>
<pre class="Agda"><a id="⊥-elim"></a><a id="20147" href="../Connectives/#20147" class="Function">⊥-elim</a> <a id="20154" class="Symbol">:</a> <a id="20156" class="Symbol">∀</a> <a id="20158" class="Symbol">{</a><a id="20159" href="../Connectives/#20159" class="Bound">A</a> <a id="20161" class="Symbol">:</a> <a id="20163" class="PrimitiveType">Set</a><a id="20166" class="Symbol">}</a>
  <a id="20170" class="Symbol">→</a> <a id="20172" href="../Connectives/#19420" class="Datatype">⊥</a>
    <a id="20178" class="Comment">--</a>
  <a id="20183" class="Symbol">→</a> <a id="20185" href="../Connectives/#20159" class="Bound">A</a>
<a id="20187" href="../Connectives/#20147" class="Function">⊥-elim</a> <a id="20194" class="Symbol">()</a>
</pre>
<!--
This is our first use of the _absurd pattern_ `()`.
Here since `⊥` is a type with no members, we indicate that it is
_never_ possible to match against a value of this type by using
the pattern `()`.
-->
<p>这是我们第一次使<strong>用荒谬模式（Absurd Pattern）</strong> <code>()</code>。在这里，因为 <code>⊥</code> 是一个没有成员的类型，我们用 <code>()</code> 模式来指明这里不可能匹配任何这个类型的值。</p>
<!--
The nullary case of `case-⊎` is `⊥-elim`.  By analogy,
we might have called it `case-⊥`, but chose to stick with the name
in the standard library.
-->
<p><code>case-⊎</code> 的零元形式是 <code>⊥-elim</code>。类比的来说，它应该叫做 <code>case-⊥</code>， 但是我们在此使用标准库中使用的名字。</p>
<!--
The nullary case of `uniq-⊎` is `uniq-⊥`, which asserts that `⊥-elim`
is equal to any arbitrary function from `⊥`:
-->
<p><code>uniq-⊎</code> 的零元形式是 <code>uniq-⊥</code>，其断言了 <code>⊥-elim</code> 和任何取 <code>⊥</code> 的函数是等价的。</p>
<pre class="Agda"><a id="uniq-⊥"></a><a id="20915" href="../Connectives/#20915" class="Function">uniq-⊥</a> <a id="20922" class="Symbol">:</a> <a id="20924" class="Symbol">∀</a> <a id="20926" class="Symbol">{</a><a id="20927" href="../Connectives/#20927" class="Bound">C</a> <a id="20929" class="Symbol">:</a> <a id="20931" class="PrimitiveType">Set</a><a id="20934" class="Symbol">}</a> <a id="20936" class="Symbol">(</a><a id="20937" href="../Connectives/#20937" class="Bound">h</a> <a id="20939" class="Symbol">:</a> <a id="20941" href="../Connectives/#19420" class="Datatype">⊥</a> <a id="20943" class="Symbol">→</a> <a id="20945" href="../Connectives/#20927" class="Bound">C</a><a id="20946" class="Symbol">)</a> <a id="20948" class="Symbol">(</a><a id="20949" href="../Connectives/#20949" class="Bound">w</a> <a id="20951" class="Symbol">:</a> <a id="20953" href="../Connectives/#19420" class="Datatype">⊥</a><a id="20954" class="Symbol">)</a> <a id="20956" class="Symbol">→</a> <a id="20958" href="../Connectives/#20147" class="Function">⊥-elim</a> <a id="20965" href="../Connectives/#20949" class="Bound">w</a> <a id="20967" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="20969" href="../Connectives/#20937" class="Bound">h</a> <a id="20971" href="../Connectives/#20949" class="Bound">w</a>
<a id="20973" href="../Connectives/#20915" class="Function">uniq-⊥</a> <a id="20980" href="../Connectives/#20980" class="Bound">h</a> <a id="20982" class="Symbol">()</a>
</pre>
<!--
Using the absurd pattern asserts there are no possible values for `w`,
so the equation holds trivially.
-->
<p>使用荒谬模式断言了 <code>w</code> 没有任何可能的值，因此等式显然成立。</p>
<!--
We refer to `⊥` as the _empty_ type. And, indeed,
type `⊥` has no members. For example, the following function
enumerates all possible arguments of type `⊥`:
-->
<p>我们将 <code>⊥</code> 成为<strong>空（Empty）</strong>类型。实际上，<code>⊥</code> 类型没有成员。 例如，下面的函数枚举了所有 <code>⊥</code> 类型的参数：</p>
<pre class="Agda"><a id="⊥-count"></a><a id="21377" href="../Connectives/#21377" class="Function">⊥-count</a> <a id="21385" class="Symbol">:</a> <a id="21387" href="../Connectives/#19420" class="Datatype">⊥</a> <a id="21389" class="Symbol">→</a> <a id="21391" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="21393" href="../Connectives/#21377" class="Function">⊥-count</a> <a id="21401" class="Symbol">()</a>
</pre>
<!--
Here again the absurd pattern `()` indicates that no value can match
type `⊥`.
-->
<p>同样，荒谬模式告诉我们没有值可以来匹配类型 <code>⊥</code>。</p>
<!--
For numbers, zero is the identity of addition. Correspondingly, empty
is the identity of sums _up to isomorphism_.
-->
<p>对于数来说，0 是加法的幺元。对应地，空是和的幺元（<strong>在同构意义下</strong>）。</p>
<!--
#### Exercise `⊥-identityˡ` (recommended)
-->
<h4 id="练习--identityˡ-推荐">练习 <code>⊥-identityˡ</code> （推荐）</h4>
<!--
Show empty is the left identity of sums up to isomorphism.
-->
<p>证明空在同构意义下是和的左幺元。</p>
<!--
<pre class="Agda"><a id="21867" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="21903" class="Comment">-- 请将代码写在此处。</a>
</pre>
<h4 id="exercise--identityʳ-practice">Exercise <code>⊥-identityʳ</code> (practice)</h4>
<h4 id="练习--identityʳ实践">练习 <code>⊥-identityʳ</code>（实践）</h4>
<!--
Show empty is the right identity of sums up to isomorphism.
-->
<p>证明空在同构意义下是和的右幺元。</p>
<!--
<pre class="Agda"><a id="22085" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="22121" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
## Implication is function {name=implication}
-->
<h2 name="implication" id="蕴涵即是函数">蕴涵即是函数</h2>
<!--
Given two propositions `A` and `B`, the implication `A → B` holds if
whenever `A` holds then `B` must also hold.  We formalise implication using
the function type, which has appeared throughout this book.
-->
<p>给定两个命题 <code>A</code> 和 <code>B</code>，其蕴涵 <code>A → B</code> 在任何 <code>A</code> 成立的时候，<code>B</code> 也成立时成立。 我们用函数类型来形式化蕴涵，如本书中通篇出现的那样。</p>
<!--
Evidence that `A → B` holds is of the form
-->
<p><code>A → B</code> 成立的证据由下面的形式组成：</p>
<pre><code>λ (x : A) → N</code></pre>
<!--
where `N` is a term of type `B` containing as a free variable `x` of type `A`.
Given a term `L` providing evidence that `A → B` holds, and a term `M`
providing evidence that `A` holds, the term `L M` provides evidence that
`B` holds.  In other words, evidence that `A → B` holds is a function that
converts evidence that `A` holds into evidence that `B` holds.
-->
<p>其中 <code>N</code> 是一个类型为 <code>B</code> 的项，其包括了一个类型为 <code>A</code> 的自由变量 <code>x</code>。 给定一个 <code>A → B</code> 成立的证明 <code>L</code>，和一个 <code>A</code> 成立的证明 <code>M</code>，那么 <code>L M</code> 是 <code>B</code> 成立的证明。 也就是说，<code>A → B</code> 成立的证明是一个函数，将 <code>A</code> 成立的证明转换成 <code>B</code> 成立的证明。</p>
<!--
Put another way, if we know that `A → B` and `A` both hold,
then we may conclude that `B` holds:
-->
<p>换句话说，如果知道 <code>A → B</code> 和 <code>A</code> 同时成立，那么我们可以推出 <code>B</code> 成立：</p>
<pre class="Agda"><a id="→-elim"></a><a id="23309" href="../Connectives/#23309" class="Function">→-elim</a> <a id="23316" class="Symbol">:</a> <a id="23318" class="Symbol">∀</a> <a id="23320" class="Symbol">{</a><a id="23321" href="../Connectives/#23321" class="Bound">A</a> <a id="23323" href="../Connectives/#23323" class="Bound">B</a> <a id="23325" class="Symbol">:</a> <a id="23327" class="PrimitiveType">Set</a><a id="23330" class="Symbol">}</a>
  <a id="23334" class="Symbol">→</a> <a id="23336" class="Symbol">(</a><a id="23337" href="../Connectives/#23321" class="Bound">A</a> <a id="23339" class="Symbol">→</a> <a id="23341" href="../Connectives/#23323" class="Bound">B</a><a id="23342" class="Symbol">)</a>
  <a id="23346" class="Symbol">→</a> <a id="23348" href="../Connectives/#23321" class="Bound">A</a>
    <a id="23354" class="Comment">-------</a>
  <a id="23364" class="Symbol">→</a> <a id="23366" href="../Connectives/#23323" class="Bound">B</a>
<a id="23368" href="../Connectives/#23309" class="Function">→-elim</a> <a id="23375" href="../Connectives/#23375" class="Bound">L</a> <a id="23377" href="../Connectives/#23377" class="Bound">M</a> <a id="23379" class="Symbol">=</a> <a id="23381" href="../Connectives/#23375" class="Bound">L</a> <a id="23383" href="../Connectives/#23377" class="Bound">M</a>
</pre>
<!--
In medieval times, this rule was known by the name _modus ponens_.
It corresponds to function application.
-->
<p>在中世纪，这条规则被叫做 <em>modus ponens</em>，它与函数应用相对应。</p>
<!--
Defining a function, with a named definition or a lambda abstraction,
is referred to as _introducing_ a function,
while applying a function is referred to as _eliminating_ the function.
-->
<p>定义一个函数，不管是带名字的定义或是使用 Lambda 抽象，被称为<strong>引入</strong>一个函数， 使用一个函数被称为<strong>消去</strong>一个函数。</p>
<!--
Elimination followed by introduction is the identity:
-->
<p>引入后接着消去，得到的还是原来的值：</p>
<pre class="Agda"><a id="η-→"></a><a id="23899" href="../Connectives/#23899" class="Function">η-→</a> <a id="23903" class="Symbol">:</a> <a id="23905" class="Symbol">∀</a> <a id="23907" class="Symbol">{</a><a id="23908" href="../Connectives/#23908" class="Bound">A</a> <a id="23910" href="../Connectives/#23910" class="Bound">B</a> <a id="23912" class="Symbol">:</a> <a id="23914" class="PrimitiveType">Set</a><a id="23917" class="Symbol">}</a> <a id="23919" class="Symbol">(</a><a id="23920" href="../Connectives/#23920" class="Bound">f</a> <a id="23922" class="Symbol">:</a> <a id="23924" href="../Connectives/#23908" class="Bound">A</a> <a id="23926" class="Symbol">→</a> <a id="23928" href="../Connectives/#23910" class="Bound">B</a><a id="23929" class="Symbol">)</a> <a id="23931" class="Symbol">→</a> <a id="23933" class="Symbol">(λ</a> <a id="23936" class="Symbol">(</a><a id="23937" href="../Connectives/#23937" class="Bound">x</a> <a id="23939" class="Symbol">:</a> <a id="23941" href="../Connectives/#23908" class="Bound">A</a><a id="23942" class="Symbol">)</a> <a id="23944" class="Symbol">→</a> <a id="23946" href="../Connectives/#23920" class="Bound">f</a> <a id="23948" href="../Connectives/#23937" class="Bound">x</a><a id="23949" class="Symbol">)</a> <a id="23951" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="23953" href="../Connectives/#23920" class="Bound">f</a>
<a id="23955" href="../Connectives/#23899" class="Function">η-→</a> <a id="23959" href="../Connectives/#23959" class="Bound">f</a> <a id="23961" class="Symbol">=</a> <a id="23963" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<!--
Implication binds less tightly than any other operator. Thus, `A ⊎ B →
B ⊎ A` parses as `(A ⊎ B) → (B ⊎ A)`.
-->
<p>蕴涵比其他的运算符结合得都不紧密。因此 <code>A ⊎ B → B ⊎ A</code> 被解析为 <code>(A ⊎ B) → (B ⊎ A)</code>。</p>
<!--
Given two types `A` and `B`, we refer to `A → B` as the _function_
space from `A` to `B`.  It is also sometimes called the _exponential_,
with `B` raised to the `A` power.  Among other reasons for calling
it the exponential, note that if type `A` has `m` distinct
members, and type `B` has `n` distinct members, then the type
`A → B` has `nᵐ` distinct members.  For instance, consider a
type `Bool` with two members and a type `Tri` with three members,
as defined earlier. Then the type `Bool → Tri` has nine (that is,
three squared) members:
-->
<p>给定两个类型 <code>A</code> 和 <code>B</code>，我们将 <code>A → B</code> 称为从 <code>A</code> 到 <code>B</code> 的<strong>函数</strong>空间。 它有时也被称作以 <code>B</code> 为底，<code>A</code> 为次数的<strong>幂</strong>。如果类型 <code>A</code> 有 <code>m</code> 个不同的成员， 类型 <code>B</code> 有 <code>n</code> 个不同的成员，那么类型 <code>A → B</code> 有 <code>nᵐ</code> 个不同的成员。 这也是它被称为幂的原因之一。例如，考虑有两个成员的 <code>Bool</code> 类型，和有三个成员的 <code>Tri</code> 类型， 如之前的定义。那么，<code>Bool → Tri</code> 类型有如下的九个成员（三的平方）：</p>
<pre><code>λ{true → aa; false → aa}  λ{true → aa; false → bb}  λ{true → aa; false → cc}
λ{true → bb; false → aa}  λ{true → bb; false → bb}  λ{true → bb; false → cc}
λ{true → cc; false → aa}  λ{true → cc; false → bb}  λ{true → cc; false → cc}</code></pre>
<!--
For example, the following function enumerates all possible
arguments of the type `Bool → Tri`:
-->
<p>下面的函数枚举了所有类型为 <code>Bool → Tri</code> 的参数：</p>
<pre class="Agda"><a id="→-count"></a><a id="25346" href="../Connectives/#25346" class="Function">→-count</a> <a id="25354" class="Symbol">:</a> <a id="25356" class="Symbol">(</a><a id="25357" href="../Connectives/#6582" class="Datatype">Bool</a> <a id="25362" class="Symbol">→</a> <a id="25364" href="../Connectives/#6635" class="Datatype">Tri</a><a id="25367" class="Symbol">)</a> <a id="25369" class="Symbol">→</a> <a id="25371" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="25373" href="../Connectives/#25346" class="Function">→-count</a> <a id="25381" href="../Connectives/#25381" class="Bound">f</a> <a id="25383" class="Keyword">with</a> <a id="25388" href="../Connectives/#25381" class="Bound">f</a> <a id="25390" href="../Connectives/#6601" class="InductiveConstructor">true</a> <a id="25395" class="Symbol">|</a> <a id="25397" href="../Connectives/#25381" class="Bound">f</a> <a id="25399" href="../Connectives/#6616" class="InductiveConstructor">false</a>
<a id="25405" class="Symbol">...</a>          <a id="25418" class="Symbol">|</a> <a id="25420" href="../Connectives/#6653" class="InductiveConstructor">aa</a>     <a id="25427" class="Symbol">|</a> <a id="25429" href="../Connectives/#6653" class="InductiveConstructor">aa</a>      <a id="25437" class="Symbol">=</a>   <a id="25441" class="Number">1</a>
<a id="25443" class="Symbol">...</a>          <a id="25456" class="Symbol">|</a> <a id="25458" href="../Connectives/#6653" class="InductiveConstructor">aa</a>     <a id="25465" class="Symbol">|</a> <a id="25467" href="../Connectives/#6664" class="InductiveConstructor">bb</a>      <a id="25475" class="Symbol">=</a>   <a id="25479" class="Number">2</a>
<a id="25481" class="Symbol">...</a>          <a id="25494" class="Symbol">|</a> <a id="25496" href="../Connectives/#6653" class="InductiveConstructor">aa</a>     <a id="25503" class="Symbol">|</a> <a id="25505" href="../Connectives/#6675" class="InductiveConstructor">cc</a>      <a id="25513" class="Symbol">=</a>   <a id="25517" class="Number">3</a>
<a id="25519" class="Symbol">...</a>          <a id="25532" class="Symbol">|</a> <a id="25534" href="../Connectives/#6664" class="InductiveConstructor">bb</a>     <a id="25541" class="Symbol">|</a> <a id="25543" href="../Connectives/#6653" class="InductiveConstructor">aa</a>      <a id="25551" class="Symbol">=</a>   <a id="25555" class="Number">4</a>
<a id="25557" class="Symbol">...</a>          <a id="25570" class="Symbol">|</a> <a id="25572" href="../Connectives/#6664" class="InductiveConstructor">bb</a>     <a id="25579" class="Symbol">|</a> <a id="25581" href="../Connectives/#6664" class="InductiveConstructor">bb</a>      <a id="25589" class="Symbol">=</a>   <a id="25593" class="Number">5</a>
<a id="25595" class="Symbol">...</a>          <a id="25608" class="Symbol">|</a> <a id="25610" href="../Connectives/#6664" class="InductiveConstructor">bb</a>     <a id="25617" class="Symbol">|</a> <a id="25619" href="../Connectives/#6675" class="InductiveConstructor">cc</a>      <a id="25627" class="Symbol">=</a>   <a id="25631" class="Number">6</a>
<a id="25633" class="Symbol">...</a>          <a id="25646" class="Symbol">|</a> <a id="25648" href="../Connectives/#6675" class="InductiveConstructor">cc</a>     <a id="25655" class="Symbol">|</a> <a id="25657" href="../Connectives/#6653" class="InductiveConstructor">aa</a>      <a id="25665" class="Symbol">=</a>   <a id="25669" class="Number">7</a>
<a id="25671" class="Symbol">...</a>          <a id="25684" class="Symbol">|</a> <a id="25686" href="../Connectives/#6675" class="InductiveConstructor">cc</a>     <a id="25693" class="Symbol">|</a> <a id="25695" href="../Connectives/#6664" class="InductiveConstructor">bb</a>      <a id="25703" class="Symbol">=</a>   <a id="25707" class="Number">8</a>
<a id="25709" class="Symbol">...</a>          <a id="25722" class="Symbol">|</a> <a id="25724" href="../Connectives/#6675" class="InductiveConstructor">cc</a>     <a id="25731" class="Symbol">|</a> <a id="25733" href="../Connectives/#6675" class="InductiveConstructor">cc</a>      <a id="25741" class="Symbol">=</a>   <a id="25745" class="Number">9</a>
</pre>
<!--
Exponential on types also share a property with exponential on
numbers in that many of the standard identities for numbers carry
over to the types.
-->
<p>类型上的幂与数的幂有相似的性质，很多数上成立的关系式也可以在类型上成立。</p>
<!--
Corresponding to the law
-->
<p>对应如下的定律：</p>
<pre><code>(p ^ n) ^ m  ≡  p ^ (n * m)</code></pre>
<!--
we have the isomorphism
-->
<p>我们有如下的同构：</p>
<pre><code>A → (B → C)  ≃  (A × B) → C</code></pre>
<!--
Both types can be viewed as functions that given evidence that `A` holds
and evidence that `B` holds can return evidence that `C` holds.
This isomorphism sometimes goes by the name *currying*.
The proof of the right inverse requires extensionality:
-->
<p>两个类型可以被看作给定 <code>A</code> 成立的证据和 <code>B</code> 成立的证据，返回 <code>C</code> 成立的证据。 这个同构有时也被称作<strong>柯里化（Currying）</strong>。右逆的证明需要外延性：</p>
<pre class="Agda"><a id="currying"></a><a id="26455" href="../Connectives/#26455" class="Function">currying</a> <a id="26464" class="Symbol">:</a> <a id="26466" class="Symbol">∀</a> <a id="26468" class="Symbol">{</a><a id="26469" href="../Connectives/#26469" class="Bound">A</a> <a id="26471" href="../Connectives/#26471" class="Bound">B</a> <a id="26473" href="../Connectives/#26473" class="Bound">C</a> <a id="26475" class="Symbol">:</a> <a id="26477" class="PrimitiveType">Set</a><a id="26480" class="Symbol">}</a> <a id="26482" class="Symbol">→</a> <a id="26484" class="Symbol">(</a><a id="26485" href="../Connectives/#26469" class="Bound">A</a> <a id="26487" class="Symbol">→</a> <a id="26489" href="../Connectives/#26471" class="Bound">B</a> <a id="26491" class="Symbol">→</a> <a id="26493" href="../Connectives/#26473" class="Bound">C</a><a id="26494" class="Symbol">)</a> <a id="26496" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="26498" class="Symbol">(</a><a id="26499" href="../Connectives/#26469" class="Bound">A</a> <a id="26501" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="26503" href="../Connectives/#26471" class="Bound">B</a> <a id="26505" class="Symbol">→</a> <a id="26507" href="../Connectives/#26473" class="Bound">C</a><a id="26508" class="Symbol">)</a>
<a id="26510" href="../Connectives/#26455" class="Function">currying</a> <a id="26519" class="Symbol">=</a>
  <a id="26523" class="Keyword">record</a>
    <a id="26534" class="Symbol">{</a> <a id="26536" href="../Isomorphism/#5650" class="Field">to</a>      <a id="26544" class="Symbol">=</a>  <a id="26547" class="Symbol">λ{</a> <a id="26550" href="../Connectives/#26550" class="Bound">f</a> <a id="26552" class="Symbol">→</a> <a id="26554" class="Symbol">λ{</a> <a id="26557" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="26559" href="../Connectives/#26559" class="Bound">x</a> <a id="26561" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="26563" href="../Connectives/#26563" class="Bound">y</a> <a id="26565" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="26567" class="Symbol">→</a> <a id="26569" href="../Connectives/#26550" class="Bound">f</a> <a id="26571" href="../Connectives/#26559" class="Bound">x</a> <a id="26573" href="../Connectives/#26563" class="Bound">y</a> <a id="26575" class="Symbol">}}</a>
    <a id="26582" class="Symbol">;</a> <a id="26584" href="../Isomorphism/#5667" class="Field">from</a>    <a id="26592" class="Symbol">=</a>  <a id="26595" class="Symbol">λ{</a> <a id="26598" href="../Connectives/#26598" class="Bound">g</a> <a id="26600" class="Symbol">→</a> <a id="26602" class="Symbol">λ{</a> <a id="26605" href="../Connectives/#26605" class="Bound">x</a> <a id="26607" class="Symbol">→</a> <a id="26609" class="Symbol">λ{</a> <a id="26612" href="../Connectives/#26612" class="Bound">y</a> <a id="26614" class="Symbol">→</a> <a id="26616" href="../Connectives/#26598" class="Bound">g</a> <a id="26618" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="26620" href="../Connectives/#26605" class="Bound">x</a> <a id="26622" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="26624" href="../Connectives/#26612" class="Bound">y</a> <a id="26626" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="26628" class="Symbol">}}}</a>
    <a id="26636" class="Symbol">;</a> <a id="26638" href="../Isomorphism/#5684" class="Field">from∘to</a> <a id="26646" class="Symbol">=</a>  <a id="26649" class="Symbol">λ{</a> <a id="26652" href="../Connectives/#26652" class="Bound">f</a> <a id="26654" class="Symbol">→</a> <a id="26656" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="26661" class="Symbol">}</a>
    <a id="26667" class="Symbol">;</a> <a id="26669" href="../Isomorphism/#5726" class="Field">to∘from</a> <a id="26677" class="Symbol">=</a>  <a id="26680" class="Symbol">λ{</a> <a id="26683" href="../Connectives/#26683" class="Bound">g</a> <a id="26685" class="Symbol">→</a> <a id="26687" href="../Isomorphism/#3602" class="Postulate">extensionality</a> <a id="26702" class="Symbol">λ{</a> <a id="26705" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="26707" href="../Connectives/#26707" class="Bound">x</a> <a id="26709" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="26711" href="../Connectives/#26711" class="Bound">y</a> <a id="26713" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="26715" class="Symbol">→</a> <a id="26717" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="26722" class="Symbol">}}</a>
    <a id="26729" class="Symbol">}</a>
</pre>
<!--
Currying tells us that instead of a function that takes a pair of arguments,
we can have a function that takes the first argument and returns a function that
expects the second argument.  Thus, for instance, our way of writing addition
-->
<p>柯里化告诉我们，如果一个函数有取一个数据对作为参数， 那么我们可以构造一个函数，取第一个参数，返回一个取第二个参数，返回最终结果的函数。 因此，举例来说，下面表示加法的形式：</p>
<pre><code>_+_ : ℕ → ℕ → ℕ</code></pre>
<!--
is isomorphic to a function that accepts a pair of arguments:
-->
<p>和下面的一个带有一个数据对作为参数的函数是同构的：</p>
<pre><code>_+′_ : (ℕ × ℕ) → ℕ</code></pre>
<!--
Agda is optimised for currying, so `2 + 3` abbreviates `_+_ 2 3`.
In a language optimised for pairing, we would instead take `2 +′ 3` as
an abbreviation for `_+′_ ⟨ 2 , 3 ⟩`.
-->
<p>Agda 对柯里化进行了优化，因此 <code>2 + 3</code> 是 <code>_+_ 2 3</code> 的简写。在一个对有序对进行优化的语言里， <code>2 +′ 3</code> 可能是 <code>_+′_ ⟨ 2 , 3 ⟩</code> 的简写。</p>
<!--
Corresponding to the law
-->
<p>对应如下的定律：</p>
<pre><code>p ^ (n + m) = (p ^ n) * (p ^ m)</code></pre>
<!--
we have the isomorphism:
-->
<p>我们有如下的同构：</p>
<pre><code>(A ⊎ B) → C  ≃  (A → C) × (B → C)</code></pre>
<!--
That is, the assertion that if either `A` holds or `B` holds then `C` holds
is the same as the assertion that if `A` holds then `C` holds and if
`B` holds then `C` holds.  The proof of the left inverse requires extensionality:
-->
<p>命题如果 <code>A</code> 成立或者 <code>B</code> 成立，那么 <code>C</code> 成立，和命题如果 <code>A</code> 成立，那么 <code>C</code> 成立以及 如果 <code>B</code> 成立，那么 <code>C</code> 成立，是一样的。左逆的证明需要外延性：</p>
<pre class="Agda"><a id="→-distrib-⊎"></a><a id="27997" href="../Connectives/#27997" class="Function">→-distrib-⊎</a> <a id="28009" class="Symbol">:</a> <a id="28011" class="Symbol">∀</a> <a id="28013" class="Symbol">{</a><a id="28014" href="../Connectives/#28014" class="Bound">A</a> <a id="28016" href="../Connectives/#28016" class="Bound">B</a> <a id="28018" href="../Connectives/#28018" class="Bound">C</a> <a id="28020" class="Symbol">:</a> <a id="28022" class="PrimitiveType">Set</a><a id="28025" class="Symbol">}</a> <a id="28027" class="Symbol">→</a> <a id="28029" class="Symbol">(</a><a id="28030" href="../Connectives/#28014" class="Bound">A</a> <a id="28032" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="28034" href="../Connectives/#28016" class="Bound">B</a> <a id="28036" class="Symbol">→</a> <a id="28038" href="../Connectives/#28018" class="Bound">C</a><a id="28039" class="Symbol">)</a> <a id="28041" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="28043" class="Symbol">((</a><a id="28045" href="../Connectives/#28014" class="Bound">A</a> <a id="28047" class="Symbol">→</a> <a id="28049" href="../Connectives/#28018" class="Bound">C</a><a id="28050" class="Symbol">)</a> <a id="28052" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="28054" class="Symbol">(</a><a id="28055" href="../Connectives/#28016" class="Bound">B</a> <a id="28057" class="Symbol">→</a> <a id="28059" href="../Connectives/#28018" class="Bound">C</a><a id="28060" class="Symbol">))</a>
<a id="28063" href="../Connectives/#27997" class="Function">→-distrib-⊎</a> <a id="28075" class="Symbol">=</a>
  <a id="28079" class="Keyword">record</a>
    <a id="28090" class="Symbol">{</a> <a id="28092" href="../Isomorphism/#5650" class="Field">to</a>      <a id="28100" class="Symbol">=</a> <a id="28102" class="Symbol">λ{</a> <a id="28105" href="../Connectives/#28105" class="Bound">f</a> <a id="28107" class="Symbol">→</a> <a id="28109" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="28111" href="../Connectives/#28105" class="Bound">f</a> <a id="28113" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="28115" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="28120" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="28122" href="../Connectives/#28105" class="Bound">f</a> <a id="28124" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="28126" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="28131" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="28133" class="Symbol">}</a>
    <a id="28139" class="Symbol">;</a> <a id="28141" href="../Isomorphism/#5667" class="Field">from</a>    <a id="28149" class="Symbol">=</a> <a id="28151" class="Symbol">λ{</a> <a id="28154" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="28156" href="../Connectives/#28156" class="Bound">g</a> <a id="28158" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="28160" href="../Connectives/#28160" class="Bound">h</a> <a id="28162" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="28164" class="Symbol">→</a> <a id="28166" class="Symbol">λ{</a> <a id="28169" class="Symbol">(</a><a id="28170" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="28175" href="../Connectives/#28175" class="Bound">x</a><a id="28176" class="Symbol">)</a> <a id="28178" class="Symbol">→</a> <a id="28180" href="../Connectives/#28156" class="Bound">g</a> <a id="28182" href="../Connectives/#28175" class="Bound">x</a> <a id="28184" class="Symbol">;</a> <a id="28186" class="Symbol">(</a><a id="28187" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="28192" href="../Connectives/#28192" class="Bound">y</a><a id="28193" class="Symbol">)</a> <a id="28195" class="Symbol">→</a> <a id="28197" href="../Connectives/#28160" class="Bound">h</a> <a id="28199" href="../Connectives/#28192" class="Bound">y</a> <a id="28201" class="Symbol">}</a> <a id="28203" class="Symbol">}</a>
    <a id="28209" class="Symbol">;</a> <a id="28211" href="../Isomorphism/#5684" class="Field">from∘to</a> <a id="28219" class="Symbol">=</a> <a id="28221" class="Symbol">λ{</a> <a id="28224" href="../Connectives/#28224" class="Bound">f</a> <a id="28226" class="Symbol">→</a> <a id="28228" href="../Isomorphism/#3602" class="Postulate">extensionality</a> <a id="28243" class="Symbol">λ{</a> <a id="28246" class="Symbol">(</a><a id="28247" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="28252" href="../Connectives/#28252" class="Bound">x</a><a id="28253" class="Symbol">)</a> <a id="28255" class="Symbol">→</a> <a id="28257" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="28262" class="Symbol">;</a> <a id="28264" class="Symbol">(</a><a id="28265" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="28270" href="../Connectives/#28270" class="Bound">y</a><a id="28271" class="Symbol">)</a> <a id="28273" class="Symbol">→</a> <a id="28275" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="28280" class="Symbol">}</a> <a id="28282" class="Symbol">}</a>
    <a id="28288" class="Symbol">;</a> <a id="28290" href="../Isomorphism/#5726" class="Field">to∘from</a> <a id="28298" class="Symbol">=</a> <a id="28300" class="Symbol">λ{</a> <a id="28303" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="28305" href="../Connectives/#28305" class="Bound">g</a> <a id="28307" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="28309" href="../Connectives/#28309" class="Bound">h</a> <a id="28311" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="28313" class="Symbol">→</a> <a id="28315" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="28320" class="Symbol">}</a>
    <a id="28326" class="Symbol">}</a>
</pre>
<!--
Corresponding to the law
-->
<p>对应如下的定律：</p>
<pre><code>(p * n) ^ m = (p ^ m) * (n ^ m)</code></pre>
<!--
we have the isomorphism:
-->
<p>我们有如下的同构：</p>
<pre><code>A → B × C  ≃  (A → B) × (A → C)</code></pre>
<!--
That is, the assertion that if `A` holds then `B` holds and `C` holds
is the same as the assertion that if `A` holds then `B` holds and if
`A` holds then `C` holds.  The proof of left inverse requires both extensionality
and the rule `η-×` for products:
-->
<p>命题如果 <code>A</code> 成立，那么 <code>B</code> 成立和 <code>C</code> 成立，和命题如果 <code>A</code> 成立，那么 <code>B</code> 成立以及 如果 <code>A</code> 成立，那么 <code>C</code> 成立，是一样的。左逆的证明需要外延性和积的 <code>η-×</code> 规则：</p>
<pre class="Agda"><a id="→-distrib-×"></a><a id="28871" href="../Connectives/#28871" class="Function">→-distrib-×</a> <a id="28883" class="Symbol">:</a> <a id="28885" class="Symbol">∀</a> <a id="28887" class="Symbol">{</a><a id="28888" href="../Connectives/#28888" class="Bound">A</a> <a id="28890" href="../Connectives/#28890" class="Bound">B</a> <a id="28892" href="../Connectives/#28892" class="Bound">C</a> <a id="28894" class="Symbol">:</a> <a id="28896" class="PrimitiveType">Set</a><a id="28899" class="Symbol">}</a> <a id="28901" class="Symbol">→</a> <a id="28903" class="Symbol">(</a><a id="28904" href="../Connectives/#28888" class="Bound">A</a> <a id="28906" class="Symbol">→</a> <a id="28908" href="../Connectives/#28890" class="Bound">B</a> <a id="28910" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="28912" href="../Connectives/#28892" class="Bound">C</a><a id="28913" class="Symbol">)</a> <a id="28915" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="28917" class="Symbol">(</a><a id="28918" href="../Connectives/#28888" class="Bound">A</a> <a id="28920" class="Symbol">→</a> <a id="28922" href="../Connectives/#28890" class="Bound">B</a><a id="28923" class="Symbol">)</a> <a id="28925" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="28927" class="Symbol">(</a><a id="28928" href="../Connectives/#28888" class="Bound">A</a> <a id="28930" class="Symbol">→</a> <a id="28932" href="../Connectives/#28892" class="Bound">C</a><a id="28933" class="Symbol">)</a>
<a id="28935" href="../Connectives/#28871" class="Function">→-distrib-×</a> <a id="28947" class="Symbol">=</a>
  <a id="28951" class="Keyword">record</a>
    <a id="28962" class="Symbol">{</a> <a id="28964" href="../Isomorphism/#5650" class="Field">to</a>      <a id="28972" class="Symbol">=</a> <a id="28974" class="Symbol">λ{</a> <a id="28977" href="../Connectives/#28977" class="Bound">f</a> <a id="28979" class="Symbol">→</a> <a id="28981" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="28983" href="../Connectives/#2161" class="Function">proj₁</a> <a id="28989" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="28991" href="../Connectives/#28977" class="Bound">f</a> <a id="28993" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="28995" href="../Connectives/#2230" class="Function">proj₂</a> <a id="29001" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="29003" href="../Connectives/#28977" class="Bound">f</a> <a id="29005" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="29007" class="Symbol">}</a>
    <a id="29013" class="Symbol">;</a> <a id="29015" href="../Isomorphism/#5667" class="Field">from</a>    <a id="29023" class="Symbol">=</a> <a id="29025" class="Symbol">λ{</a> <a id="29028" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29030" href="../Connectives/#29030" class="Bound">g</a> <a id="29032" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29034" href="../Connectives/#29034" class="Bound">h</a> <a id="29036" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="29038" class="Symbol">→</a> <a id="29040" class="Symbol">λ</a> <a id="29042" href="../Connectives/#29042" class="Bound">x</a> <a id="29044" class="Symbol">→</a> <a id="29046" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29048" href="../Connectives/#29030" class="Bound">g</a> <a id="29050" href="../Connectives/#29042" class="Bound">x</a> <a id="29052" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29054" href="../Connectives/#29034" class="Bound">h</a> <a id="29056" href="../Connectives/#29042" class="Bound">x</a> <a id="29058" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="29060" class="Symbol">}</a>
    <a id="29066" class="Symbol">;</a> <a id="29068" href="../Isomorphism/#5684" class="Field">from∘to</a> <a id="29076" class="Symbol">=</a> <a id="29078" class="Symbol">λ{</a> <a id="29081" href="../Connectives/#29081" class="Bound">f</a> <a id="29083" class="Symbol">→</a> <a id="29085" href="../Isomorphism/#3602" class="Postulate">extensionality</a> <a id="29100" class="Symbol">λ{</a> <a id="29103" href="../Connectives/#29103" class="Bound">x</a> <a id="29105" class="Symbol">→</a> <a id="29107" href="../Connectives/#4263" class="Function">η-×</a> <a id="29111" class="Symbol">(</a><a id="29112" href="../Connectives/#29081" class="Bound">f</a> <a id="29114" href="../Connectives/#29103" class="Bound">x</a><a id="29115" class="Symbol">)</a> <a id="29117" class="Symbol">}</a> <a id="29119" class="Symbol">}</a>
    <a id="29125" class="Symbol">;</a> <a id="29127" href="../Isomorphism/#5726" class="Field">to∘from</a> <a id="29135" class="Symbol">=</a> <a id="29137" class="Symbol">λ{</a> <a id="29140" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29142" href="../Connectives/#29142" class="Bound">g</a> <a id="29144" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29146" href="../Connectives/#29146" class="Bound">h</a> <a id="29148" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="29150" class="Symbol">→</a> <a id="29152" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="29157" class="Symbol">}</a>
    <a id="29163" class="Symbol">}</a>
</pre>
<!--
## Distribution
-->
<h2 id="分配律">分配律</h2>
<!--
Products distribute over sum, up to isomorphism.  The code to validate
this fact is similar in structure to our previous results:
-->
<p>在同构意义下，积对于和满足分配律。验证这条形式的代码和之前的证明相似：</p>
<pre class="Agda"><a id="×-distrib-⊎"></a><a id="29386" href="../Connectives/#29386" class="Function">×-distrib-⊎</a> <a id="29398" class="Symbol">:</a> <a id="29400" class="Symbol">∀</a> <a id="29402" class="Symbol">{</a><a id="29403" href="../Connectives/#29403" class="Bound">A</a> <a id="29405" href="../Connectives/#29405" class="Bound">B</a> <a id="29407" href="../Connectives/#29407" class="Bound">C</a> <a id="29409" class="Symbol">:</a> <a id="29411" class="PrimitiveType">Set</a><a id="29414" class="Symbol">}</a> <a id="29416" class="Symbol">→</a> <a id="29418" class="Symbol">(</a><a id="29419" href="../Connectives/#29403" class="Bound">A</a> <a id="29421" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="29423" href="../Connectives/#29405" class="Bound">B</a><a id="29424" class="Symbol">)</a> <a id="29426" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="29428" href="../Connectives/#29407" class="Bound">C</a> <a id="29430" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="29432" class="Symbol">(</a><a id="29433" href="../Connectives/#29403" class="Bound">A</a> <a id="29435" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="29437" href="../Connectives/#29407" class="Bound">C</a><a id="29438" class="Symbol">)</a> <a id="29440" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="29442" class="Symbol">(</a><a id="29443" href="../Connectives/#29405" class="Bound">B</a> <a id="29445" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="29447" href="../Connectives/#29407" class="Bound">C</a><a id="29448" class="Symbol">)</a>
<a id="29450" href="../Connectives/#29386" class="Function">×-distrib-⊎</a> <a id="29462" class="Symbol">=</a>
  <a id="29466" class="Keyword">record</a>
    <a id="29477" class="Symbol">{</a> <a id="29479" href="../Isomorphism/#5650" class="Field">to</a>      <a id="29487" class="Symbol">=</a> <a id="29489" class="Symbol">λ{</a> <a id="29492" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29494" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="29499" href="../Connectives/#29499" class="Bound">x</a> <a id="29501" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29503" href="../Connectives/#29503" class="Bound">z</a> <a id="29505" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="29507" class="Symbol">→</a> <a id="29509" class="Symbol">(</a><a id="29510" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="29515" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29517" href="../Connectives/#29499" class="Bound">x</a> <a id="29519" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29521" href="../Connectives/#29503" class="Bound">z</a> <a id="29523" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a><a id="29524" class="Symbol">)</a>
                 <a id="29543" class="Symbol">;</a> <a id="29545" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29547" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="29552" href="../Connectives/#29552" class="Bound">y</a> <a id="29554" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29556" href="../Connectives/#29556" class="Bound">z</a> <a id="29558" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="29560" class="Symbol">→</a> <a id="29562" class="Symbol">(</a><a id="29563" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="29568" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29570" href="../Connectives/#29552" class="Bound">y</a> <a id="29572" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29574" href="../Connectives/#29556" class="Bound">z</a> <a id="29576" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a><a id="29577" class="Symbol">)</a>
                 <a id="29596" class="Symbol">}</a>
    <a id="29602" class="Symbol">;</a> <a id="29604" href="../Isomorphism/#5667" class="Field">from</a>    <a id="29612" class="Symbol">=</a> <a id="29614" class="Symbol">λ{</a> <a id="29617" class="Symbol">(</a><a id="29618" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="29623" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29625" href="../Connectives/#29625" class="Bound">x</a> <a id="29627" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29629" href="../Connectives/#29629" class="Bound">z</a> <a id="29631" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a><a id="29632" class="Symbol">)</a> <a id="29634" class="Symbol">→</a> <a id="29636" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29638" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="29643" href="../Connectives/#29625" class="Bound">x</a> <a id="29645" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29647" href="../Connectives/#29629" class="Bound">z</a> <a id="29649" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a>
                 <a id="29668" class="Symbol">;</a> <a id="29670" class="Symbol">(</a><a id="29671" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="29676" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29678" href="../Connectives/#29678" class="Bound">y</a> <a id="29680" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29682" href="../Connectives/#29682" class="Bound">z</a> <a id="29684" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a><a id="29685" class="Symbol">)</a> <a id="29687" class="Symbol">→</a> <a id="29689" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29691" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="29696" href="../Connectives/#29678" class="Bound">y</a> <a id="29698" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29700" href="../Connectives/#29682" class="Bound">z</a> <a id="29702" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a>
                 <a id="29721" class="Symbol">}</a>
    <a id="29727" class="Symbol">;</a> <a id="29729" href="../Isomorphism/#5684" class="Field">from∘to</a> <a id="29737" class="Symbol">=</a> <a id="29739" class="Symbol">λ{</a> <a id="29742" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29744" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="29749" href="../Connectives/#29749" class="Bound">x</a> <a id="29751" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29753" href="../Connectives/#29753" class="Bound">z</a> <a id="29755" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="29757" class="Symbol">→</a> <a id="29759" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="29781" class="Symbol">;</a> <a id="29783" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29785" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="29790" href="../Connectives/#29790" class="Bound">y</a> <a id="29792" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29794" href="../Connectives/#29794" class="Bound">z</a> <a id="29796" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="29798" class="Symbol">→</a> <a id="29800" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="29822" class="Symbol">}</a>
    <a id="29828" class="Symbol">;</a> <a id="29830" href="../Isomorphism/#5726" class="Field">to∘from</a> <a id="29838" class="Symbol">=</a> <a id="29840" class="Symbol">λ{</a> <a id="29843" class="Symbol">(</a><a id="29844" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="29849" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29851" href="../Connectives/#29851" class="Bound">x</a> <a id="29853" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29855" href="../Connectives/#29855" class="Bound">z</a> <a id="29857" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a><a id="29858" class="Symbol">)</a> <a id="29860" class="Symbol">→</a> <a id="29862" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="29884" class="Symbol">;</a> <a id="29886" class="Symbol">(</a><a id="29887" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="29892" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="29894" href="../Connectives/#29894" class="Bound">y</a> <a id="29896" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="29898" href="../Connectives/#29898" class="Bound">z</a> <a id="29900" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a><a id="29901" class="Symbol">)</a> <a id="29903" class="Symbol">→</a> <a id="29905" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="29927" class="Symbol">}</a>
    <a id="29933" class="Symbol">}</a>
</pre>
<!--
Sums do not distribute over products up to isomorphism, but it is an embedding:
-->
<p>和对于积不满足分配律，但满足嵌入：</p>
<pre class="Agda"><a id="⊎-distrib-×"></a><a id="30053" href="../Connectives/#30053" class="Function">⊎-distrib-×</a> <a id="30065" class="Symbol">:</a> <a id="30067" class="Symbol">∀</a> <a id="30069" class="Symbol">{</a><a id="30070" href="../Connectives/#30070" class="Bound">A</a> <a id="30072" href="../Connectives/#30072" class="Bound">B</a> <a id="30074" href="../Connectives/#30074" class="Bound">C</a> <a id="30076" class="Symbol">:</a> <a id="30078" class="PrimitiveType">Set</a><a id="30081" class="Symbol">}</a> <a id="30083" class="Symbol">→</a> <a id="30085" class="Symbol">(</a><a id="30086" href="../Connectives/#30070" class="Bound">A</a> <a id="30088" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="30090" href="../Connectives/#30072" class="Bound">B</a><a id="30091" class="Symbol">)</a> <a id="30093" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="30095" href="../Connectives/#30074" class="Bound">C</a> <a id="30097" href="../Isomorphism/#11725" class="Record Operator">≲</a> <a id="30099" class="Symbol">(</a><a id="30100" href="../Connectives/#30070" class="Bound">A</a> <a id="30102" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="30104" href="../Connectives/#30074" class="Bound">C</a><a id="30105" class="Symbol">)</a> <a id="30107" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="30109" class="Symbol">(</a><a id="30110" href="../Connectives/#30072" class="Bound">B</a> <a id="30112" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="30114" href="../Connectives/#30074" class="Bound">C</a><a id="30115" class="Symbol">)</a>
<a id="30117" href="../Connectives/#30053" class="Function">⊎-distrib-×</a> <a id="30129" class="Symbol">=</a>
  <a id="30133" class="Keyword">record</a>
    <a id="30144" class="Symbol">{</a> <a id="30146" href="../Isomorphism/#11765" class="Field">to</a>      <a id="30154" class="Symbol">=</a> <a id="30156" class="Symbol">λ{</a> <a id="30159" class="Symbol">(</a><a id="30160" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="30165" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="30167" href="../Connectives/#30167" class="Bound">x</a> <a id="30169" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="30171" href="../Connectives/#30171" class="Bound">y</a> <a id="30173" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a><a id="30174" class="Symbol">)</a> <a id="30176" class="Symbol">→</a> <a id="30178" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="30180" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="30185" href="../Connectives/#30167" class="Bound">x</a> <a id="30187" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="30189" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="30194" href="../Connectives/#30171" class="Bound">y</a> <a id="30196" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a>
                 <a id="30215" class="Symbol">;</a> <a id="30217" class="Symbol">(</a><a id="30218" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="30223" href="../Connectives/#30223" class="Bound">z</a><a id="30224" class="Symbol">)</a>         <a id="30234" class="Symbol">→</a> <a id="30236" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="30238" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="30243" href="../Connectives/#30223" class="Bound">z</a> <a id="30245" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="30247" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="30252" href="../Connectives/#30223" class="Bound">z</a> <a id="30254" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a>
                 <a id="30273" class="Symbol">}</a>
    <a id="30279" class="Symbol">;</a> <a id="30281" href="../Isomorphism/#11785" class="Field">from</a>    <a id="30289" class="Symbol">=</a> <a id="30291" class="Symbol">λ{</a> <a id="30294" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="30296" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="30301" href="../Connectives/#30301" class="Bound">x</a> <a id="30303" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="30305" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="30310" href="../Connectives/#30310" class="Bound">y</a> <a id="30312" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="30314" class="Symbol">→</a> <a id="30316" class="Symbol">(</a><a id="30317" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="30322" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="30324" href="../Connectives/#30301" class="Bound">x</a> <a id="30326" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="30328" href="../Connectives/#30310" class="Bound">y</a> <a id="30330" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a><a id="30331" class="Symbol">)</a>
                 <a id="30350" class="Symbol">;</a> <a id="30352" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="30354" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="30359" href="../Connectives/#30359" class="Bound">x</a> <a id="30361" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="30363" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="30368" href="../Connectives/#30368" class="Bound">z</a> <a id="30370" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="30372" class="Symbol">→</a> <a id="30374" class="Symbol">(</a><a id="30375" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="30380" href="../Connectives/#30368" class="Bound">z</a><a id="30381" class="Symbol">)</a>
                 <a id="30400" class="Symbol">;</a> <a id="30402" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="30404" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="30409" href="../Connectives/#30409" class="Bound">z</a> <a id="30411" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="30413" class="Symbol">_</a>      <a id="30420" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a> <a id="30422" class="Symbol">→</a> <a id="30424" class="Symbol">(</a><a id="30425" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="30430" href="../Connectives/#30409" class="Bound">z</a><a id="30431" class="Symbol">)</a>
                 <a id="30450" class="Symbol">}</a>
    <a id="30456" class="Symbol">;</a> <a id="30458" href="../Isomorphism/#11805" class="Field">from∘to</a> <a id="30466" class="Symbol">=</a> <a id="30468" class="Symbol">λ{</a> <a id="30471" class="Symbol">(</a><a id="30472" href="../Connectives/#14785" class="InductiveConstructor">inj₁</a> <a id="30477" href="../Connectives/#1745" class="InductiveConstructor Operator">⟨</a> <a id="30479" href="../Connectives/#30479" class="Bound">x</a> <a id="30481" href="../Connectives/#1745" class="InductiveConstructor Operator">,</a> <a id="30483" href="../Connectives/#30483" class="Bound">y</a> <a id="30485" href="../Connectives/#1745" class="InductiveConstructor Operator">⟩</a><a id="30486" class="Symbol">)</a> <a id="30488" class="Symbol">→</a> <a id="30490" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="30512" class="Symbol">;</a> <a id="30514" class="Symbol">(</a><a id="30515" href="../Connectives/#14827" class="InductiveConstructor">inj₂</a> <a id="30520" href="../Connectives/#30520" class="Bound">z</a><a id="30521" class="Symbol">)</a>         <a id="30531" class="Symbol">→</a> <a id="30533" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
                 <a id="30555" class="Symbol">}</a>
    <a id="30561" class="Symbol">}</a>
</pre>
<!--
Note that there is a choice in how we write the `from` function.
As given, it takes `⟨ inj₂ z , inj₂ z′ ⟩` to `inj₂ z`, but it is
easy to write a variant that instead returns `inj₂ z′`.  We have
an embedding rather than an isomorphism because the
`from` function must discard either `z` or `z′` in this case.
-->
<p>我们在定义 <code>from</code> 函数的时候可以有选择。给定的定义中，它将 <code>⟨ inj₂ z , inj₂ z′ ⟩</code> 转换为 <code>inj₂ z</code>，但我们也可以返回 <code>inj₂ z′</code> 作为嵌入证明的变种。我们在这里只能证明嵌入， 而不能证明同构，因为 <code>from</code> 函数必须丢弃 <code>z</code> 或者 <code>z′</code> 其中的一个。</p>
<!--
In the usual approach to logic, both of the distribution laws
are given as equivalences, where each side implies the other:
-->
<p>在一般的逻辑学方法中，两条分配律都以等价的形式给出，每一边都蕴涵了另一边：</p>
<pre><code>A × (B ⊎ C) ⇔ (A × B) ⊎ (A × C)
A ⊎ (B × C) ⇔ (A ⊎ B) × (A ⊎ C)</code></pre>
<!--
But when we consider the functions that provide evidence for these
implications, then the first corresponds to an isomorphism while the
second only corresponds to an embedding, revealing a sense in which
one of these laws is "more true" than the other.
-->
<p>但当我们考虑提供上述蕴涵证明的函数时，第一条对应同构而第二条只能对应嵌入， 揭示了有些定理比另一个更加的「正确」。</p>
<!--
#### Exercise `⊎-weak-×` (recommended)
-->
<h4 id="练习--weak--推荐">练习 <code>⊎-weak-×</code> （推荐）</h4>
<!--
Show that the following property holds:
-->
<p>证明如下性质成立：</p>
<pre class="Agda"><a id="31752" class="Keyword">postulate</a>
  <a id="⊎-weak-×"></a><a id="31764" href="../Connectives/#31764" class="Postulate">⊎-weak-×</a> <a id="31773" class="Symbol">:</a> <a id="31775" class="Symbol">∀</a> <a id="31777" class="Symbol">{</a><a id="31778" href="../Connectives/#31778" class="Bound">A</a> <a id="31780" href="../Connectives/#31780" class="Bound">B</a> <a id="31782" href="../Connectives/#31782" class="Bound">C</a> <a id="31784" class="Symbol">:</a> <a id="31786" class="PrimitiveType">Set</a><a id="31789" class="Symbol">}</a> <a id="31791" class="Symbol">→</a> <a id="31793" class="Symbol">(</a><a id="31794" href="../Connectives/#31778" class="Bound">A</a> <a id="31796" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="31798" href="../Connectives/#31780" class="Bound">B</a><a id="31799" class="Symbol">)</a> <a id="31801" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="31803" href="../Connectives/#31782" class="Bound">C</a> <a id="31805" class="Symbol">→</a> <a id="31807" href="../Connectives/#31778" class="Bound">A</a> <a id="31809" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="31811" class="Symbol">(</a><a id="31812" href="../Connectives/#31780" class="Bound">B</a> <a id="31814" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="31816" href="../Connectives/#31782" class="Bound">C</a><a id="31817" class="Symbol">)</a>
</pre>
<!--
This is called a _weak distributive law_. Give the corresponding
distributive law, and explain how it relates to the weak version.
-->
<p>这被称为<strong>弱分配律（Weak Distributive Law）</strong>。给出相对应的分配律，并解释分配律与弱分配律的关系。</p>
<!--
<pre class="Agda"><a id="32037" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="32073" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
#### Exercise `⊎×-implies-×⊎` (practice)
-->
<h4 id="练习--implies-实践">练习 <code>⊎×-implies-×⊎</code>（实践）</h4>
<!--
Show that a disjunct of conjuncts implies a conjunct of disjuncts:
-->
<p>证明合取的析取蕴涵了析取的合取：</p>
<pre class="Agda"><a id="32271" class="Keyword">postulate</a>
  <a id="⊎×-implies-×⊎"></a><a id="32283" href="../Connectives/#32283" class="Postulate">⊎×-implies-×⊎</a> <a id="32297" class="Symbol">:</a> <a id="32299" class="Symbol">∀</a> <a id="32301" class="Symbol">{</a><a id="32302" href="../Connectives/#32302" class="Bound">A</a> <a id="32304" href="../Connectives/#32304" class="Bound">B</a> <a id="32306" href="../Connectives/#32306" class="Bound">C</a> <a id="32308" href="../Connectives/#32308" class="Bound">D</a> <a id="32310" class="Symbol">:</a> <a id="32312" class="PrimitiveType">Set</a><a id="32315" class="Symbol">}</a> <a id="32317" class="Symbol">→</a> <a id="32319" class="Symbol">(</a><a id="32320" href="../Connectives/#32302" class="Bound">A</a> <a id="32322" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="32324" href="../Connectives/#32304" class="Bound">B</a><a id="32325" class="Symbol">)</a> <a id="32327" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="32329" class="Symbol">(</a><a id="32330" href="../Connectives/#32306" class="Bound">C</a> <a id="32332" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="32334" href="../Connectives/#32308" class="Bound">D</a><a id="32335" class="Symbol">)</a> <a id="32337" class="Symbol">→</a> <a id="32339" class="Symbol">(</a><a id="32340" href="../Connectives/#32302" class="Bound">A</a> <a id="32342" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="32344" href="../Connectives/#32306" class="Bound">C</a><a id="32345" class="Symbol">)</a> <a id="32347" href="../Connectives/#1714" class="Datatype Operator">×</a> <a id="32349" class="Symbol">(</a><a id="32350" href="../Connectives/#32304" class="Bound">B</a> <a id="32352" href="../Connectives/#14754" class="Datatype Operator">⊎</a> <a id="32354" href="../Connectives/#32308" class="Bound">D</a><a id="32355" class="Symbol">)</a>
</pre>
<!--
Does the converse hold? If so, prove; if not, give a counterexample.
-->
<p>反命题成立吗？如果成立，给出证明；如果不成立，给出反例。</p>
<!--
<pre class="Agda"><a id="32480" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="32516" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
## Standard library
-->
<h2 id="标准库">标准库</h2>
<!--
Definitions similar to those in this chapter can be found in the standard library:
-->
<p>标准库中可以找到与本章节中相似的定义：</p>
<pre class="Agda"><a id="32690" class="Keyword">import</a> <a id="32697" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html" class="Module">Data.Product</a> <a id="32710" class="Keyword">using</a> <a id="32716" class="Symbol">(</a><a id="32717" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">_×_</a><a id="32720" class="Symbol">;</a> <a id="32722" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="32727" class="Symbol">;</a> <a id="32729" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="32734" class="Symbol">)</a> <a id="32736" class="Keyword">renaming</a> <a id="32745" class="Symbol">(</a><a id="32746" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="32750" class="Symbol">to</a> <a id="_,_"></a><a id="32753" href="../Connectives/#32753" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="32758" class="Symbol">)</a>
<a id="32760" class="Keyword">import</a> <a id="32767" href="https://agda.github.io/agda-stdlib/v1.3/Data.Unit.html" class="Module">Data.Unit</a> <a id="32777" class="Keyword">using</a> <a id="32783" class="Symbol">(</a><a id="32784" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="32785" class="Symbol">;</a> <a id="32787" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="32789" class="Symbol">)</a>
<a id="32791" class="Keyword">import</a> <a id="32798" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.html" class="Module">Data.Sum</a> <a id="32807" class="Keyword">using</a> <a id="32813" class="Symbol">(</a><a id="32814" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#728" class="Datatype Operator">_⊎_</a><a id="32817" class="Symbol">;</a> <a id="32819" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#778" class="InductiveConstructor">inj₁</a><a id="32823" class="Symbol">;</a> <a id="32825" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#803" class="InductiveConstructor">inj₂</a><a id="32829" class="Symbol">)</a> <a id="32831" class="Keyword">renaming</a> <a id="32840" class="Symbol">(</a><a id="32841" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#914" class="Function Operator">[_,_]</a> <a id="32847" class="Symbol">to</a> <a id="[_,_]"></a><a id="32850" href="../Connectives/#32850" class="Function Operator">case-⊎</a><a id="32856" class="Symbol">)</a>
<a id="32858" class="Keyword">import</a> <a id="32865" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html" class="Module">Data.Empty</a> <a id="32876" class="Keyword">using</a> <a id="32882" class="Symbol">(</a><a id="32883" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#526" class="Datatype">⊥</a><a id="32884" class="Symbol">;</a> <a id="32886" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a><a id="32892" class="Symbol">)</a>
<a id="32894" class="Keyword">import</a> <a id="32901" href="https://agda.github.io/agda-stdlib/v1.3/Function.Equivalence.html" class="Module">Function.Equivalence</a> <a id="32922" class="Keyword">using</a> <a id="32928" class="Symbol">(</a><a id="32929" href="https://agda.github.io/agda-stdlib/v1.3/Function.Equivalence.html#971" class="Function Operator">_⇔_</a><a id="32932" class="Symbol">)</a>
</pre>
<!--
The standard library constructs pairs with `_,_` whereas we use `⟨_,_⟩`.
The former makes it convenient to build triples or larger tuples from pairs,
permitting `a , b , c` to stand for `(a , (b , c))`.  But it conflicts with
other useful notations, such as `[_,_]` to construct a list of two elements in
Chapter [Lists](/Lists/)
and `Γ , A` to extend environments in
Chapter [DeBruijn](/DeBruijn/).
The standard library `_⇔_` is similar to ours, but the one in the
standard library is less convenient, since it is parameterised with
respect to an arbitrary notion of equivalence.
-->
<p>标准库中使用 <code>_,_</code> 构造数据对，而我们使用 <code>⟨_,_⟩</code>。前者在从数据对构造三元对或者更大的 元组时更加的方便，允许 <code>a , b , c</code> 作为 <code>(a, (b , c))</code> 的记法。但它与其他有用的记法相冲突， 比如说 <a href="../Lists/">Lists</a> 中的 <code>[_,_]</code> 记法表示两个元素的列表， 或者 <a href="../DeBruijn/">DeBruijn</a> 章节中的 <code>Γ , A</code> 来表示环境的扩展。 标准库中的 <code>_⇔_</code> 和我们的相似，但使用起来比较不便， 因为它可以根据任意的相等性定义进行参数化。</p>
<h2 id="unicode">Unicode</h2>
<!--
This chapter uses the following unicode:

    ×  U+00D7  MULTIPLICATION SIGN (\x)
    ⊎  U+228E  MULTISET UNION (\u+)
    ⊤  U+22A4  DOWN TACK (\top)
    ⊥  U+22A5  UP TACK (\bot)
    η  U+03B7  GREEK SMALL LETTER ETA (\eta)
    ₁  U+2081  SUBSCRIPT ONE (\_1)
    ₂  U+2082  SUBSCRIPT TWO (\_2)
    ⇔  U+21D4  LEFT RIGHT DOUBLE ARROW (\<=>)
-->
<p>本章节使用下列 Unicode：</p>
<pre><code>×  U+00D7  乘法符号 (\x)
⊎  U+228E  多重集并集 (\u+)
⊤  U+22A4  向下图钉 (\top)
⊥  U+22A5  向上图钉 (\bot)
η  U+03B7  希腊小写字母 ETA (\eta)
₁  U+2081  下标 1 (\_1)
₂  U+2082  下标 2 (\_2)
⇔  U+21D4  左右双箭头 (\&lt;=&gt;)</code></pre>
<!--
[^from-wadler-2015]: This paragraph was adopted from "Propositions as Types", Philip Wadler, _Communications of the ACM_, December 2015.
-->
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>此段内容由 Propositions as Types（命题即类型）改编而来， 作者：Philip Wadler，发表于 《ACM 通讯》，2015 年 9 月<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
    </div>
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Isomorphism/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Connectives.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Negation/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

</article>

            </div>
        </main>
        <footer class="site-footer h-card">
    <data class="u-url" href="../"></data>
    <div class="wrapper">
        <h2 class="footer-heading">编程语言基础：Agda 语言描述</h2>
        
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Philip Wadler</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wadler" title="wadler"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wadler</a></li>
    
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Wen Kokke</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wenkokke</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;wenkokke</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Jeremy G. Siek</li>
                    <li>
                        
                        <a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/jsiek" title="jsiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;jsiek</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;jeremysiek</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        
        This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
    </div>
</footer>

    </body>
</html>
