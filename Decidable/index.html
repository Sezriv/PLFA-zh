<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../public/css/style.css">
  
  <title>编程语言基础：Agda 语言描述 – Decidable</title>
  
  
  
</head>

    <body>
        <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="../">编程语言基础：Agda 语言描述</a>
        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="../">主页</a>
                <a class="page-link" href="../Announcements/">公告</a>
                <a class="page-link" href="../GettingStarted/">使用说明</a>
                <a class="page-link" href="../Citing/">引用</a>
                <a class="page-link" href="https://plfa.github.io/">English</a>
            </div>
        </nav>
    </div>
</header>

        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Quantifiers/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Decidable.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Lists/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

    <header class="post-header">
        <h1 class="post-title" id="decidable">Decidable: 布尔值与判定过程</h1>
    </header>
    <div class="post-content">
        <pre class="Agda"><a id="197" class="Keyword">module</a> <a id="204" href="../Decidable/" class="Module">plfa.part1.Decidable</a> <a id="225" class="Keyword">where</a>
</pre>
<!--
We have a choice as to how to represent relations:
as an inductive data type of _evidence_ that the relation holds,
or as a function that _computes_ whether the relation holds.
Here we explore the relation between these choices.
We first explore the familiar notion of _booleans_,
but later discover that these are best avoided in favour
of a new notion of _decidable_.
-->
<p>我们有两种不同的方式来表示关系：一是表示为由关系成立的<strong>证明（Evidence）</strong>所构成的数据类型； 二是表示为一个<strong>计算（Compute）</strong>关系是否成立的函数。在本章中，我们将探讨这两种方式之间的关系。 我们首先研究大家熟悉的<strong>布尔值（Boolean）</strong>记法，但是之后我们会发现，相较布尔值记法， 使用一种新的<strong>可判定性（Decidable）</strong>记法将会是更好的选择。</p>
<!--
## Imports
-->
<h2 id="导入">导入</h2>
<pre class="Agda"><a id="842" class="Keyword">import</a> <a id="849" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="887" class="Symbol">as</a> <a id="890" class="Module">Eq</a>
<a id="893" class="Keyword">open</a> <a id="898" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="901" class="Keyword">using</a> <a id="907" class="Symbol">(</a><a id="908" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="911" class="Symbol">;</a> <a id="913" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="917" class="Symbol">)</a>
<a id="919" class="Keyword">open</a> <a id="924" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2419" class="Module">Eq.≡-Reasoning</a>
<a id="939" class="Keyword">open</a> <a id="944" class="Keyword">import</a> <a id="951" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.html" class="Module">Data.Nat</a> <a id="960" class="Keyword">using</a> <a id="966" class="Symbol">(</a><a id="967" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="968" class="Symbol">;</a> <a id="970" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="974" class="Symbol">;</a> <a id="976" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="979" class="Symbol">)</a>
<a id="981" class="Keyword">open</a> <a id="986" class="Keyword">import</a> <a id="993" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html" class="Module">Data.Product</a> <a id="1006" class="Keyword">using</a> <a id="1012" class="Symbol">(</a><a id="1013" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">_×_</a><a id="1016" class="Symbol">)</a> <a id="1018" class="Keyword">renaming</a> <a id="1027" class="Symbol">(</a><a id="1028" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="1032" class="Symbol">to</a> <a id="_,_"></a><a id="1035" href="../Decidable/#1035" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="1040" class="Symbol">)</a>
<a id="1042" class="Keyword">open</a> <a id="1047" class="Keyword">import</a> <a id="1054" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.html" class="Module">Data.Sum</a> <a id="1063" class="Keyword">using</a> <a id="1069" class="Symbol">(</a><a id="1070" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#728" class="Datatype Operator">_⊎_</a><a id="1073" class="Symbol">;</a> <a id="1075" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#778" class="InductiveConstructor">inj₁</a><a id="1079" class="Symbol">;</a> <a id="1081" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#803" class="InductiveConstructor">inj₂</a><a id="1085" class="Symbol">)</a>
<a id="1087" class="Keyword">open</a> <a id="1092" class="Keyword">import</a> <a id="1099" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="1116" class="Keyword">using</a> <a id="1122" class="Symbol">(</a><a id="1123" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬_</a><a id="1125" class="Symbol">)</a>
<a id="1127" class="Keyword">open</a> <a id="1132" class="Keyword">import</a> <a id="1139" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="1165" class="Keyword">using</a> <a id="1171" class="Symbol">()</a>
  <a id="1176" class="Keyword">renaming</a> <a id="1185" class="Symbol">(</a><a id="1186" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.Negation.html#858" class="Function">contradiction</a> <a id="1200" class="Symbol">to</a> <a id="contradiction"></a><a id="1203" href="../Decidable/#1203" class="Function">¬¬-intro</a><a id="1211" class="Symbol">)</a>
<a id="1213" class="Keyword">open</a> <a id="1218" class="Keyword">import</a> <a id="1225" href="https://agda.github.io/agda-stdlib/v1.3/Data.Unit.html" class="Module">Data.Unit</a> <a id="1235" class="Keyword">using</a> <a id="1241" class="Symbol">(</a><a id="1242" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="1243" class="Symbol">;</a> <a id="1245" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="1247" class="Symbol">)</a>
<a id="1249" class="Keyword">open</a> <a id="1254" class="Keyword">import</a> <a id="1261" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html" class="Module">Data.Empty</a> <a id="1272" class="Keyword">using</a> <a id="1278" class="Symbol">(</a><a id="1279" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#526" class="Datatype">⊥</a><a id="1280" class="Symbol">;</a> <a id="1282" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a><a id="1288" class="Symbol">)</a>
<a id="1290" class="Keyword">open</a> <a id="1295" class="Keyword">import</a> <a id="1302" href="../Relations/" class="Module">plfa.part1.Relations</a> <a id="1323" class="Keyword">using</a> <a id="1329" class="Symbol">(</a><a id="1330" href="../Relations/#26518" class="Datatype Operator">_&lt;_</a><a id="1333" class="Symbol">;</a> <a id="1335" href="../Relations/#26545" class="InductiveConstructor">z&lt;s</a><a id="1338" class="Symbol">;</a> <a id="1340" href="../Relations/#26602" class="InductiveConstructor">s&lt;s</a><a id="1343" class="Symbol">)</a>
<a id="1345" class="Keyword">open</a> <a id="1350" class="Keyword">import</a> <a id="1357" href="../Isomorphism/" class="Module">plfa.part1.Isomorphism</a> <a id="1380" class="Keyword">using</a> <a id="1386" class="Symbol">(</a><a id="1387" href="../Isomorphism/#14988" class="Record Operator">_⇔_</a><a id="1390" class="Symbol">)</a>
</pre>
<!--
## Evidence vs Computation
-->
<h2 id="证据-vs-计算">证据 vs 计算</h2>
<!--
Recall that Chapter [Relations](/Relations/)
defined comparison as an inductive datatype,
which provides _evidence_ that one number
is less than or equal to another:
-->
<p>回忆我们在 <a href="../Relations/">Relations</a> 章节中将比较定义为一个归纳数据类型，其提供了一个数小于或等于另外一个数的证明：</p>
<pre class="Agda"><a id="1699" class="Keyword">infix</a> <a id="1705" class="Number">4</a> <a id="1707" href="../Decidable/#1717" class="Datatype Operator">_≤_</a>

<a id="1712" class="Keyword">data</a> <a id="_≤_"></a><a id="1717" href="../Decidable/#1717" class="Datatype Operator">_≤_</a> <a id="1721" class="Symbol">:</a> <a id="1723" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="1725" class="Symbol">→</a> <a id="1727" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="1729" class="Symbol">→</a> <a id="1731" class="PrimitiveType">Set</a> <a id="1735" class="Keyword">where</a>

  <a id="_≤_.z≤n"></a><a id="1744" href="../Decidable/#1744" class="InductiveConstructor">z≤n</a> <a id="1748" class="Symbol">:</a> <a id="1750" class="Symbol">∀</a> <a id="1752" class="Symbol">{</a><a id="1753" href="../Decidable/#1753" class="Bound">n</a> <a id="1755" class="Symbol">:</a> <a id="1757" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="1758" class="Symbol">}</a>
      <a id="1766" class="Comment">--------</a>
    <a id="1779" class="Symbol">→</a> <a id="1781" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="1786" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="1788" href="../Decidable/#1753" class="Bound">n</a>

  <a id="_≤_.s≤s"></a><a id="1793" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="1797" class="Symbol">:</a> <a id="1799" class="Symbol">∀</a> <a id="1801" class="Symbol">{</a><a id="1802" href="../Decidable/#1802" class="Bound">m</a> <a id="1804" href="../Decidable/#1804" class="Bound">n</a> <a id="1806" class="Symbol">:</a> <a id="1808" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="1809" class="Symbol">}</a>
    <a id="1815" class="Symbol">→</a> <a id="1817" href="../Decidable/#1802" class="Bound">m</a> <a id="1819" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="1821" href="../Decidable/#1804" class="Bound">n</a>
      <a id="1829" class="Comment">-------------</a>
    <a id="1847" class="Symbol">→</a> <a id="1849" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1853" href="../Decidable/#1802" class="Bound">m</a> <a id="1855" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="1857" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1861" href="../Decidable/#1804" class="Bound">n</a>
</pre>
<!--
For example, we can provide evidence that `2 ≤ 4`,
and show there is no possible evidence that `4 ≤ 2`:
-->
<p>举例来说，我们提供 <code>2 ≤ 4</code> 成立的证明，也可以证明没有 <code>4 ≤ 2</code> 成立的证明。</p>
<pre class="Agda"><a id="2≤4"></a><a id="2034" href="../Decidable/#2034" class="Function">2≤4</a> <a id="2038" class="Symbol">:</a> <a id="2040" class="Number">2</a> <a id="2042" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="2044" class="Number">4</a>
<a id="2046" href="../Decidable/#2034" class="Function">2≤4</a> <a id="2050" class="Symbol">=</a> <a id="2052" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="2056" class="Symbol">(</a><a id="2057" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="2061" href="../Decidable/#1744" class="InductiveConstructor">z≤n</a><a id="2064" class="Symbol">)</a>

<a id="¬4≤2"></a><a id="2067" href="../Decidable/#2067" class="Function">¬4≤2</a> <a id="2072" class="Symbol">:</a> <a id="2074" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="2076" class="Symbol">(</a><a id="2077" class="Number">4</a> <a id="2079" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="2081" class="Number">2</a><a id="2082" class="Symbol">)</a>
<a id="2084" href="../Decidable/#2067" class="Function">¬4≤2</a> <a id="2089" class="Symbol">(</a><a id="2090" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="2094" class="Symbol">(</a><a id="2095" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="2099" class="Symbol">()))</a>
</pre>
<!--
The occurrence of `()` attests to the fact that there is
no possible evidence for `2 ≤ 0`, which `z≤n` cannot match
(because `2` is not `zero`) and `s≤s` cannot match
(because `0` cannot match `suc n`).
-->
<p><code>()</code> 的出现表明了没有 <code>2 ≤ 0</code> 成立的证明：<code>z≤n</code> 不能匹配（因为 <code>2</code> 不是 <code>zero</code>），<code>s≤s</code> 也不能匹配（因为 <code>0</code> 不能匹配 <code>suc n</code>）。</p>
<!--
An alternative, which may seem more familiar, is to define a
type of booleans:
-->
<p>作为替代的定义，我们可以定义一个大家可能比较熟悉的布尔类型：</p>
<pre class="Agda"><a id="2539" class="Keyword">data</a> <a id="Bool"></a><a id="2544" href="../Decidable/#2544" class="Datatype">Bool</a> <a id="2549" class="Symbol">:</a> <a id="2551" class="PrimitiveType">Set</a> <a id="2555" class="Keyword">where</a>
  <a id="Bool.true"></a><a id="2563" href="../Decidable/#2563" class="InductiveConstructor">true</a>  <a id="2569" class="Symbol">:</a> <a id="2571" href="../Decidable/#2544" class="Datatype">Bool</a>
  <a id="Bool.false"></a><a id="2578" href="../Decidable/#2578" class="InductiveConstructor">false</a> <a id="2584" class="Symbol">:</a> <a id="2586" href="../Decidable/#2544" class="Datatype">Bool</a>
</pre>
<!--
Given booleans, we can define a function of two numbers that
_computes_ to `true` if the comparison holds and to `false` otherwise:
-->
<p>给定了布尔类型，我们可以定义一个两个数的函数在比较关系成立时来<strong>计算</strong>出 <code>true</code>， 否则计算出 <code>false</code>：</p>
<pre class="Agda"><a id="2805" class="Keyword">infix</a> <a id="2811" class="Number">4</a> <a id="2813" href="../Decidable/#2819" class="Function Operator">_≤ᵇ_</a>

<a id="_≤ᵇ_"></a><a id="2819" href="../Decidable/#2819" class="Function Operator">_≤ᵇ_</a> <a id="2824" class="Symbol">:</a> <a id="2826" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2828" class="Symbol">→</a> <a id="2830" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2832" class="Symbol">→</a> <a id="2834" href="../Decidable/#2544" class="Datatype">Bool</a>
<a id="2839" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="2844" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="2847" href="../Decidable/#2847" class="Bound">n</a>       <a id="2855" class="Symbol">=</a>  <a id="2858" href="../Decidable/#2563" class="InductiveConstructor">true</a>
<a id="2863" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2867" href="../Decidable/#2867" class="Bound">m</a> <a id="2869" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="2872" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>   <a id="2879" class="Symbol">=</a>  <a id="2882" href="../Decidable/#2578" class="InductiveConstructor">false</a>
<a id="2888" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2892" href="../Decidable/#2892" class="Bound">m</a> <a id="2894" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="2897" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2901" href="../Decidable/#2901" class="Bound">n</a>  <a id="2904" class="Symbol">=</a>  <a id="2907" href="../Decidable/#2892" class="Bound">m</a> <a id="2909" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="2912" href="../Decidable/#2901" class="Bound">n</a>
</pre>
<!--
The first and last clauses of this definition resemble the two
constructors of the corresponding inductive datatype, while the
middle clause arises because there is no possible evidence that
`suc m ≤ zero` for any `m`.
For example, we can compute that `2 ≤ᵇ 4` holds,
and we can compute that `4 ≤ᵇ 2` does not hold:
-->
<p>定义中的第一条与最后一条与归纳数据类型中的两个构造子相对应。因为对于任意的 <code>m</code>，不可能出现 <code>suc m ≤ zero</code> 的证明，我们使用中间一条定义来表示。 举个例子，我们可以计算 <code>2 ≤ᵇ 4</code> 成立，也可以计算 <code>4 ≤ᵇ 2</code> 不成立：</p>
<pre class="Agda"><a id="3376" href="../Decidable/#3376" class="Function">_</a> <a id="3378" class="Symbol">:</a> <a id="3380" class="Symbol">(</a><a id="3381" class="Number">2</a> <a id="3383" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="3386" class="Number">4</a><a id="3387" class="Symbol">)</a> <a id="3389" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3391" href="../Decidable/#2563" class="InductiveConstructor">true</a>
<a id="3396" class="Symbol">_</a> <a id="3398" class="Symbol">=</a>
  <a id="3402" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="3412" class="Number">2</a> <a id="3414" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="3417" class="Number">4</a>
  <a id="3421" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="3429" class="Number">1</a> <a id="3431" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="3434" class="Number">3</a>
  <a id="3438" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="3446" class="Number">0</a> <a id="3448" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="3451" class="Number">2</a>
  <a id="3455" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="3463" href="../Decidable/#2563" class="InductiveConstructor">true</a>
  <a id="3470" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>

<a id="3473" href="../Decidable/#3473" class="Function">_</a> <a id="3475" class="Symbol">:</a> <a id="3477" class="Symbol">(</a><a id="3478" class="Number">4</a> <a id="3480" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="3483" class="Number">2</a><a id="3484" class="Symbol">)</a> <a id="3486" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3488" href="../Decidable/#2578" class="InductiveConstructor">false</a>
<a id="3494" class="Symbol">_</a> <a id="3496" class="Symbol">=</a>
  <a id="3500" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="3510" class="Number">4</a> <a id="3512" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="3515" class="Number">2</a>
  <a id="3519" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="3527" class="Number">3</a> <a id="3529" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="3532" class="Number">1</a>
  <a id="3536" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="3544" class="Number">2</a> <a id="3546" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="3549" class="Number">0</a>
  <a id="3553" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="3561" href="../Decidable/#2578" class="InductiveConstructor">false</a>
  <a id="3569" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
In the first case, it takes two steps to reduce the first argument to zero,
and one more step to compute true, corresponding to the two uses of `s≤s`
and the one use of `z≤n` when providing evidence that `2 ≤ 4`.
In the second case, it takes two steps to reduce the second argument to zero,
and one more step to compute false, corresponding to the two uses of `s≤s`
and the one use of `()` when showing there can be no evidence that `4 ≤ 2`.
-->
<p>在第一种情况中，我们需要两步来将第一个参数降低到 0，再用一步来计算出真，这对应着我们需要 使用两次 <code>s≤s</code> 和一次 <code>z≤n</code> 来证明 <code>2 ≤ 4</code>。 在第二种情况中，我们需要两步来将第二个参数降低到 0，再用一步来计算出假，这对应着我们需要 使用两次 <code>s≤s</code> 和一次 <code>()</code> 来说明没有 <code>4 ≤ 2</code> 的证明。</p>
<!--
## Relating evidence and computation
-->
<h2 id="将证明与计算相联系">将证明与计算相联系</h2>
<!--
We would hope to be able to show these two approaches are related, and
indeed we can.  First, we define a function that lets us map from the
computation world to the evidence world:
-->
<p>我们希望能够证明这两种方法是有联系的，而我们的确可以。 首先，我们定义一个函数来把计算世界映射到证明世界：</p>
<pre class="Agda"><a id="T"></a><a id="4506" href="../Decidable/#4506" class="Function">T</a> <a id="4508" class="Symbol">:</a> <a id="4510" href="../Decidable/#2544" class="Datatype">Bool</a> <a id="4515" class="Symbol">→</a> <a id="4517" class="PrimitiveType">Set</a>
<a id="4521" href="../Decidable/#4506" class="Function">T</a> <a id="4523" href="../Decidable/#2563" class="InductiveConstructor">true</a>   <a id="4530" class="Symbol">=</a>  <a id="4533" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="4535" href="../Decidable/#4506" class="Function">T</a> <a id="4537" href="../Decidable/#2578" class="InductiveConstructor">false</a>  <a id="4544" class="Symbol">=</a>  <a id="4547" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#526" class="Datatype">⊥</a>
</pre>
<!--
Recall that `⊤` is the unit type which contains the single element `tt`,
and the `⊥` is the empty type which contains no values.  (Also note that
`T` is a capital letter t, and distinct from `⊤`.)  If `b` is of type `Bool`,
then `tt` provides evidence that `T b` holds if `b` is true, while there is
no possible evidence that `T b` holds if `b` is false.
-->
<p>回忆到 <code>⊤</code> 是只有一个元素 <code>tt</code> 的单元类型，<code>⊥</code> 是没有值的空类型。（注意 <code>T</code> 是大写字母 <code>t</code>， 与 <code>⊤</code> 不同。）如果 <code>b</code> 是 <code>Bool</code> 类型的，那么如果 <code>b</code> 为真，<code>tt</code> 可以提供 <code>T b</code> 成立的证明； 如果 <code>b</code> 为假，则不可能有 <code>T b</code> 成立的证明。</p>
<!--
Another way to put this is that `T b` is inhabited exactly when `b ≡ true`
is inhabited.
In the forward direction, we need to do a case analysis on the boolean `b`:
-->
<p>换句话说，<code>T b</code> 当且仅当 <code>b ≡ true</code> 成立时成立。在向前的方向，我们需要针对 <code>b</code> 进行情况分析：</p>
<pre class="Agda"><a id="T→≡"></a><a id="5312" href="../Decidable/#5312" class="Function">T→≡</a> <a id="5316" class="Symbol">:</a> <a id="5318" class="Symbol">∀</a> <a id="5320" class="Symbol">(</a><a id="5321" href="../Decidable/#5321" class="Bound">b</a> <a id="5323" class="Symbol">:</a> <a id="5325" href="../Decidable/#2544" class="Datatype">Bool</a><a id="5329" class="Symbol">)</a> <a id="5331" class="Symbol">→</a> <a id="5333" href="../Decidable/#4506" class="Function">T</a> <a id="5335" href="../Decidable/#5321" class="Bound">b</a> <a id="5337" class="Symbol">→</a> <a id="5339" href="../Decidable/#5321" class="Bound">b</a> <a id="5341" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="5343" href="../Decidable/#2563" class="InductiveConstructor">true</a>
<a id="5348" href="../Decidable/#5312" class="Function">T→≡</a> <a id="5352" href="../Decidable/#2563" class="InductiveConstructor">true</a> <a id="5357" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>   <a id="5362" class="Symbol">=</a>  <a id="5365" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="5370" href="../Decidable/#5312" class="Function">T→≡</a> <a id="5374" href="../Decidable/#2578" class="InductiveConstructor">false</a> <a id="5380" class="Symbol">()</a>
</pre>
<!--
If `b` is true then `T b` is inhabited by `tt` and `b ≡ true` is inhabited
by `refl`, while if `b` is false then `T b` in uninhabited.
-->
<p>如果 <code>b</code> 为真，那么 <code>T b</code> 由 <code>tt</code> 证明，<code>b ≡ true</code> 由 <code>refl</code> 证明。 当 <code>b</code> 为假，那么 <code>T b</code> 无法证明。</p>
<!--
In the reverse direction, there is no need for a case analysis on the boolean `b`:
-->
<p>在向后的方向，不需要针对布尔值 <code>b</code> 的情况分析：</p>
<pre class="Agda"><a id="≡→T"></a><a id="5736" href="../Decidable/#5736" class="Function">≡→T</a> <a id="5740" class="Symbol">:</a> <a id="5742" class="Symbol">∀</a> <a id="5744" class="Symbol">{</a><a id="5745" href="../Decidable/#5745" class="Bound">b</a> <a id="5747" class="Symbol">:</a> <a id="5749" href="../Decidable/#2544" class="Datatype">Bool</a><a id="5753" class="Symbol">}</a> <a id="5755" class="Symbol">→</a> <a id="5757" href="../Decidable/#5745" class="Bound">b</a> <a id="5759" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="5761" href="../Decidable/#2563" class="InductiveConstructor">true</a> <a id="5766" class="Symbol">→</a> <a id="5768" href="../Decidable/#4506" class="Function">T</a> <a id="5770" href="../Decidable/#5745" class="Bound">b</a>
<a id="5772" href="../Decidable/#5736" class="Function">≡→T</a> <a id="5776" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>  <a id="5782" class="Symbol">=</a>  <a id="5785" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
</pre>
<!--
If `b ≡ true` is inhabited by `refl` we know that `b` is `true` and
hence `T b` is inhabited by `tt`.
-->
<p>如果 <code>b ≡ true</code> 由 <code>refl</code> 证明，我们知道 <code>b</code> 是 <code>true</code>，因此 <code>T b</code> 由 <code>tt</code> 证明。</p>
<!--
Now we can show that `T (m ≤ᵇ n)` is inhabited exactly when `m ≤ n` is inhabited.
-->
<p>现在我们可以证明 <code>T (m ≤ᵇ n)</code> 当且仅当 <code>m ≤ n</code> 成立时成立。</p>
<!--
In the forward direction, we consider the three clauses in the definition
of `_≤ᵇ_`:
-->
<p>在向前的方向，我们考虑 <code>_≤ᵇ_</code> 定义中的三条语句：</p>
<pre class="Agda"><a id="≤ᵇ→≤"></a><a id="6234" href="../Decidable/#6234" class="Function">≤ᵇ→≤</a> <a id="6239" class="Symbol">:</a> <a id="6241" class="Symbol">∀</a> <a id="6243" class="Symbol">(</a><a id="6244" href="../Decidable/#6244" class="Bound">m</a> <a id="6246" href="../Decidable/#6246" class="Bound">n</a> <a id="6248" class="Symbol">:</a> <a id="6250" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="6251" class="Symbol">)</a> <a id="6253" class="Symbol">→</a> <a id="6255" href="../Decidable/#4506" class="Function">T</a> <a id="6257" class="Symbol">(</a><a id="6258" href="../Decidable/#6244" class="Bound">m</a> <a id="6260" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="6263" href="../Decidable/#6246" class="Bound">n</a><a id="6264" class="Symbol">)</a> <a id="6266" class="Symbol">→</a> <a id="6268" href="../Decidable/#6244" class="Bound">m</a> <a id="6270" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="6272" href="../Decidable/#6246" class="Bound">n</a>
<a id="6274" href="../Decidable/#6234" class="Function">≤ᵇ→≤</a> <a id="6279" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="6287" href="../Decidable/#6287" class="Bound">n</a>       <a id="6295" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>  <a id="6299" class="Symbol">=</a>  <a id="6302" href="../Decidable/#1744" class="InductiveConstructor">z≤n</a>
<a id="6306" href="../Decidable/#6234" class="Function">≤ᵇ→≤</a> <a id="6311" class="Symbol">(</a><a id="6312" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6316" href="../Decidable/#6316" class="Bound">m</a><a id="6317" class="Symbol">)</a> <a id="6319" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="6327" class="Symbol">()</a>
<a id="6330" href="../Decidable/#6234" class="Function">≤ᵇ→≤</a> <a id="6335" class="Symbol">(</a><a id="6336" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6340" href="../Decidable/#6340" class="Bound">m</a><a id="6341" class="Symbol">)</a> <a id="6343" class="Symbol">(</a><a id="6344" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6348" href="../Decidable/#6348" class="Bound">n</a><a id="6349" class="Symbol">)</a> <a id="6351" href="../Decidable/#6351" class="Bound">t</a>   <a id="6355" class="Symbol">=</a>  <a id="6358" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="6362" class="Symbol">(</a><a id="6363" href="../Decidable/#6234" class="Function">≤ᵇ→≤</a> <a id="6368" href="../Decidable/#6340" class="Bound">m</a> <a id="6370" href="../Decidable/#6348" class="Bound">n</a> <a id="6372" href="../Decidable/#6351" class="Bound">t</a><a id="6373" class="Symbol">)</a>
</pre>
<!--
In the first clause, we immediately have that `zero ≤ᵇ n` is
true, so `T (m ≤ᵇ n)` is evidenced by `tt`, and correspondingly `m ≤ n` is
evidenced by `z≤n`. In the middle clause, we immediately have that
`suc m ≤ᵇ zero` is false, and hence `T (m ≤ᵇ n)` is empty, so we need
not provide evidence that `m ≤ n`, which is just as well since there is no
such evidence.  In the last clause, we have that `suc m ≤ᵇ suc n` recurses
to `m ≤ᵇ n`.  We let `t` be the evidence of `T (suc m ≤ᵇ suc n)` if it exists,
which, by definition of `_≤ᵇ_`, will also be evidence of `T (m ≤ᵇ n)`.
We recursively invoke the function to get evidence that `m ≤ n`, which
`s≤s` converts to evidence that `suc m ≤ suc n`.
-->
<p>第一条语句中，我们立即可以得出 <code>zero ≤ᵇ n</code> 为真，所以 <code>T (m ≤ᵇ n)</code> 由 <code>tt</code> 而得， 相对应地 <code>m ≤ n</code> 由 <code>z≤n</code> 而证明。在中间的语句中，我们立刻得出 <code>suc m ≤ᵇ zero</code> 为假，则 <code>T (m ≤ᵇ n)</code> 为空，因此我们无需证明 <code>m ≤ n</code>，同时也不存在这样的证明。在最后的语句中，我们对于 <code>suc m ≤ᵇ suc n</code> 递归至 <code>m ≤ᵇ n</code>。令 <code>t</code> 为 <code>T (suc m ≤ᵇ suc n)</code> 的证明，如果其存在。 根据 <code>_≤ᵇ_</code> 的定义，这也是 <code>T (m ≤ᵇ n)</code> 的证明。我们递归地应用函数来获得 <code>m ≤ n</code> 的证明，再使用 <code>s≤s</code> 将其转换成为 <code>suc m ≤ suc n</code> 的证明。</p>
<!--
In the reverse direction, we consider the possible forms of evidence
that `m ≤ n`:
-->
<p>在向后的方向，我们考虑 <code>m ≤ n</code> 成立证明的可能形式：</p>
<pre class="Agda"><a id="≤→≤ᵇ"></a><a id="7558" href="../Decidable/#7558" class="Function">≤→≤ᵇ</a> <a id="7563" class="Symbol">:</a> <a id="7565" class="Symbol">∀</a> <a id="7567" class="Symbol">{</a><a id="7568" href="../Decidable/#7568" class="Bound">m</a> <a id="7570" href="../Decidable/#7570" class="Bound">n</a> <a id="7572" class="Symbol">:</a> <a id="7574" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="7575" class="Symbol">}</a> <a id="7577" class="Symbol">→</a> <a id="7579" href="../Decidable/#7568" class="Bound">m</a> <a id="7581" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="7583" href="../Decidable/#7570" class="Bound">n</a> <a id="7585" class="Symbol">→</a> <a id="7587" href="../Decidable/#4506" class="Function">T</a> <a id="7589" class="Symbol">(</a><a id="7590" href="../Decidable/#7568" class="Bound">m</a> <a id="7592" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="7595" href="../Decidable/#7570" class="Bound">n</a><a id="7596" class="Symbol">)</a>
<a id="7598" href="../Decidable/#7558" class="Function">≤→≤ᵇ</a> <a id="7603" href="../Decidable/#1744" class="InductiveConstructor">z≤n</a>        <a id="7614" class="Symbol">=</a>  <a id="7617" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
<a id="7620" href="../Decidable/#7558" class="Function">≤→≤ᵇ</a> <a id="7625" class="Symbol">(</a><a id="7626" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="7630" href="../Decidable/#7630" class="Bound">m≤n</a><a id="7633" class="Symbol">)</a>  <a id="7636" class="Symbol">=</a>  <a id="7639" href="../Decidable/#7558" class="Function">≤→≤ᵇ</a> <a id="7644" href="../Decidable/#7630" class="Bound">m≤n</a>
</pre>
<!--
If the evidence is `z≤n` then we immediately have that `zero ≤ᵇ n` is
true, so `T (m ≤ᵇ n)` is evidenced by `tt`. If the evidence is `s≤s`
applied to `m≤n`, then `suc m ≤ᵇ suc n` reduces to `m ≤ᵇ n`, and we
may recursively invoke the function to produce evidence that `T (m ≤ᵇ n)`.
-->
<p>如果证明是 <code>z≤n</code>，我们立即可以得到 <code>zero ≤ᵇ n</code> 为真，所以 <code>T (m ≤ᵇ n)</code> 由 <code>tt</code> 证明。 如果证明是 <code>s≤s</code> 作用于 <code>m≤n</code>，那么 <code>suc m ≤ᵇ suc n</code> 规约到 <code>m ≤ᵇ n</code>，我们可以递归地使用函数 来获得 <code>T (m ≤ᵇ n)</code> 的证明。</p>
<!--
The forward proof has one more clause than the reverse proof,
precisely because in the forward proof we need clauses corresponding to
the comparison yielding both true and false, while in the reverse proof
we only need clauses corresponding to the case where there is evidence
that the comparison holds.  This is exactly why we tend to prefer the
evidence formulation to the computation formulation, because it allows
us to do less work: we consider only cases where the relation holds,
and can ignore those where it does not.
-->
<p>向前方向的证明比向后方向的证明多一条语句，因为在向前方向的证明中我们需要考虑比较结果为真和假 的语句，而向后方向的证明只需要考虑比较成立的语句。这也是为什么我们比起计算的形式，更加偏爱证明的形式， 因为这样让我们做更少的工作：我们只需要考虑关系成立时的情况，而可以忽略不成立的情况。</p>
<!--
On the other hand, sometimes the computation formulation may be just what
we want.  Given a non-obvious relation over large values, it might be
handy to have the computer work out the answer for us.  Fortunately,
rather than choosing between _evidence_ and _computation_,
there is a way to get the benefits of both.
-->
<p>从另一个角度来说，有时计算的性质可能正是我们所需要的。面对一个大数值上的非显然关系， 使用电脑来计算出答案可能会更加方便。幸运的是，比起在<strong>证明</strong>或<strong>计算</strong>之中犹豫， 我们有一种更好的方法来兼取其优。</p>
<!--
## The best of both worlds
-->
<h2 name="the-best-of-both-worlds" id="取二者之精华">取二者之精华</h2>
<!--
A function that returns a boolean returns exactly a single bit of information:
does the relation hold or does it not? Conversely, the evidence approach tells
us exactly why the relation holds, but we are responsible for generating the
evidence.  But it is easy to define a type that combines the benefits of
both approaches.  It is called `Dec A`, where `Dec` is short for _decidable_:
-->
<p>一个返回布尔值的函数提供恰好一比特的信息：这个关系成立或是不成立。相反地，证明的形式告诉我们 为什么这个关系成立，但却需要我们自行完成这个证明。不过，我们其实可以简单地定义一个类型来取二者之精华。 我们把它叫做：<code>Dec A</code>，其中 <code>Dec</code> 是<strong>可判定的（Decidable）</strong>的意思。</p>
<pre class="Agda"><a id="9838" class="Keyword">data</a> <a id="Dec"></a><a id="9843" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="9847" class="Symbol">(</a><a id="9848" href="../Decidable/#9848" class="Bound">A</a> <a id="9850" class="Symbol">:</a> <a id="9852" class="PrimitiveType">Set</a><a id="9855" class="Symbol">)</a> <a id="9857" class="Symbol">:</a> <a id="9859" class="PrimitiveType">Set</a> <a id="9863" class="Keyword">where</a>
  <a id="Dec.yes"></a><a id="9871" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="9875" class="Symbol">:</a>   <a id="9879" href="../Decidable/#9848" class="Bound">A</a> <a id="9881" class="Symbol">→</a> <a id="9883" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="9887" href="../Decidable/#9848" class="Bound">A</a>
  <a id="Dec.no"></a><a id="9891" href="../Decidable/#9891" class="InductiveConstructor">no</a>  <a id="9895" class="Symbol">:</a> <a id="9897" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="9899" href="../Decidable/#9848" class="Bound">A</a> <a id="9901" class="Symbol">→</a> <a id="9903" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="9907" href="../Decidable/#9848" class="Bound">A</a>
</pre>
<!--
Like booleans, the type has two constructors.  A value of type `Dec A`
is either of the form `yes x`, where `x` provides evidence that `A` holds,
or of the form `no ¬x`, where `¬x` provides evidence that `A` cannot hold
(that is, `¬x` is a function which given evidence of `A` yields a contradiction).
-->
<p>正如布尔值，这个类型有两个构造子。一个 <code>Dec A</code> 类型的值要么是以 <code>yes x</code> 的形式，其中 <code>x</code> 提供 <code>A</code> 成立的证明，或者是以 <code>no ¬x</code> 的形式，其中 <code>x</code> 提供了 <code>A</code> 无法成立的证明。（也就是说，<code>¬x</code> 是一个给定 <code>A</code> 成立的证据，返回矛盾的函数）</p>
<!--
For example, we define a function `_≤?_` which given two numbers decides whether one
is less than or equal to the other, and provides evidence to justify its conclusion.
-->
<p>比如说，我们定义一个函数 <code>_≤?_</code>，给定两个数，判定是否一个数小于等于另一个，并提供证明来说明结论。</p>
<!--
First, we introduce two functions useful for constructing evidence that
an inequality does not hold:
-->
<p>首先，我们使用两个有用的函数，用于构造不等式不成立的证明：</p>
<pre class="Agda"><a id="¬s≤z"></a><a id="10752" href="../Decidable/#10752" class="Function">¬s≤z</a> <a id="10757" class="Symbol">:</a> <a id="10759" class="Symbol">∀</a> <a id="10761" class="Symbol">{</a><a id="10762" href="../Decidable/#10762" class="Bound">m</a> <a id="10764" class="Symbol">:</a> <a id="10766" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="10767" class="Symbol">}</a> <a id="10769" class="Symbol">→</a> <a id="10771" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="10773" class="Symbol">(</a><a id="10774" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="10778" href="../Decidable/#10762" class="Bound">m</a> <a id="10780" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="10782" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="10786" class="Symbol">)</a>
<a id="10788" href="../Decidable/#10752" class="Function">¬s≤z</a> <a id="10793" class="Symbol">()</a>

<a id="¬s≤s"></a><a id="10797" href="../Decidable/#10797" class="Function">¬s≤s</a> <a id="10802" class="Symbol">:</a> <a id="10804" class="Symbol">∀</a> <a id="10806" class="Symbol">{</a><a id="10807" href="../Decidable/#10807" class="Bound">m</a> <a id="10809" href="../Decidable/#10809" class="Bound">n</a> <a id="10811" class="Symbol">:</a> <a id="10813" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="10814" class="Symbol">}</a> <a id="10816" class="Symbol">→</a> <a id="10818" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="10820" class="Symbol">(</a><a id="10821" href="../Decidable/#10807" class="Bound">m</a> <a id="10823" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="10825" href="../Decidable/#10809" class="Bound">n</a><a id="10826" class="Symbol">)</a> <a id="10828" class="Symbol">→</a> <a id="10830" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="10832" class="Symbol">(</a><a id="10833" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="10837" href="../Decidable/#10807" class="Bound">m</a> <a id="10839" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="10841" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="10845" href="../Decidable/#10809" class="Bound">n</a><a id="10846" class="Symbol">)</a>
<a id="10848" href="../Decidable/#10797" class="Function">¬s≤s</a> <a id="10853" href="../Decidable/#10853" class="Bound">¬m≤n</a> <a id="10858" class="Symbol">(</a><a id="10859" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="10863" href="../Decidable/#10863" class="Bound">m≤n</a><a id="10866" class="Symbol">)</a> <a id="10868" class="Symbol">=</a> <a id="10870" href="../Decidable/#10853" class="Bound">¬m≤n</a> <a id="10875" href="../Decidable/#10863" class="Bound">m≤n</a>
</pre>
<!--
The first of these asserts that `¬ (suc m ≤ zero)`, and follows by
absurdity, since any evidence of inequality has the form `zero ≤ n`
or `suc m ≤ suc n`, neither of which match `suc m ≤ zero`. The second
of these takes evidence `¬m≤n` of `¬ (m ≤ n)` and returns a proof of
`¬ (suc m ≤ suc n)`.  Any evidence of `suc m ≤ suc n` must have the
form `s≤s m≤n` where `m≤n` is evidence that `m ≤ n`.  Hence, we have
a contradiction, evidenced by `¬m≤n m≤n`.
-->
<p>第一个函数断言了 <code>¬ (suc m ≤ zero)</code>，由荒谬可得。因为每个不等式的成立证明必须是 <code>zero ≤ n</code> 或者 <code>suc m ≤ suc n</code> 的形式，两者都无法匹配 <code>suc m ≤ zero</code>。 第二个函数取 <code>¬ (m ≤ n)</code> 的证明 <code>¬m≤n</code>，返回 <code>¬ (suc m ≤ suc n)</code> 的证明。 所有形如 <code>suc m ≤ suc n</code> 的证明必须是以 <code>s≤s m≤n</code> 的形式给出。因此我们可以构造一个 矛盾，以 <code>¬m≤n m≤n</code> 来证明。</p>
<!--
Using these, it is straightforward to decide an inequality:
-->
<p>使用这些，我们可以直接的判定不等关系：</p>
<pre class="Agda"><a id="_≤?_"></a><a id="11686" href="../Decidable/#11686" class="Function Operator">_≤?_</a> <a id="11691" class="Symbol">:</a> <a id="11693" class="Symbol">∀</a> <a id="11695" class="Symbol">(</a><a id="11696" href="../Decidable/#11696" class="Bound">m</a> <a id="11698" href="../Decidable/#11698" class="Bound">n</a> <a id="11700" class="Symbol">:</a> <a id="11702" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="11703" class="Symbol">)</a> <a id="11705" class="Symbol">→</a> <a id="11707" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="11711" class="Symbol">(</a><a id="11712" href="../Decidable/#11696" class="Bound">m</a> <a id="11714" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="11716" href="../Decidable/#11698" class="Bound">n</a><a id="11717" class="Symbol">)</a>
<a id="11719" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="11725" href="../Decidable/#11686" class="Function Operator">≤?</a> <a id="11728" href="../Decidable/#11728" class="Bound">n</a>                   <a id="11748" class="Symbol">=</a>  <a id="11751" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="11755" href="../Decidable/#1744" class="InductiveConstructor">z≤n</a>
<a id="11759" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="11763" href="../Decidable/#11763" class="Bound">m</a> <a id="11765" href="../Decidable/#11686" class="Function Operator">≤?</a> <a id="11768" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>                <a id="11788" class="Symbol">=</a>  <a id="11791" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="11794" href="../Decidable/#10752" class="Function">¬s≤z</a>
<a id="11799" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="11803" href="../Decidable/#11803" class="Bound">m</a> <a id="11805" href="../Decidable/#11686" class="Function Operator">≤?</a> <a id="11808" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="11812" href="../Decidable/#11812" class="Bound">n</a> <a id="11814" class="Keyword">with</a> <a id="11819" href="../Decidable/#11803" class="Bound">m</a> <a id="11821" href="../Decidable/#11686" class="Function Operator">≤?</a> <a id="11824" href="../Decidable/#11812" class="Bound">n</a>
<a id="11826" class="Symbol">...</a>               <a id="11844" class="Symbol">|</a> <a id="11846" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="11850" href="../Decidable/#11850" class="Bound">m≤n</a>  <a id="11855" class="Symbol">=</a>  <a id="11858" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="11862" class="Symbol">(</a><a id="11863" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="11867" href="../Decidable/#11850" class="Bound">m≤n</a><a id="11870" class="Symbol">)</a>
<a id="11872" class="Symbol">...</a>               <a id="11890" class="Symbol">|</a> <a id="11892" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="11895" href="../Decidable/#11895" class="Bound">¬m≤n</a>  <a id="11901" class="Symbol">=</a>  <a id="11904" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="11907" class="Symbol">(</a><a id="11908" href="../Decidable/#10797" class="Function">¬s≤s</a> <a id="11913" href="../Decidable/#11895" class="Bound">¬m≤n</a><a id="11917" class="Symbol">)</a>
</pre>
<!--
As with `_≤ᵇ_`, the definition has three clauses.  In the first
clause, it is immediate that `zero ≤ n` holds, and it is evidenced by
`z≤n`.  In the second clause, it is immediate that `suc m ≤ zero` does
not hold, and it is evidenced by `¬s≤z`.
In the third clause, to decide whether `suc m ≤ suc n` holds we
recursively invoke `m ≤? n`.  There are two possibilities.  In the
`yes` case it returns evidence `m≤n` that `m ≤ n`, and `s≤s m≤n`
provides evidence that `suc m ≤ suc n`.  In the `no` case it returns
evidence `¬m≤n` that `¬ (m ≤ n)`, and `¬s≤s ¬m≤n` provides evidence
that `¬ (suc m ≤ suc n)`.
-->
<p>与 <code>_≤ᵇ_</code> 一样，定义有三条语句。第一条语句中，<code>zero ≤ n</code> 立即成立，由 <code>z≤n</code> 证明。 第二条语句中，<code>suc m ≤ zero</code> 立即不成立，由 <code>¬s≤z</code> 证明。 第三条语句中，我们需要递归地应用 <code>m ≤? n</code>。有两种可能性，在 <code>yes</code> 的情况中，它会返回 <code>m ≤ n</code> 的证明 <code>m≤n</code>，所以 <code>s≤s m≤n</code> 即可作为 <code>suc m ≤ suc n</code> 的证明；在 <code>no</code> 的情况中， 它会返回 <code>¬ (m ≤ n)</code> 的证明 <code>¬m≤n</code>，所以 <code>¬s≤s ¬m≤n</code> 即可作为 <code>¬ (suc m ≤ suc n)</code> 的证明。</p>
<!--
When we wrote `_≤ᵇ_`, we had to write two other functions, `≤ᵇ→≤` and `≤→≤ᵇ`,
in order to show that it was correct.  In contrast, the definition of `_≤?_`
proves itself correct, as attested to by its type.  The code of `_≤?_`
is far more compact than the combined code of `_≤ᵇ_`, `≤ᵇ→≤`, and `≤→≤ᵇ`.
As we will later show, if you really want the latter three, it is easy
to derive them from `_≤?_`.
-->
<p>当我们写 <code>_≤ᵇ_</code> 时，我们必须写两个其他的函数 <code>≤ᵇ→≤</code> 和 <code>≤→≤ᵇ</code> 来证明其正确性。 作为对比，<code>_≤?_</code> 的定义自身就证明了其正确性，由类型即可得知。<code>_≤?_</code> 的代码也比 <code>_≤ᵇ_</code>、<code>≤ᵇ→≤</code> 和 <code>≤→≤ᵇ</code> 加起来要简洁的多。我们稍后将会证明，如果我们需要后三者， 我们亦可简单地从 <code>_≤?_</code> 中派生出来。</p>
<!--
We can use our new function to _compute_ the _evidence_ that earlier we had to
think up on our own:
-->
<p>我们可以使用我们新的函数来<strong>计算</strong>出我们之前需要自己想出来的<strong>证明</strong>。</p>
<pre class="Agda"><a id="13568" href="../Decidable/#13568" class="Function">_</a> <a id="13570" class="Symbol">:</a> <a id="13572" class="Number">2</a> <a id="13574" href="../Decidable/#11686" class="Function Operator">≤?</a> <a id="13577" class="Number">4</a> <a id="13579" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="13581" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="13585" class="Symbol">(</a><a id="13586" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="13590" class="Symbol">(</a><a id="13591" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="13595" href="../Decidable/#1744" class="InductiveConstructor">z≤n</a><a id="13598" class="Symbol">))</a>
<a id="13601" class="Symbol">_</a> <a id="13603" class="Symbol">=</a> <a id="13605" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="13611" href="../Decidable/#13611" class="Function">_</a> <a id="13613" class="Symbol">:</a> <a id="13615" class="Number">4</a> <a id="13617" href="../Decidable/#11686" class="Function Operator">≤?</a> <a id="13620" class="Number">2</a> <a id="13622" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="13624" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="13627" class="Symbol">(</a><a id="13628" href="../Decidable/#10797" class="Function">¬s≤s</a> <a id="13633" class="Symbol">(</a><a id="13634" href="../Decidable/#10797" class="Function">¬s≤s</a> <a id="13639" href="../Decidable/#10752" class="Function">¬s≤z</a><a id="13643" class="Symbol">))</a>
<a id="13646" class="Symbol">_</a> <a id="13648" class="Symbol">=</a> <a id="13650" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<!--
You can check that Agda will indeed compute these values.  Typing
`C-c C-n` and providing `2 ≤? 4` or `4 ≤? 2` as the requested expression
causes Agda to print the values given above.
-->
<p>你可以验证 Agda 的确计算出了这些值。输入 <code>C-c C-n</code> 并给出 <code>2 ≤? 4</code> 或者 <code>4 ≤? 2</code> 作为 需要的表达式，Agda 会输出如上的值。</p>
<!--
(A subtlety: if we do not define `¬s≤z` and `¬s≤s` as top-level functions,
but instead use inline anonymous functions then Agda may have
trouble normalising evidence of negation.)
-->
<p>（小细节：如果我们不把 <code>¬s≤z</code> 和 <code>¬s≤s</code> 作为顶层函数来定义，而是使用内嵌的匿名函数， Agda 可能会在规范化否定的证明中出现问题。）</p>
<!--
#### Exercise `_<?_` (recommended)
-->
<h4 id="练习-__-推荐">练习 <code>_&lt;?_</code> （推荐）</h4>
<!--
Analogous to the function above, define a function to decide strict inequality:
-->
<p>与上面的函数相似，定义一个判定严格不等性的函数：</p>
<pre class="Agda"><a id="14392" class="Keyword">postulate</a>
  <a id="_&lt;?_"></a><a id="14404" href="../Decidable/#14404" class="Postulate Operator">_&lt;?_</a> <a id="14409" class="Symbol">:</a> <a id="14411" class="Symbol">∀</a> <a id="14413" class="Symbol">(</a><a id="14414" href="../Decidable/#14414" class="Bound">m</a> <a id="14416" href="../Decidable/#14416" class="Bound">n</a> <a id="14418" class="Symbol">:</a> <a id="14420" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="14421" class="Symbol">)</a> <a id="14423" class="Symbol">→</a> <a id="14425" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="14429" class="Symbol">(</a><a id="14430" href="../Decidable/#14414" class="Bound">m</a> <a id="14432" href="../Relations/#26518" class="Datatype Operator">&lt;</a> <a id="14434" href="../Decidable/#14416" class="Bound">n</a><a id="14435" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="14451" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="14487" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
#### Exercise `_≡ℕ?_` (practice)
-->
<h4 id="练习-_ℕ_实践">练习 <code>_≡ℕ?_</code>（实践）</h4>
<!--
Define a function to decide whether two naturals are equal:
-->
<p>定义一个函数来判定两个自然数是否相等。</p>
<pre class="Agda"><a id="14664" class="Keyword">postulate</a>
  <a id="_≡ℕ?_"></a><a id="14676" href="../Decidable/#14676" class="Postulate Operator">_≡ℕ?_</a> <a id="14682" class="Symbol">:</a> <a id="14684" class="Symbol">∀</a> <a id="14686" class="Symbol">(</a><a id="14687" href="../Decidable/#14687" class="Bound">m</a> <a id="14689" href="../Decidable/#14689" class="Bound">n</a> <a id="14691" class="Symbol">:</a> <a id="14693" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="14694" class="Symbol">)</a> <a id="14696" class="Symbol">→</a> <a id="14698" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="14702" class="Symbol">(</a><a id="14703" href="../Decidable/#14687" class="Bound">m</a> <a id="14705" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="14707" href="../Decidable/#14689" class="Bound">n</a><a id="14708" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="14724" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="14760" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
## Decidables from booleans, and booleans from decidables
-->
<h2 name="decidables-from-booleans-and-booleans-from-decidables" id="从可判定的值到布尔值从布尔值到可判定的值">从可判定的值到布尔值，从布尔值到可判定的值</h2>
<!--
Curious readers might wonder if we could reuse the definition of
`m ≤ᵇ n`, together with the proofs that it is equivalent to `m ≤ n`, to show
decidability.  Indeed, we can do so as follows:
-->
<p>好奇的读者可能会思考能不能重用 <code>m ≤ᵇ n</code> 的定义，加上它与 <code>m ≤ n</code> 等价的证明， 来证明可判定性。的确，我们是可以做到的：</p>
<pre class="Agda"><a id="_≤?′_"></a><a id="15209" href="../Decidable/#15209" class="Function Operator">_≤?′_</a> <a id="15215" class="Symbol">:</a> <a id="15217" class="Symbol">∀</a> <a id="15219" class="Symbol">(</a><a id="15220" href="../Decidable/#15220" class="Bound">m</a> <a id="15222" href="../Decidable/#15222" class="Bound">n</a> <a id="15224" class="Symbol">:</a> <a id="15226" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="15227" class="Symbol">)</a> <a id="15229" class="Symbol">→</a> <a id="15231" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="15235" class="Symbol">(</a><a id="15236" href="../Decidable/#15220" class="Bound">m</a> <a id="15238" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="15240" href="../Decidable/#15222" class="Bound">n</a><a id="15241" class="Symbol">)</a>
<a id="15243" href="../Decidable/#15243" class="Bound">m</a> <a id="15245" href="../Decidable/#15209" class="Function Operator">≤?′</a> <a id="15249" href="../Decidable/#15249" class="Bound">n</a> <a id="15251" class="Keyword">with</a> <a id="15256" href="../Decidable/#15243" class="Bound">m</a> <a id="15258" href="../Decidable/#2819" class="Function Operator">≤ᵇ</a> <a id="15261" href="../Decidable/#15249" class="Bound">n</a> <a id="15263" class="Symbol">|</a> <a id="15265" href="../Decidable/#6234" class="Function">≤ᵇ→≤</a> <a id="15270" href="../Decidable/#15243" class="Bound">m</a> <a id="15272" href="../Decidable/#15249" class="Bound">n</a> <a id="15274" class="Symbol">|</a> <a id="15276" href="../Decidable/#7558" class="Function">≤→≤ᵇ</a> <a id="15281" class="Symbol">{</a><a id="15282" href="../Decidable/#15243" class="Bound">m</a><a id="15283" class="Symbol">}</a> <a id="15285" class="Symbol">{</a><a id="15286" href="../Decidable/#15249" class="Bound">n</a><a id="15287" class="Symbol">}</a>
<a id="15289" class="Symbol">...</a>        <a id="15300" class="Symbol">|</a> <a id="15302" href="../Decidable/#2563" class="InductiveConstructor">true</a>   <a id="15309" class="Symbol">|</a> <a id="15311" href="../Decidable/#15311" class="Bound">p</a>        <a id="15320" class="Symbol">|</a> <a id="15322" class="Symbol">_</a>            <a id="15335" class="Symbol">=</a> <a id="15337" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="15341" class="Symbol">(</a><a id="15342" href="../Decidable/#15311" class="Bound">p</a> <a id="15344" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="15346" class="Symbol">)</a>
<a id="15348" class="Symbol">...</a>        <a id="15359" class="Symbol">|</a> <a id="15361" href="../Decidable/#2578" class="InductiveConstructor">false</a>  <a id="15368" class="Symbol">|</a> <a id="15370" class="Symbol">_</a>        <a id="15379" class="Symbol">|</a> <a id="15381" href="../Decidable/#15381" class="Bound">¬p</a>           <a id="15394" class="Symbol">=</a> <a id="15396" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="15399" href="../Decidable/#15381" class="Bound">¬p</a>
</pre>
<!--
If `m ≤ᵇ n` is true then `≤ᵇ→≤` yields a proof that `m ≤ n` holds,
while if it is false then `≤→≤ᵇ` takes a proof that `m ≤ n` holds into a contradiction.
-->
<p>如果 <code>m ≤ᵇ n</code> 为真，那么 <code>≤ᵇ→≤</code> 会返回一个 <code>m ≤ n</code> 成立的证明。 如果 <code>m ≤ᵇ n</code> 为假，那么 <code>≤→≤ᵇ</code> 会取一个 <code>m ≤ n</code> 成立的证明，将其转换为一个矛盾。</p>
<!--
The triple binding of the `with` clause in this proof is essential.
If instead we wrote:
-->
<p>在这个证明中，<code>with</code> 语句的三重约束是必须的。如果我们取而代之的写：</p>
<pre><code>_≤?″_ : ∀ (m n : ℕ) → Dec (m ≤ n)
m ≤?″ n with m ≤ᵇ n
... | true   =  yes (≤ᵇ→≤ m n tt)
... | false  =  no (≤→≤ᵇ {m} {n})</code></pre>
<!--
then Agda would make two complaints, one for each clause:
-->
<p>那么 Agda 对于每条语句会有一个抱怨：</p>
<pre><code>⊤ !=&lt; (T (m ≤ᵇ n)) of type Set
when checking that the expression tt has type T (m ≤ᵇ n)

T (m ≤ᵇ n) !=&lt; ⊥ of type Set
when checking that the expression ≤→≤ᵇ {m} {n} has type ¬ m ≤ n</code></pre>
<!--
Putting the expressions into the `with` clause permits Agda to exploit
the fact that `T (m ≤ᵇ n)` is `⊤` when `m ≤ᵇ n` is true, and that
`T (m ≤ᵇ n)` is `⊥` when `m ≤ᵇ n` is false.
-->
<p>将表达式放在 <code>with</code> 语句中能让 Agda 利用下列事实：当 <code>m ≤ᵇ n</code> 为真时，<code>T (m ≤ᵇ n)</code> 是 <code>⊤</code>；当 <code>m ≤ᵇ n</code> 为假时，<code>T (m ≤ᵇ n)</code> 是 <code>⊥</code>。</p>
<!--
However, overall it is simpler to just define `_≤?_` directly, as in the previous
section.  If one really wants `_≤ᵇ_`, then it and its properties are easily derived
from `_≤?_`, as we will now show.
-->
<p>然而，总体来说还是直接定义 <code>_≤?_</code> 比较方便，正如之前部分中那样。如果有人真的很需要 <code>_≤ᵇ_</code>， 那么它和它的性质可以简单地从 <code>_≤?_</code> 中派生出来，正如我们接下来要展示的一样。</p>
<!--
Erasure takes a decidable value to a boolean:
-->
<p>擦除（Erasure）将一个可判定的值转换为一个布尔值：</p>
<pre class="Agda"><a id="⌊_⌋"></a><a id="16932" href="../Decidable/#16932" class="Function Operator">⌊_⌋</a> <a id="16936" class="Symbol">:</a> <a id="16938" class="Symbol">∀</a> <a id="16940" class="Symbol">{</a><a id="16941" href="../Decidable/#16941" class="Bound">A</a> <a id="16943" class="Symbol">:</a> <a id="16945" class="PrimitiveType">Set</a><a id="16948" class="Symbol">}</a> <a id="16950" class="Symbol">→</a> <a id="16952" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="16956" href="../Decidable/#16941" class="Bound">A</a> <a id="16958" class="Symbol">→</a> <a id="16960" href="../Decidable/#2544" class="Datatype">Bool</a>
<a id="16965" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="16967" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="16971" href="../Decidable/#16971" class="Bound">x</a> <a id="16973" href="../Decidable/#16932" class="Function Operator">⌋</a>  <a id="16976" class="Symbol">=</a>  <a id="16979" href="../Decidable/#2563" class="InductiveConstructor">true</a>
<a id="16984" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="16986" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="16989" href="../Decidable/#16989" class="Bound">¬x</a> <a id="16992" href="../Decidable/#16932" class="Function Operator">⌋</a>  <a id="16995" class="Symbol">=</a>  <a id="16998" href="../Decidable/#2578" class="InductiveConstructor">false</a>
</pre>
<!--
Using erasure, we can easily derive `_≤ᵇ_` from `_≤?_`:
-->
<p>使用擦除，我们可以简单地从 <code>_≤?_</code> 中派生出 <code>_≤ᵇ_</code>：</p>
<pre class="Agda"><a id="_≤ᵇ′_"></a><a id="17114" href="../Decidable/#17114" class="Function Operator">_≤ᵇ′_</a> <a id="17120" class="Symbol">:</a> <a id="17122" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="17124" class="Symbol">→</a> <a id="17126" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="17128" class="Symbol">→</a> <a id="17130" href="../Decidable/#2544" class="Datatype">Bool</a>
<a id="17135" href="../Decidable/#17135" class="Bound">m</a> <a id="17137" href="../Decidable/#17114" class="Function Operator">≤ᵇ′</a> <a id="17141" href="../Decidable/#17141" class="Bound">n</a>  <a id="17144" class="Symbol">=</a>  <a id="17147" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="17149" href="../Decidable/#17135" class="Bound">m</a> <a id="17151" href="../Decidable/#11686" class="Function Operator">≤?</a> <a id="17154" href="../Decidable/#17141" class="Bound">n</a> <a id="17156" href="../Decidable/#16932" class="Function Operator">⌋</a>
</pre>
<!--
Further, if `D` is a value of type `Dec A`, then `T ⌊ D ⌋` is
inhabited exactly when `A` is inhabited:
-->
更进一步来说，如果 <code>D</code> 是一个类型为 <code>Dec A</code> 的值，那么 <code>T ⌊ D ⌋</code> 当且仅当 <code>A</code> 成立时成立：
<pre class="Agda"><a id="toWitness"></a><a id="17341" href="../Decidable/#17341" class="Function">toWitness</a> <a id="17351" class="Symbol">:</a> <a id="17353" class="Symbol">∀</a> <a id="17355" class="Symbol">{</a><a id="17356" href="../Decidable/#17356" class="Bound">A</a> <a id="17358" class="Symbol">:</a> <a id="17360" class="PrimitiveType">Set</a><a id="17363" class="Symbol">}</a> <a id="17365" class="Symbol">{</a><a id="17366" href="../Decidable/#17366" class="Bound">D</a> <a id="17368" class="Symbol">:</a> <a id="17370" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="17374" href="../Decidable/#17356" class="Bound">A</a><a id="17375" class="Symbol">}</a> <a id="17377" class="Symbol">→</a> <a id="17379" href="../Decidable/#4506" class="Function">T</a> <a id="17381" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="17383" href="../Decidable/#17366" class="Bound">D</a> <a id="17385" href="../Decidable/#16932" class="Function Operator">⌋</a> <a id="17387" class="Symbol">→</a> <a id="17389" href="../Decidable/#17356" class="Bound">A</a>
<a id="17391" href="../Decidable/#17341" class="Function">toWitness</a> <a id="17401" class="Symbol">{</a><a id="17402" href="../Decidable/#17402" class="Bound">A</a><a id="17403" class="Symbol">}</a> <a id="17405" class="Symbol">{</a><a id="17406" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="17410" href="../Decidable/#17410" class="Bound">x</a><a id="17411" class="Symbol">}</a> <a id="17413" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>  <a id="17417" class="Symbol">=</a>  <a id="17420" href="../Decidable/#17410" class="Bound">x</a>
<a id="17422" href="../Decidable/#17341" class="Function">toWitness</a> <a id="17432" class="Symbol">{</a><a id="17433" href="../Decidable/#17433" class="Bound">A</a><a id="17434" class="Symbol">}</a> <a id="17436" class="Symbol">{</a><a id="17437" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="17440" href="../Decidable/#17440" class="Bound">¬x</a><a id="17442" class="Symbol">}</a> <a id="17444" class="Symbol">()</a>

<a id="fromWitness"></a><a id="17448" href="../Decidable/#17448" class="Function">fromWitness</a> <a id="17460" class="Symbol">:</a> <a id="17462" class="Symbol">∀</a> <a id="17464" class="Symbol">{</a><a id="17465" href="../Decidable/#17465" class="Bound">A</a> <a id="17467" class="Symbol">:</a> <a id="17469" class="PrimitiveType">Set</a><a id="17472" class="Symbol">}</a> <a id="17474" class="Symbol">{</a><a id="17475" href="../Decidable/#17475" class="Bound">D</a> <a id="17477" class="Symbol">:</a> <a id="17479" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="17483" href="../Decidable/#17465" class="Bound">A</a><a id="17484" class="Symbol">}</a> <a id="17486" class="Symbol">→</a> <a id="17488" href="../Decidable/#17465" class="Bound">A</a> <a id="17490" class="Symbol">→</a> <a id="17492" href="../Decidable/#4506" class="Function">T</a> <a id="17494" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="17496" href="../Decidable/#17475" class="Bound">D</a> <a id="17498" href="../Decidable/#16932" class="Function Operator">⌋</a>
<a id="17500" href="../Decidable/#17448" class="Function">fromWitness</a> <a id="17512" class="Symbol">{</a><a id="17513" href="../Decidable/#17513" class="Bound">A</a><a id="17514" class="Symbol">}</a> <a id="17516" class="Symbol">{</a><a id="17517" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="17521" href="../Decidable/#17521" class="Bound">x</a><a id="17522" class="Symbol">}</a> <a id="17524" class="Symbol">_</a>  <a id="17527" class="Symbol">=</a>  <a id="17530" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
<a id="17533" href="../Decidable/#17448" class="Function">fromWitness</a> <a id="17545" class="Symbol">{</a><a id="17546" href="../Decidable/#17546" class="Bound">A</a><a id="17547" class="Symbol">}</a> <a id="17549" class="Symbol">{</a><a id="17550" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="17553" href="../Decidable/#17553" class="Bound">¬x</a><a id="17555" class="Symbol">}</a> <a id="17557" href="../Decidable/#17557" class="Bound">x</a>  <a id="17560" class="Symbol">=</a>  <a id="17563" href="../Decidable/#17553" class="Bound">¬x</a> <a id="17566" href="../Decidable/#17557" class="Bound">x</a>
</pre>
<!--
Using these, we can easily derive that `T (m ≤ᵇ′ n)` is inhabited
exactly when `m ≤ n` is inhabited:
-->
<p>使用这些，我们可以简单地派生出 <code>T (m ≤ᵇ′ n)</code> 当且仅当 <code>m ≤ n</code> 成立时成立。</p>
<pre class="Agda"><a id="≤ᵇ′→≤"></a><a id="17739" href="../Decidable/#17739" class="Function">≤ᵇ′→≤</a> <a id="17745" class="Symbol">:</a> <a id="17747" class="Symbol">∀</a> <a id="17749" class="Symbol">{</a><a id="17750" href="../Decidable/#17750" class="Bound">m</a> <a id="17752" href="../Decidable/#17752" class="Bound">n</a> <a id="17754" class="Symbol">:</a> <a id="17756" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="17757" class="Symbol">}</a> <a id="17759" class="Symbol">→</a> <a id="17761" href="../Decidable/#4506" class="Function">T</a> <a id="17763" class="Symbol">(</a><a id="17764" href="../Decidable/#17750" class="Bound">m</a> <a id="17766" href="../Decidable/#17114" class="Function Operator">≤ᵇ′</a> <a id="17770" href="../Decidable/#17752" class="Bound">n</a><a id="17771" class="Symbol">)</a> <a id="17773" class="Symbol">→</a> <a id="17775" href="../Decidable/#17750" class="Bound">m</a> <a id="17777" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="17779" href="../Decidable/#17752" class="Bound">n</a>
<a id="17781" href="../Decidable/#17739" class="Function">≤ᵇ′→≤</a>  <a id="17788" class="Symbol">=</a>  <a id="17791" href="../Decidable/#17341" class="Function">toWitness</a>

<a id="≤→≤ᵇ′"></a><a id="17802" href="../Decidable/#17802" class="Function">≤→≤ᵇ′</a> <a id="17808" class="Symbol">:</a> <a id="17810" class="Symbol">∀</a> <a id="17812" class="Symbol">{</a><a id="17813" href="../Decidable/#17813" class="Bound">m</a> <a id="17815" href="../Decidable/#17815" class="Bound">n</a> <a id="17817" class="Symbol">:</a> <a id="17819" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="17820" class="Symbol">}</a> <a id="17822" class="Symbol">→</a> <a id="17824" href="../Decidable/#17813" class="Bound">m</a> <a id="17826" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="17828" href="../Decidable/#17815" class="Bound">n</a> <a id="17830" class="Symbol">→</a> <a id="17832" href="../Decidable/#4506" class="Function">T</a> <a id="17834" class="Symbol">(</a><a id="17835" href="../Decidable/#17813" class="Bound">m</a> <a id="17837" href="../Decidable/#17114" class="Function Operator">≤ᵇ′</a> <a id="17841" href="../Decidable/#17815" class="Bound">n</a><a id="17842" class="Symbol">)</a>
<a id="17844" href="../Decidable/#17802" class="Function">≤→≤ᵇ′</a>  <a id="17851" class="Symbol">=</a>  <a id="17854" href="../Decidable/#17448" class="Function">fromWitness</a>
</pre>
<!--
In summary, it is usually best to eschew booleans and rely on decidables.
If you need booleans, they and their properties are easily derived from the
corresponding decidables.
-->
<p>总结来说，最好避免直接使用布尔值，而使用可判定的值。如果有需要布尔值的时候，它们和它们的性质 可以简单地从对应的可判定的值中派生而来。</p>
<!--
## Logical connectives
-->
<!--
Most readers will be familiar with the logical connectives for booleans.
Each of these extends to decidables.
-->
<p>大多数读者对于布尔值的逻辑运算符很熟悉了。每个逻辑运算符都可以被延伸至可判定的值。</p>
<!--
The conjunction of two booleans is true if both are true,
and false if either is false:
-->
<p>两个布尔值的合取当两者都为真时为真，当任一为假时为假：</p>
<pre class="Agda"><a id="18454" class="Keyword">infixr</a> <a id="18461" class="Number">6</a> <a id="18463" href="../Decidable/#18468" class="Function Operator">_∧_</a>

<a id="_∧_"></a><a id="18468" href="../Decidable/#18468" class="Function Operator">_∧_</a> <a id="18472" class="Symbol">:</a> <a id="18474" href="../Decidable/#2544" class="Datatype">Bool</a> <a id="18479" class="Symbol">→</a> <a id="18481" href="../Decidable/#2544" class="Datatype">Bool</a> <a id="18486" class="Symbol">→</a> <a id="18488" href="../Decidable/#2544" class="Datatype">Bool</a>
<a id="18493" href="../Decidable/#2563" class="InductiveConstructor">true</a>  <a id="18499" href="../Decidable/#18468" class="Function Operator">∧</a> <a id="18501" href="../Decidable/#2563" class="InductiveConstructor">true</a>  <a id="18507" class="Symbol">=</a> <a id="18509" href="../Decidable/#2563" class="InductiveConstructor">true</a>
<a id="18514" href="../Decidable/#2578" class="InductiveConstructor">false</a> <a id="18520" href="../Decidable/#18468" class="Function Operator">∧</a> <a id="18522" class="Symbol">_</a>     <a id="18528" class="Symbol">=</a> <a id="18530" href="../Decidable/#2578" class="InductiveConstructor">false</a>
<a id="18536" class="CatchallClause Symbol">_</a><a id="18537" class="CatchallClause">     </a><a id="18542" href="../Decidable/#18468" class="CatchallClause Function Operator">∧</a><a id="18543" class="CatchallClause"> </a><a id="18544" href="../Decidable/#2578" class="CatchallClause InductiveConstructor">false</a> <a id="18550" class="Symbol">=</a> <a id="18552" href="../Decidable/#2578" class="InductiveConstructor">false</a>
</pre>
<!--
In Emacs, the left-hand side of the third equation displays in grey,
indicating that the order of the equations determines which of the
second or the third can match.  However, regardless of which matches
the answer is the same.
-->
<p>在 Emacs 中，第三个等式的左手边显示为灰色，表示这些等式出现的顺序决定了是第二条还是第三条 会被匹配到。然而，不管是哪一条被匹配到，结果都是一样的。</p>
<!--
Correspondingly, given two decidable propositions, we can
decide their conjunction:
-->
<p>相应地，给定两个可判定的命题，我们可以判定它们的合取：</p>
<pre class="Agda"><a id="19008" class="Keyword">infixr</a> <a id="19015" class="Number">6</a> <a id="19017" href="../Decidable/#19026" class="Function Operator">_×-dec_</a>

<a id="_×-dec_"></a><a id="19026" href="../Decidable/#19026" class="Function Operator">_×-dec_</a> <a id="19034" class="Symbol">:</a> <a id="19036" class="Symbol">∀</a> <a id="19038" class="Symbol">{</a><a id="19039" href="../Decidable/#19039" class="Bound">A</a> <a id="19041" href="../Decidable/#19041" class="Bound">B</a> <a id="19043" class="Symbol">:</a> <a id="19045" class="PrimitiveType">Set</a><a id="19048" class="Symbol">}</a> <a id="19050" class="Symbol">→</a> <a id="19052" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="19056" href="../Decidable/#19039" class="Bound">A</a> <a id="19058" class="Symbol">→</a> <a id="19060" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="19064" href="../Decidable/#19041" class="Bound">B</a> <a id="19066" class="Symbol">→</a> <a id="19068" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="19072" class="Symbol">(</a><a id="19073" href="../Decidable/#19039" class="Bound">A</a> <a id="19075" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="19077" href="../Decidable/#19041" class="Bound">B</a><a id="19078" class="Symbol">)</a>
<a id="19080" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="19084" href="../Decidable/#19084" class="Bound">x</a> <a id="19086" href="../Decidable/#19026" class="Function Operator">×-dec</a> <a id="19092" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="19096" href="../Decidable/#19096" class="Bound">y</a> <a id="19098" class="Symbol">=</a> <a id="19100" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="19104" href="../Decidable/#1035" class="InductiveConstructor Operator">⟨</a> <a id="19106" href="../Decidable/#19084" class="Bound">x</a> <a id="19108" href="../Decidable/#1035" class="InductiveConstructor Operator">,</a> <a id="19110" href="../Decidable/#19096" class="Bound">y</a> <a id="19112" href="../Decidable/#1035" class="InductiveConstructor Operator">⟩</a>
<a id="19114" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="19117" href="../Decidable/#19117" class="Bound">¬x</a> <a id="19120" href="../Decidable/#19026" class="Function Operator">×-dec</a> <a id="19126" class="Symbol">_</a>     <a id="19132" class="Symbol">=</a> <a id="19134" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="19137" class="Symbol">λ{</a> <a id="19140" href="../Decidable/#1035" class="InductiveConstructor Operator">⟨</a> <a id="19142" href="../Decidable/#19142" class="Bound">x</a> <a id="19144" href="../Decidable/#1035" class="InductiveConstructor Operator">,</a> <a id="19146" href="../Decidable/#19146" class="Bound">y</a> <a id="19148" href="../Decidable/#1035" class="InductiveConstructor Operator">⟩</a> <a id="19150" class="Symbol">→</a> <a id="19152" href="../Decidable/#19117" class="Bound">¬x</a> <a id="19155" href="../Decidable/#19142" class="Bound">x</a> <a id="19157" class="Symbol">}</a>
<a id="19159" class="CatchallClause Symbol">_</a><a id="19160" class="CatchallClause">     </a><a id="19165" href="../Decidable/#19026" class="CatchallClause Function Operator">×-dec</a><a id="19170" class="CatchallClause"> </a><a id="19171" href="../Decidable/#9891" class="CatchallClause InductiveConstructor">no</a><a id="19173" class="CatchallClause"> </a><a id="19174" href="../Decidable/#19174" class="CatchallClause Bound">¬y</a> <a id="19177" class="Symbol">=</a> <a id="19179" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="19182" class="Symbol">λ{</a> <a id="19185" href="../Decidable/#1035" class="InductiveConstructor Operator">⟨</a> <a id="19187" href="../Decidable/#19187" class="Bound">x</a> <a id="19189" href="../Decidable/#1035" class="InductiveConstructor Operator">,</a> <a id="19191" href="../Decidable/#19191" class="Bound">y</a> <a id="19193" href="../Decidable/#1035" class="InductiveConstructor Operator">⟩</a> <a id="19195" class="Symbol">→</a> <a id="19197" href="../Decidable/#19174" class="Bound">¬y</a> <a id="19200" href="../Decidable/#19191" class="Bound">y</a> <a id="19202" class="Symbol">}</a>
</pre>
<!--
The conjunction of two propositions holds if they both hold,
and its negation holds if the negation of either holds.
If both hold, then we pair the evidence for each to yield
evidence of the conjunct.  If the negation of either holds,
assuming the conjunct will lead to a contradiction.
-->
<p>两个命题的合取当两者都成立时成立，其否定则当任意一者否定成立时成立。如果两个都成立， 我们将每一证明放入数据对中，作为合取的证明。如果任意一者的否定成立，假设整个合取将会引入一个矛盾。</p>
<!--
Again in Emacs, the left-hand side of the third equation displays in grey,
indicating that the order of the equations determines which of the
second or the third can match.  This time the answer is different depending
on which matches; if both conjuncts fail to hold we pick the first to
yield the contradiction, but it would be equally valid to pick the second.
-->
<p>同样地，在 Emacs 中，第三条等式在左手边以灰色显示，说明等式的顺序决定了第二条还是第三条会被匹配。 这一次，我们给出的结果会因为是第二条还是第三条而不一样。如果两个命题都不成立，我们选择第一个来构造矛盾， 但选择第二个也是同样正确的。</p>
<!--
The disjunction of two booleans is true if either is true,
and false if both are false:
-->
<p>两个布尔值的析取当任意为真时为真，当两者为假时为假：</p>
<pre class="Agda"><a id="20225" class="Keyword">infixr</a> <a id="20232" class="Number">5</a> <a id="20234" href="../Decidable/#20239" class="Function Operator">_∨_</a>

<a id="_∨_"></a><a id="20239" href="../Decidable/#20239" class="Function Operator">_∨_</a> <a id="20243" class="Symbol">:</a> <a id="20245" href="../Decidable/#2544" class="Datatype">Bool</a> <a id="20250" class="Symbol">→</a> <a id="20252" href="../Decidable/#2544" class="Datatype">Bool</a> <a id="20257" class="Symbol">→</a> <a id="20259" href="../Decidable/#2544" class="Datatype">Bool</a>
<a id="20264" href="../Decidable/#2563" class="InductiveConstructor">true</a>  <a id="20270" href="../Decidable/#20239" class="Function Operator">∨</a> <a id="20272" class="Symbol">_</a>      <a id="20279" class="Symbol">=</a> <a id="20281" href="../Decidable/#2563" class="InductiveConstructor">true</a>
<a id="20286" class="CatchallClause Symbol">_</a><a id="20287" class="CatchallClause">     </a><a id="20292" href="../Decidable/#20239" class="CatchallClause Function Operator">∨</a><a id="20293" class="CatchallClause"> </a><a id="20294" href="../Decidable/#2563" class="CatchallClause InductiveConstructor">true</a>   <a id="20301" class="Symbol">=</a> <a id="20303" href="../Decidable/#2563" class="InductiveConstructor">true</a>
<a id="20308" href="../Decidable/#2578" class="InductiveConstructor">false</a> <a id="20314" href="../Decidable/#20239" class="Function Operator">∨</a> <a id="20316" href="../Decidable/#2578" class="InductiveConstructor">false</a>  <a id="20323" class="Symbol">=</a> <a id="20325" href="../Decidable/#2578" class="InductiveConstructor">false</a>
</pre>
<!--
In Emacs, the left-hand side of the second equation displays in grey,
indicating that the order of the equations determines which of the
first or the second can match.  However, regardless of which matches
the answer is the same.
-->
<p>在 Emacs 中，第二个等式的左手边显示为灰色，表示这些等式出现的顺序决定了是第一条还是第二条 会被匹配到。然而，不管是哪一条被匹配到，结果都是一样的。</p>
<!--
Correspondingly, given two decidable propositions, we can
decide their disjunction:
-->
<p>相应地，给定两个可判定的命题，我们可以判定它们的析取：</p>
<pre class="Agda"><a id="20782" class="Keyword">infixr</a> <a id="20789" class="Number">5</a> <a id="20791" href="../Decidable/#20800" class="Function Operator">_⊎-dec_</a>

<a id="_⊎-dec_"></a><a id="20800" href="../Decidable/#20800" class="Function Operator">_⊎-dec_</a> <a id="20808" class="Symbol">:</a> <a id="20810" class="Symbol">∀</a> <a id="20812" class="Symbol">{</a><a id="20813" href="../Decidable/#20813" class="Bound">A</a> <a id="20815" href="../Decidable/#20815" class="Bound">B</a> <a id="20817" class="Symbol">:</a> <a id="20819" class="PrimitiveType">Set</a><a id="20822" class="Symbol">}</a> <a id="20824" class="Symbol">→</a> <a id="20826" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="20830" href="../Decidable/#20813" class="Bound">A</a> <a id="20832" class="Symbol">→</a> <a id="20834" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="20838" href="../Decidable/#20815" class="Bound">B</a> <a id="20840" class="Symbol">→</a> <a id="20842" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="20846" class="Symbol">(</a><a id="20847" href="../Decidable/#20813" class="Bound">A</a> <a id="20849" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#728" class="Datatype Operator">⊎</a> <a id="20851" href="../Decidable/#20815" class="Bound">B</a><a id="20852" class="Symbol">)</a>
<a id="20854" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="20858" href="../Decidable/#20858" class="Bound">x</a> <a id="20860" href="../Decidable/#20800" class="Function Operator">⊎-dec</a> <a id="20866" class="Symbol">_</a>     <a id="20872" class="Symbol">=</a> <a id="20874" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="20878" class="Symbol">(</a><a id="20879" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#778" class="InductiveConstructor">inj₁</a> <a id="20884" href="../Decidable/#20858" class="Bound">x</a><a id="20885" class="Symbol">)</a>
<a id="20887" class="CatchallClause Symbol">_</a><a id="20888" class="CatchallClause">     </a><a id="20893" href="../Decidable/#20800" class="CatchallClause Function Operator">⊎-dec</a><a id="20898" class="CatchallClause"> </a><a id="20899" href="../Decidable/#9871" class="CatchallClause InductiveConstructor">yes</a><a id="20902" class="CatchallClause"> </a><a id="20903" href="../Decidable/#20903" class="CatchallClause Bound">y</a> <a id="20905" class="Symbol">=</a> <a id="20907" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="20911" class="Symbol">(</a><a id="20912" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#803" class="InductiveConstructor">inj₂</a> <a id="20917" href="../Decidable/#20903" class="Bound">y</a><a id="20918" class="Symbol">)</a>
<a id="20920" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="20923" href="../Decidable/#20923" class="Bound">¬x</a> <a id="20926" href="../Decidable/#20800" class="Function Operator">⊎-dec</a> <a id="20932" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="20935" href="../Decidable/#20935" class="Bound">¬y</a> <a id="20938" class="Symbol">=</a> <a id="20940" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="20943" class="Symbol">λ{</a> <a id="20946" class="Symbol">(</a><a id="20947" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#778" class="InductiveConstructor">inj₁</a> <a id="20952" href="../Decidable/#20952" class="Bound">x</a><a id="20953" class="Symbol">)</a> <a id="20955" class="Symbol">→</a> <a id="20957" href="../Decidable/#20923" class="Bound">¬x</a> <a id="20960" href="../Decidable/#20952" class="Bound">x</a> <a id="20962" class="Symbol">;</a> <a id="20964" class="Symbol">(</a><a id="20965" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#803" class="InductiveConstructor">inj₂</a> <a id="20970" href="../Decidable/#20970" class="Bound">y</a><a id="20971" class="Symbol">)</a> <a id="20973" class="Symbol">→</a> <a id="20975" href="../Decidable/#20935" class="Bound">¬y</a> <a id="20978" href="../Decidable/#20970" class="Bound">y</a> <a id="20980" class="Symbol">}</a>
</pre>
<!--
The disjunction of two propositions holds if either holds,
and its negation holds if the negation of both hold.
If either holds, we inject the evidence to yield
evidence of the disjunct.  If the negation of both hold,
assuming either disjunct will lead to a contradiction.
-->
<p>两个命题的析取当任意一者成立时成立，其否定则当两者的否定成立时成立。如果任意一者成立， 我们使用其证明来作为析取的证明。如果两个的否定都成立，假设任意一者都会引入一个矛盾。</p>
<!--
Again in Emacs, the left-hand side of the second equation displays in grey,
indicating that the order of the equations determines which of the
first or the second can match.  This time the answer is different depending
on which matches; if both disjuncts hold we pick the first,
but it would be equally valid to pick the second.
-->
<p>同样地，在 Emacs 中，第二条等式在左手边以灰色显示，说明等式的顺序决定了第一条还是第二条会被匹配。 这一次，我们给出的结果会因为是第二条还是第三条而不一样。如果两个命题都成立，我们选择第一个来构造析取， 但选择第二个也是同样正确的。</p>
<!--
The negation of a boolean is false if its argument is true,
and vice versa:
-->
<p>一个布尔值的否定当值为真时为假，反之亦然：</p>
<pre class="Agda"><a id="not"></a><a id="21931" href="../Decidable/#21931" class="Function">not</a> <a id="21935" class="Symbol">:</a> <a id="21937" href="../Decidable/#2544" class="Datatype">Bool</a> <a id="21942" class="Symbol">→</a> <a id="21944" href="../Decidable/#2544" class="Datatype">Bool</a>
<a id="21949" href="../Decidable/#21931" class="Function">not</a> <a id="21953" href="../Decidable/#2563" class="InductiveConstructor">true</a>  <a id="21959" class="Symbol">=</a> <a id="21961" href="../Decidable/#2578" class="InductiveConstructor">false</a>
<a id="21967" href="../Decidable/#21931" class="Function">not</a> <a id="21971" href="../Decidable/#2578" class="InductiveConstructor">false</a> <a id="21977" class="Symbol">=</a> <a id="21979" href="../Decidable/#2563" class="InductiveConstructor">true</a>
</pre>
<!--
Correspondingly, given a decidable proposition, we
can decide its negation:
-->
<p>相应地，给定一个可判定的命题，我们可以判定它的否定：</p>
<pre class="Agda"><a id="¬?"></a><a id="22107" href="../Decidable/#22107" class="Function">¬?</a> <a id="22110" class="Symbol">:</a> <a id="22112" class="Symbol">∀</a> <a id="22114" class="Symbol">{</a><a id="22115" href="../Decidable/#22115" class="Bound">A</a> <a id="22117" class="Symbol">:</a> <a id="22119" class="PrimitiveType">Set</a><a id="22122" class="Symbol">}</a> <a id="22124" class="Symbol">→</a> <a id="22126" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="22130" href="../Decidable/#22115" class="Bound">A</a> <a id="22132" class="Symbol">→</a> <a id="22134" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="22138" class="Symbol">(</a><a id="22139" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="22141" href="../Decidable/#22115" class="Bound">A</a><a id="22142" class="Symbol">)</a>
<a id="22144" href="../Decidable/#22107" class="Function">¬?</a> <a id="22147" class="Symbol">(</a><a id="22148" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="22152" href="../Decidable/#22152" class="Bound">x</a><a id="22153" class="Symbol">)</a>  <a id="22156" class="Symbol">=</a>  <a id="22159" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="22162" class="Symbol">(</a><a id="22163" href="../Decidable/#1203" class="Function">¬¬-intro</a> <a id="22172" href="../Decidable/#22152" class="Bound">x</a><a id="22173" class="Symbol">)</a>
<a id="22175" href="../Decidable/#22107" class="Function">¬?</a> <a id="22178" class="Symbol">(</a><a id="22179" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="22182" href="../Decidable/#22182" class="Bound">¬x</a><a id="22184" class="Symbol">)</a>  <a id="22187" class="Symbol">=</a>  <a id="22190" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="22194" href="../Decidable/#22182" class="Bound">¬x</a>
</pre>
<!--
We simply swap yes and no.  In the first equation,
the right-hand side asserts that the negation of `¬ A` holds,
in other words, that `¬ ¬ A` holds, which is an easy consequence
of the fact that `A` holds.
-->
<p>我们直接把 yes 和 no 交换。在第一个等式中，右手边断言了 <code>¬ A</code> 的否定成立，也就是说 <code>¬ ¬ A</code> 成立——这是一个 <code>A</code> 成立时可以简单得到的推论。</p>
<!--
There is also a slightly less familiar connective,
corresponding to implication:
-->
<p>还有一个与蕴涵相对应，但是稍微不那么知名的运算符：</p>
<pre class="Agda"><a id="_⊃_"></a><a id="22626" href="../Decidable/#22626" class="Function Operator">_⊃_</a> <a id="22630" class="Symbol">:</a> <a id="22632" href="../Decidable/#2544" class="Datatype">Bool</a> <a id="22637" class="Symbol">→</a> <a id="22639" href="../Decidable/#2544" class="Datatype">Bool</a> <a id="22644" class="Symbol">→</a> <a id="22646" href="../Decidable/#2544" class="Datatype">Bool</a>
<a id="22651" class="Symbol">_</a>     <a id="22657" href="../Decidable/#22626" class="Function Operator">⊃</a> <a id="22659" href="../Decidable/#2563" class="InductiveConstructor">true</a>   <a id="22666" class="Symbol">=</a>  <a id="22669" href="../Decidable/#2563" class="InductiveConstructor">true</a>
<a id="22674" href="../Decidable/#2578" class="CatchallClause InductiveConstructor">false</a><a id="22679" class="CatchallClause"> </a><a id="22680" href="../Decidable/#22626" class="CatchallClause Function Operator">⊃</a><a id="22681" class="CatchallClause"> </a><a id="22682" class="CatchallClause Symbol">_</a>      <a id="22689" class="Symbol">=</a>  <a id="22692" href="../Decidable/#2563" class="InductiveConstructor">true</a>
<a id="22697" href="../Decidable/#2563" class="InductiveConstructor">true</a>  <a id="22703" href="../Decidable/#22626" class="Function Operator">⊃</a> <a id="22705" href="../Decidable/#2578" class="InductiveConstructor">false</a>  <a id="22712" class="Symbol">=</a>  <a id="22715" href="../Decidable/#2578" class="InductiveConstructor">false</a>
</pre>
<!--
One boolean implies another if
whenever the first is true then the second is true.
Hence, the implication of two booleans is true if
the second is true or the first is false,
and false if the first is true and the second is false.
In Emacs, the left-hand side of the second equation displays in grey,
indicating that the order of the equations determines which of the
first or the second can match.  However, regardless of which matches
the answer is the same.
-->
<p>当任何一个布尔值为真的时候，另一个布尔值恒为真，我们成为第一个布尔值蕴涵第二个布尔值。 因此，两者的蕴涵在第二个为真或者第一个为假时为真，在第一个为真而第二个为假时为假。 在 Emacs 中，第二个等式的左手边显示为灰色，表示这些等式出现的顺序决定了是第一条还是第二条 会被匹配到。然而，不管是哪一条被匹配到，结果都是一样的。</p>
<!--
Correspondingly, given two decidable propositions,
we can decide if the first implies the second:
-->
<p>相应地，给定两个可判定的命题，我们可以判定它们的析取：</p>
<pre class="Agda"><a id="_→-dec_"></a><a id="23503" href="../Decidable/#23503" class="Function Operator">_→-dec_</a> <a id="23511" class="Symbol">:</a> <a id="23513" class="Symbol">∀</a> <a id="23515" class="Symbol">{</a><a id="23516" href="../Decidable/#23516" class="Bound">A</a> <a id="23518" href="../Decidable/#23518" class="Bound">B</a> <a id="23520" class="Symbol">:</a> <a id="23522" class="PrimitiveType">Set</a><a id="23525" class="Symbol">}</a> <a id="23527" class="Symbol">→</a> <a id="23529" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="23533" href="../Decidable/#23516" class="Bound">A</a> <a id="23535" class="Symbol">→</a> <a id="23537" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="23541" href="../Decidable/#23518" class="Bound">B</a> <a id="23543" class="Symbol">→</a> <a id="23545" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="23549" class="Symbol">(</a><a id="23550" href="../Decidable/#23516" class="Bound">A</a> <a id="23552" class="Symbol">→</a> <a id="23554" href="../Decidable/#23518" class="Bound">B</a><a id="23555" class="Symbol">)</a>
<a id="23557" class="Symbol">_</a>     <a id="23563" href="../Decidable/#23503" class="Function Operator">→-dec</a> <a id="23569" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="23573" href="../Decidable/#23573" class="Bound">y</a>  <a id="23576" class="Symbol">=</a>  <a id="23579" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="23583" class="Symbol">(λ</a> <a id="23586" href="../Decidable/#23586" class="Bound">_</a> <a id="23588" class="Symbol">→</a> <a id="23590" href="../Decidable/#23573" class="Bound">y</a><a id="23591" class="Symbol">)</a>
<a id="23593" href="../Decidable/#9891" class="CatchallClause InductiveConstructor">no</a><a id="23595" class="CatchallClause"> </a><a id="23596" href="../Decidable/#23596" class="CatchallClause Bound">¬x</a><a id="23598" class="CatchallClause"> </a><a id="23599" href="../Decidable/#23503" class="CatchallClause Function Operator">→-dec</a><a id="23604" class="CatchallClause"> </a><a id="23605" class="CatchallClause Symbol">_</a>      <a id="23612" class="Symbol">=</a>  <a id="23615" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="23619" class="Symbol">(λ</a> <a id="23622" href="../Decidable/#23622" class="Bound">x</a> <a id="23624" class="Symbol">→</a> <a id="23626" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="23633" class="Symbol">(</a><a id="23634" href="../Decidable/#23596" class="Bound">¬x</a> <a id="23637" href="../Decidable/#23622" class="Bound">x</a><a id="23638" class="Symbol">))</a>
<a id="23641" href="../Decidable/#9871" class="InductiveConstructor">yes</a> <a id="23645" href="../Decidable/#23645" class="Bound">x</a> <a id="23647" href="../Decidable/#23503" class="Function Operator">→-dec</a> <a id="23653" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="23656" href="../Decidable/#23656" class="Bound">¬y</a>  <a id="23660" class="Symbol">=</a>  <a id="23663" href="../Decidable/#9891" class="InductiveConstructor">no</a> <a id="23666" class="Symbol">(λ</a> <a id="23669" href="../Decidable/#23669" class="Bound">f</a> <a id="23671" class="Symbol">→</a> <a id="23673" href="../Decidable/#23656" class="Bound">¬y</a> <a id="23676" class="Symbol">(</a><a id="23677" href="../Decidable/#23669" class="Bound">f</a> <a id="23679" href="../Decidable/#23645" class="Bound">x</a><a id="23680" class="Symbol">))</a>
</pre>
<!--
The implication holds if either the second holds or
the negation of the first holds, and its negation
holds if the first holds and the negation of the second holds.
Evidence for the implication is a function from evidence
of the first to evidence of the second.
If the second holds, the function returns the evidence for it.
If the negation of the first holds, the function takes the
evidence of the first and derives a contradiction.
If the first holds and the negation of the second holds,
given evidence of the implication we must derive a contradiction;
we apply the evidence of the implication `f` to the evidence of the
first `x`, yielding a contradiction with the evidence `¬y` of
the negation of the second.
-->
<p>两者的蕴涵在第二者成立或者第一者的否定成立时成立，其否定在第一者成立而第二者否定成立时成立。 蕴涵成立的证明是一个从第一者成立的证明到第二者成立的证明的函数。如果第二者成立，那么这个函数 直接返回第二者的证明。如果第一者的否定成立，那么使用第一者成立的证明，构造一个矛盾。 如果第一者成立，第二者不成立，给定蕴涵成立的证明，我们必须构造一个矛盾：我们将成立的证明 <code>f</code> 应用于第一者成立的证明 <code>x</code>，再加以第二者否定成立的证明 <code>¬y</code> 来构造矛盾。</p>
<!--
Again in Emacs, the left-hand side of the second equation displays in grey,
indicating that the order of the equations determines which of the
first or the second can match.  This time the answer is different depending
on which matches; but either is equally valid.
-->
<p>同样地，在 Emacs 中，第二条等式在左手边以灰色显示，说明等式的顺序决定了第一条还是第二条会被匹配。 这一次，我们给出的结果会因为是哪一条被匹配而不一样，但两者都是同样正确的。</p>
<!--
#### Exercise `erasure` (practice)
-->
<h4 id="练习-erasure实践">练习 <code>erasure</code>（实践）</h4>
<!--
Show that erasure relates corresponding boolean and decidable operations:
-->
<p>证明擦除将对应的布尔值和可判定的值的操作联系了起来：</p>
<pre class="Agda"><a id="25195" class="Keyword">postulate</a>
  <a id="∧-×"></a><a id="25207" href="../Decidable/#25207" class="Postulate">∧-×</a> <a id="25211" class="Symbol">:</a> <a id="25213" class="Symbol">∀</a> <a id="25215" class="Symbol">{</a><a id="25216" href="../Decidable/#25216" class="Bound">A</a> <a id="25218" href="../Decidable/#25218" class="Bound">B</a> <a id="25220" class="Symbol">:</a> <a id="25222" class="PrimitiveType">Set</a><a id="25225" class="Symbol">}</a> <a id="25227" class="Symbol">(</a><a id="25228" href="../Decidable/#25228" class="Bound">x</a> <a id="25230" class="Symbol">:</a> <a id="25232" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="25236" href="../Decidable/#25216" class="Bound">A</a><a id="25237" class="Symbol">)</a> <a id="25239" class="Symbol">(</a><a id="25240" href="../Decidable/#25240" class="Bound">y</a> <a id="25242" class="Symbol">:</a> <a id="25244" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="25248" href="../Decidable/#25218" class="Bound">B</a><a id="25249" class="Symbol">)</a> <a id="25251" class="Symbol">→</a> <a id="25253" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="25255" href="../Decidable/#25228" class="Bound">x</a> <a id="25257" href="../Decidable/#16932" class="Function Operator">⌋</a> <a id="25259" href="../Decidable/#18468" class="Function Operator">∧</a> <a id="25261" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="25263" href="../Decidable/#25240" class="Bound">y</a> <a id="25265" href="../Decidable/#16932" class="Function Operator">⌋</a> <a id="25267" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="25269" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="25271" href="../Decidable/#25228" class="Bound">x</a> <a id="25273" href="../Decidable/#19026" class="Function Operator">×-dec</a> <a id="25279" href="../Decidable/#25240" class="Bound">y</a> <a id="25281" href="../Decidable/#16932" class="Function Operator">⌋</a>
  <a id="∨-⊎"></a><a id="25285" href="../Decidable/#25285" class="Postulate">∨-⊎</a> <a id="25289" class="Symbol">:</a> <a id="25291" class="Symbol">∀</a> <a id="25293" class="Symbol">{</a><a id="25294" href="../Decidable/#25294" class="Bound">A</a> <a id="25296" href="../Decidable/#25296" class="Bound">B</a> <a id="25298" class="Symbol">:</a> <a id="25300" class="PrimitiveType">Set</a><a id="25303" class="Symbol">}</a> <a id="25305" class="Symbol">(</a><a id="25306" href="../Decidable/#25306" class="Bound">x</a> <a id="25308" class="Symbol">:</a> <a id="25310" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="25314" href="../Decidable/#25294" class="Bound">A</a><a id="25315" class="Symbol">)</a> <a id="25317" class="Symbol">(</a><a id="25318" href="../Decidable/#25318" class="Bound">y</a> <a id="25320" class="Symbol">:</a> <a id="25322" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="25326" href="../Decidable/#25296" class="Bound">B</a><a id="25327" class="Symbol">)</a> <a id="25329" class="Symbol">→</a> <a id="25331" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="25333" href="../Decidable/#25306" class="Bound">x</a> <a id="25335" href="../Decidable/#16932" class="Function Operator">⌋</a> <a id="25337" href="../Decidable/#20239" class="Function Operator">∨</a> <a id="25339" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="25341" href="../Decidable/#25318" class="Bound">y</a> <a id="25343" href="../Decidable/#16932" class="Function Operator">⌋</a> <a id="25345" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="25347" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="25349" href="../Decidable/#25306" class="Bound">x</a> <a id="25351" href="../Decidable/#20800" class="Function Operator">⊎-dec</a> <a id="25357" href="../Decidable/#25318" class="Bound">y</a> <a id="25359" href="../Decidable/#16932" class="Function Operator">⌋</a>
  <a id="not-¬"></a><a id="25363" href="../Decidable/#25363" class="Postulate">not-¬</a> <a id="25369" class="Symbol">:</a> <a id="25371" class="Symbol">∀</a> <a id="25373" class="Symbol">{</a><a id="25374" href="../Decidable/#25374" class="Bound">A</a> <a id="25376" class="Symbol">:</a> <a id="25378" class="PrimitiveType">Set</a><a id="25381" class="Symbol">}</a> <a id="25383" class="Symbol">(</a><a id="25384" href="../Decidable/#25384" class="Bound">x</a> <a id="25386" class="Symbol">:</a> <a id="25388" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="25392" href="../Decidable/#25374" class="Bound">A</a><a id="25393" class="Symbol">)</a> <a id="25395" class="Symbol">→</a> <a id="25397" href="../Decidable/#21931" class="Function">not</a> <a id="25401" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="25403" href="../Decidable/#25384" class="Bound">x</a> <a id="25405" href="../Decidable/#16932" class="Function Operator">⌋</a> <a id="25407" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="25409" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="25411" href="../Decidable/#22107" class="Function">¬?</a> <a id="25414" href="../Decidable/#25384" class="Bound">x</a> <a id="25416" href="../Decidable/#16932" class="Function Operator">⌋</a>
</pre>
<!--
#### Exercise `iff-erasure` (recommended)
-->
<h4 id="练习-iff-erasure-推荐">练习 <code>iff-erasure</code> （推荐）</h4>
<!--
Give analogues of the `_⇔_` operation from
Chapter [Isomorphism](/Isomorphism/#iff),
operation on booleans and decidables, and also show the corresponding erasure:
-->
<p>给出与<a href="../Isomorphism/#iff">同构与嵌入</a>章节中 <code>_↔︎_</code> 相对应的布尔值与可判定的值的操作， 并证明其对应的擦除：</p>
<pre class="Agda"><a id="25750" class="Keyword">postulate</a>
  <a id="_iff_"></a><a id="25762" href="../Decidable/#25762" class="Postulate Operator">_iff_</a> <a id="25768" class="Symbol">:</a> <a id="25770" href="../Decidable/#2544" class="Datatype">Bool</a> <a id="25775" class="Symbol">→</a> <a id="25777" href="../Decidable/#2544" class="Datatype">Bool</a> <a id="25782" class="Symbol">→</a> <a id="25784" href="../Decidable/#2544" class="Datatype">Bool</a>
  <a id="_⇔-dec_"></a><a id="25791" href="../Decidable/#25791" class="Postulate Operator">_⇔-dec_</a> <a id="25799" class="Symbol">:</a> <a id="25801" class="Symbol">∀</a> <a id="25803" class="Symbol">{</a><a id="25804" href="../Decidable/#25804" class="Bound">A</a> <a id="25806" href="../Decidable/#25806" class="Bound">B</a> <a id="25808" class="Symbol">:</a> <a id="25810" class="PrimitiveType">Set</a><a id="25813" class="Symbol">}</a> <a id="25815" class="Symbol">→</a> <a id="25817" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="25821" href="../Decidable/#25804" class="Bound">A</a> <a id="25823" class="Symbol">→</a> <a id="25825" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="25829" href="../Decidable/#25806" class="Bound">B</a> <a id="25831" class="Symbol">→</a> <a id="25833" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="25837" class="Symbol">(</a><a id="25838" href="../Decidable/#25804" class="Bound">A</a> <a id="25840" href="../Isomorphism/#14988" class="Record Operator">⇔</a> <a id="25842" href="../Decidable/#25806" class="Bound">B</a><a id="25843" class="Symbol">)</a>
  <a id="iff-⇔"></a><a id="25847" href="../Decidable/#25847" class="Postulate">iff-⇔</a> <a id="25853" class="Symbol">:</a> <a id="25855" class="Symbol">∀</a> <a id="25857" class="Symbol">{</a><a id="25858" href="../Decidable/#25858" class="Bound">A</a> <a id="25860" href="../Decidable/#25860" class="Bound">B</a> <a id="25862" class="Symbol">:</a> <a id="25864" class="PrimitiveType">Set</a><a id="25867" class="Symbol">}</a> <a id="25869" class="Symbol">(</a><a id="25870" href="../Decidable/#25870" class="Bound">x</a> <a id="25872" class="Symbol">:</a> <a id="25874" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="25878" href="../Decidable/#25858" class="Bound">A</a><a id="25879" class="Symbol">)</a> <a id="25881" class="Symbol">(</a><a id="25882" href="../Decidable/#25882" class="Bound">y</a> <a id="25884" class="Symbol">:</a> <a id="25886" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="25890" href="../Decidable/#25860" class="Bound">B</a><a id="25891" class="Symbol">)</a> <a id="25893" class="Symbol">→</a> <a id="25895" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="25897" href="../Decidable/#25870" class="Bound">x</a> <a id="25899" href="../Decidable/#16932" class="Function Operator">⌋</a> <a id="25901" href="../Decidable/#25762" class="Postulate Operator">iff</a> <a id="25905" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="25907" href="../Decidable/#25882" class="Bound">y</a> <a id="25909" href="../Decidable/#16932" class="Function Operator">⌋</a> <a id="25911" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="25913" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="25915" href="../Decidable/#25870" class="Bound">x</a> <a id="25917" href="../Decidable/#25791" class="Postulate Operator">⇔-dec</a> <a id="25923" href="../Decidable/#25882" class="Bound">y</a> <a id="25925" href="../Decidable/#16932" class="Function Operator">⌋</a>
</pre>
<!--
<pre class="Agda"><a id="25941" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="25977" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
## Proof by reflection {name=proof-by-reflection}
-->
<h2 name="proof-by-reflection" id="互映证明">互映证明</h2>
<!--
Let's revisit our definition of monus from
Chapter [Naturals](/Naturals/).
If we subtract a larger number from a smaller number, we take the result to be
zero. We had to do something, after all. What could we have done differently? We
could have defined a *guarded* version of minus, a function which subtracts `n`
from `m` only if `n ≤ m`:
-->
<p>让我们回顾一下章节<a href="../Naturals/">自然数</a>中 <code>monus</code> 的定义。 如果从一个较小的数中减去一个较大的数，结果为零。毕竟我们总是要得到一个结果。 我们可以用其他方式定义吗？可以定义一版带有<strong>守卫（guarded）</strong>的减法──只有当 <code>n ≤ m</code> 时才能从 <code>m</code> 中减去 <code>n</code> ：</p>
<pre class="Agda"><a id="minus"></a><a id="26599" href="../Decidable/#26599" class="Function">minus</a> <a id="26605" class="Symbol">:</a> <a id="26607" class="Symbol">(</a><a id="26608" href="../Decidable/#26608" class="Bound">m</a> <a id="26610" href="../Decidable/#26610" class="Bound">n</a> <a id="26612" class="Symbol">:</a> <a id="26614" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="26615" class="Symbol">)</a> <a id="26617" class="Symbol">(</a><a id="26618" href="../Decidable/#26618" class="Bound">n≤m</a> <a id="26622" class="Symbol">:</a> <a id="26624" href="../Decidable/#26610" class="Bound">n</a> <a id="26626" href="../Decidable/#1717" class="Datatype Operator">≤</a> <a id="26628" href="../Decidable/#26608" class="Bound">m</a><a id="26629" class="Symbol">)</a> <a id="26631" class="Symbol">→</a> <a id="26633" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="26635" href="../Decidable/#26599" class="Function">minus</a> <a id="26641" href="../Decidable/#26641" class="Bound">m</a>       <a id="26649" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="26657" class="Symbol">_</a>         <a id="26667" class="Symbol">=</a> <a id="26669" href="../Decidable/#26641" class="Bound">m</a>
<a id="26671" href="../Decidable/#26599" class="Function">minus</a> <a id="26677" class="Symbol">(</a><a id="26678" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="26682" href="../Decidable/#26682" class="Bound">m</a><a id="26683" class="Symbol">)</a> <a id="26685" class="Symbol">(</a><a id="26686" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="26690" href="../Decidable/#26690" class="Bound">n</a><a id="26691" class="Symbol">)</a> <a id="26693" class="Symbol">(</a><a id="26694" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="26698" href="../Decidable/#26698" class="Bound">n≤m</a><a id="26701" class="Symbol">)</a> <a id="26703" class="Symbol">=</a> <a id="26705" href="../Decidable/#26599" class="Function">minus</a> <a id="26711" href="../Decidable/#26682" class="Bound">m</a> <a id="26713" href="../Decidable/#26690" class="Bound">n</a> <a id="26715" href="../Decidable/#26698" class="Bound">n≤m</a>
</pre>
<!--
Unfortunately, it is painful to use, since we have to explicitly provide
the proof that `n ≤ m`:
-->
<p>然而这种定义难以使用，因为我们必须显式地为 <code>n ≤ m</code> 提供证明：</p>
<pre class="Agda"><a id="26872" href="../Decidable/#26872" class="Function">_</a> <a id="26874" class="Symbol">:</a> <a id="26876" href="../Decidable/#26599" class="Function">minus</a> <a id="26882" class="Number">5</a> <a id="26884" class="Number">3</a> <a id="26886" class="Symbol">(</a><a id="26887" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="26891" class="Symbol">(</a><a id="26892" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="26896" class="Symbol">(</a><a id="26897" href="../Decidable/#1793" class="InductiveConstructor">s≤s</a> <a id="26901" href="../Decidable/#1744" class="InductiveConstructor">z≤n</a><a id="26904" class="Symbol">)))</a> <a id="26908" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="26910" class="Number">2</a>
<a id="26912" class="Symbol">_</a> <a id="26914" class="Symbol">=</a> <a id="26916" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<!--
We cannot solve this problem in general, but in the scenario above, we happen to
know the two numbers *statically*. In that case, we can use a technique called
*proof by reflection*. Essentially, we can ask Agda to run the decidable
equality `n ≤? m` while type checking, and make sure that `n ≤ m`!
-->
<p>这个问题没有通用的解决方案，但是在上述的情景下，我们恰好<strong>静态地</strong>知道这两个数字。这种情况下，我们可以使用一种被称为<strong>互映证明（proof by reflection）</strong>的技术。 实质上，在类型检查的时候我们可以让 Agda 运行可判定的等式 <code>n ≤? m</code> 并且保证 <code>n ≤ m</code>！</p>
<!--
We do this by using a feature of implicits. Agda will fill in an implicit of a
record type if it can fill in all its fields. So Agda will *always* manage to
fill in an implicit of an *empty* record type, since there aren't any fields
after all. This is why `⊤` is defined as an empty record.
-->
<p>我们使用「隐式参数」的一个特性来实现这个功能。如果 Agda 可以填充一个记录类型的所有字段，那么 Agda 就可以填充此记录类型的隐式参数。 由于空记录类型没有任何字段，Agda 总是会设法填充空记录类型的隐式参数。这就是 <code>⊤</code> 类型被定义成空记录的原因。</p>
<!--
The trick is to have an implicit argument of the type `T ⌊ n ≤? m ⌋`. Let's go
through what this means step-by-step. First, we run the decision procedure,
`n ≤? m`. This provides us with evidence whether `n ≤ m` holds or not. We erase the
evidence to a boolean. Finally, we apply `T`. Recall that `T` maps booleans into
the world of evidence: `true` becomes the unit type `⊤`, and `false` becomes the
empty type `⊥`. Operationally, an implicit argument of this type works as a
guard.
-->
<p>这里的技巧是设置一个类型为 <code>T ⌊ n ≤? m ⌋</code> 的隐式参数。让我们一步一步阐述这句话的含义。 首先，我们运行判定过程 <code>n ≤? m</code>。它向我们提供了 <code>n ≤ m</code> 是否成立的证据。我们擦除证据得到布尔值。 最后，我们应用 <code>T</code>。回想一下，<code>T</code> 将布尔值映射到证据的世界：<code>true</code> 变成了单位类型 <code>⊤</code>， <code>false</code> 变成了空类型 <code>⊥</code> 。在操作上，这个类型的隐式参数起到了守卫的作用。</p>
<!--
- If `n ≤ m` holds, the type of the implicit value reduces to `⊤`. Agda then
  happily provides the implicit value.
- Otherwise, the type reduces to `⊥`, which Agda has no chance of providing, so
  it will throw an error. For instance, if we call `3 - 5` we get `_n≤m_254 : ⊥`.
-->
<ul>
<li>如果 <code>n ≤ m</code> 成立，隐式参数的类型规约为 <code>⊤</code>。 然后 Agda 会欣然地提供隐式参数。</li>
<li>否则，类型规约为 <code>⊥</code> ，Agda 无法为此类型提供对应的值，因此会报错。例如，如果我们调用 <code>3 - 5</code> 会得到 <code>_n≤m_254 : ⊥</code>。</li>
</ul>
<!--
We obtain the witness for `n ≤ m` using `toWitness`, which we defined earlier:
-->
<p>我们使用之前定义的 <code>toWitness</code> 获得了 <code>n ≤ m</code> 的证据：</p>
<pre class="Agda"><a id="_-_"></a><a id="29075" href="../Decidable/#29075" class="Function Operator">_-_</a> <a id="29079" class="Symbol">:</a> <a id="29081" class="Symbol">(</a><a id="29082" href="../Decidable/#29082" class="Bound">m</a> <a id="29084" href="../Decidable/#29084" class="Bound">n</a> <a id="29086" class="Symbol">:</a> <a id="29088" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="29089" class="Symbol">)</a> <a id="29091" class="Symbol">{</a><a id="29092" href="../Decidable/#29092" class="Bound">n≤m</a> <a id="29096" class="Symbol">:</a> <a id="29098" href="../Decidable/#4506" class="Function">T</a> <a id="29100" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="29102" href="../Decidable/#29084" class="Bound">n</a> <a id="29104" href="../Decidable/#11686" class="Function Operator">≤?</a> <a id="29107" href="../Decidable/#29082" class="Bound">m</a> <a id="29109" href="../Decidable/#16932" class="Function Operator">⌋</a><a id="29110" class="Symbol">}</a> <a id="29112" class="Symbol">→</a> <a id="29114" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="29116" href="../Decidable/#29075" class="Function Operator">_-_</a> <a id="29120" href="../Decidable/#29120" class="Bound">m</a> <a id="29122" href="../Decidable/#29122" class="Bound">n</a> <a id="29124" class="Symbol">{</a><a id="29125" href="../Decidable/#29125" class="Bound">n≤m</a><a id="29128" class="Symbol">}</a> <a id="29130" class="Symbol">=</a> <a id="29132" href="../Decidable/#26599" class="Function">minus</a> <a id="29138" href="../Decidable/#29120" class="Bound">m</a> <a id="29140" href="../Decidable/#29122" class="Bound">n</a> <a id="29142" class="Symbol">(</a><a id="29143" href="../Decidable/#17341" class="Function">toWitness</a> <a id="29153" href="../Decidable/#29125" class="Bound">n≤m</a><a id="29156" class="Symbol">)</a>
</pre>
<!--
We can safely use `_-_` as long as we statically know the two numbers:
-->
<p>我们现在只要能静态地知道这两个数就可以安全地使用 <code>_-_</code> 了：</p>
<pre class="Agda"><a id="29283" href="../Decidable/#29283" class="Function">_</a> <a id="29285" class="Symbol">:</a> <a id="29287" class="Number">5</a> <a id="29289" href="../Decidable/#29075" class="Function Operator">-</a> <a id="29291" class="Number">3</a> <a id="29293" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="29295" class="Number">2</a>
<a id="29297" class="Symbol">_</a> <a id="29299" class="Symbol">=</a> <a id="29301" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<!--
It turns out that this idiom is very common. The standard library defines a
synonym for `T ⌊ ? ⌋` called `True`:
-->
<p>事实上，这种惯用语法非常普遍。标准库为 <code>T ⌊ ? ⌋</code> 定义了叫做 <code>True</code> 的同义词：</p>
<pre class="Agda"><a id="True"></a><a id="29488" href="../Decidable/#29488" class="Function">True</a> <a id="29493" class="Symbol">:</a> <a id="29495" class="Symbol">∀</a> <a id="29497" class="Symbol">{</a><a id="29498" href="../Decidable/#29498" class="Bound">Q</a><a id="29499" class="Symbol">}</a> <a id="29501" class="Symbol">→</a> <a id="29503" href="../Decidable/#9843" class="Datatype">Dec</a> <a id="29507" href="../Decidable/#29498" class="Bound">Q</a> <a id="29509" class="Symbol">→</a> <a id="29511" class="PrimitiveType">Set</a>
<a id="29515" href="../Decidable/#29488" class="Function">True</a> <a id="29520" href="../Decidable/#29520" class="Bound">Q</a> <a id="29522" class="Symbol">=</a> <a id="29524" href="../Decidable/#4506" class="Function">T</a> <a id="29526" href="../Decidable/#16932" class="Function Operator">⌊</a> <a id="29528" href="../Decidable/#29520" class="Bound">Q</a> <a id="29530" href="../Decidable/#16932" class="Function Operator">⌋</a>
</pre>
<!--
#### Exercise `False`
-->
<h4 id="练习-false">练习 <code>False</code></h4>
<!--
Give analogues of `True`, `toWitness`, and `fromWitness` which work with *negated* properties. Call these `False`, `toWitnessFalse`, and `fromWitnessFalse`.
-->
<p>给出 <code>True</code>，<code>toWitness</code> 和 <code>fromWitness</code> 的<strong>相反</strong>定义。分别称为 <code>False</code>，<code>toWitnessFalse</code> 和 <code>fromWitnessFalse</code>。</p>
<!--
## Standard Library
-->
<h2 id="标准库">标准库</h2>
<pre class="Agda"><a id="29895" class="Keyword">import</a> <a id="29902" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html" class="Module">Data.Bool.Base</a> <a id="29917" class="Keyword">using</a> <a id="29923" class="Symbol">(</a><a id="29924" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="29928" class="Symbol">;</a> <a id="29930" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="29934" class="Symbol">;</a> <a id="29936" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="29941" class="Symbol">;</a> <a id="29943" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html#1451" class="Function">T</a><a id="29944" class="Symbol">;</a> <a id="29946" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html#986" class="Function Operator">_∧_</a><a id="29949" class="Symbol">;</a> <a id="29951" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html#1044" class="Function Operator">_∨_</a><a id="29954" class="Symbol">;</a> <a id="29956" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html#932" class="Function">not</a><a id="29959" class="Symbol">)</a>
<a id="29961" class="Keyword">import</a> <a id="29968" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.html" class="Module">Data.Nat</a> <a id="29977" class="Keyword">using</a> <a id="29983" class="Symbol">(</a><a id="29984" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#4678" class="Function Operator">_≤?_</a><a id="29988" class="Symbol">)</a>
<a id="29990" class="Keyword">import</a> <a id="29997" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="30014" class="Keyword">using</a> <a id="30020" class="Symbol">(</a><a id="30021" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1508" class="Record">Dec</a><a id="30024" class="Symbol">;</a> <a id="30026" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a><a id="30029" class="Symbol">;</a> <a id="30031" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a><a id="30033" class="Symbol">)</a>
<a id="30035" class="Keyword">import</a> <a id="30042" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="30069" class="Keyword">using</a> <a id="30075" class="Symbol">(</a><a id="30076" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.Decidable.Core.html#1312" class="Function Operator">⌊_⌋</a><a id="30079" class="Symbol">;</a> <a id="30081" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.Decidable.Core.html#1365" class="Function">True</a><a id="30085" class="Symbol">;</a> <a id="30087" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.Decidable.Core.html#1484" class="Function">toWitness</a><a id="30096" class="Symbol">;</a> <a id="30098" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.Decidable.Core.html#1653" class="Function">fromWitness</a><a id="30109" class="Symbol">)</a>
<a id="30111" class="Keyword">import</a> <a id="30118" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="30144" class="Keyword">using</a> <a id="30150" class="Symbol">(</a><a id="30151" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.Negation.html#1286" class="Function">¬?</a><a id="30153" class="Symbol">)</a>
<a id="30155" class="Keyword">import</a> <a id="30162" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.Product.html" class="Module">Relation.Nullary.Product</a> <a id="30187" class="Keyword">using</a> <a id="30193" class="Symbol">(</a><a id="30194" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.Product.html#904" class="Function Operator">_×-dec_</a><a id="30201" class="Symbol">)</a>
<a id="30203" class="Keyword">import</a> <a id="30210" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.Sum.html" class="Module">Relation.Nullary.Sum</a> <a id="30231" class="Keyword">using</a> <a id="30237" class="Symbol">(</a><a id="30238" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.Sum.html#946" class="Function Operator">_⊎-dec_</a><a id="30245" class="Symbol">)</a>
<a id="30247" class="Keyword">import</a> <a id="30254" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="30270" class="Keyword">using</a> <a id="30276" class="Symbol">(</a><a id="30277" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.Definitions.html#4575" class="Function">Decidable</a><a id="30286" class="Symbol">)</a>
</pre>
<h2 id="unicode">Unicode</h2>
<!--
    ∧  U+2227  LOGICAL AND (\and, \wedge)
    ∨  U+2228  LOGICAL OR (\or, \vee)
    ⊃  U+2283  SUPERSET OF (\sup)
    ᵇ  U+1D47  MODIFIER LETTER SMALL B  (\^b)
    ⌊  U+230A  LEFT FLOOR (\clL)
    ⌋  U+230B  RIGHT FLOOR (\clR)
-->
<pre><code>∧  U+2227  逻辑和 (\and, \wedge)
∨  U+2228  逻辑或 (\or, \vee)
⊃  U+2283  超集 (\sup)
ᵇ  U+1D47  修饰符小写 B  (\^b)
⌊  U+230A  左向下取整 (\clL)
⌋  U+230B  右向下取整 (\clR)</code></pre>
    </div>
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Quantifiers/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Decidable.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Lists/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

</article>

            </div>
        </main>
        <footer class="site-footer h-card">
    <data class="u-url" href="../"></data>
    <div class="wrapper">
        <h2 class="footer-heading">编程语言基础：Agda 语言描述</h2>
        
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Philip Wadler</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wadler" title="wadler"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wadler</a></li>
    
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Wen Kokke</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wenkokke</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;wenkokke</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Jeremy G. Siek</li>
                    <li>
                        
                        <a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/jsiek" title="jsiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;jsiek</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;jeremysiek</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        
        This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
    </div>
</footer>

    </body>
</html>
