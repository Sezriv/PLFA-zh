<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../public/css/style.css">
  
  <title>编程语言基础：Agda 语言描述 – Equality</title>
  
  
  
</head>

    <body>
        <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="../">编程语言基础：Agda 语言描述</a>
        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="../">主页</a>
                <a class="page-link" href="../Announcements/">公告</a>
                <a class="page-link" href="../GettingStarted/">使用说明</a>
                <a class="page-link" href="../Citing/">引用</a>
                <a class="page-link" href="https://plfa.github.io/">English</a>
            </div>
        </nav>
    </div>
</header>

        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Relations/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Equality.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Isomorphism/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

    <header class="post-header">
        <h1 class="post-title" id="equality">Equality: 相等性与等式推理</h1>
    </header>
    <div class="post-content">
        <pre class="Agda"><a id="183" class="Keyword">module</a> <a id="190" href="../Equality/" class="Module">plfa.part1.Equality</a> <a id="210" class="Keyword">where</a>
</pre>
<!--
Much of our reasoning has involved equality.  Given two terms `M`
and `N`, both of type `A`, we write `M ≡ N` to assert that `M` and `N`
are interchangeable.  So far we have treated equality as a primitive,
here we show how to define it as an inductive datatype.
-->
<p>我们在论证的过程中经常会使用相等性。给定两个都为 <code>A</code> 类型的项 <code>M</code> 和 <code>N</code>， 我们用 <code>M ≡ N</code> 来表示 <code>M</code> 和 <code>N</code> 可以相互替换。在此之前， 我们将相等性作为一个基础运算，而现在我们来说明如果将其定义为一个归纳的数据类型。</p>
<!--
## Imports
-->
<h2 id="导入">导入</h2>
<!--
This chapter has no imports.  Every chapter in this book, and nearly
every module in the Agda standard library, imports equality.
Since we define equality here, any import would create a conflict.
-->
<p>本章节没有导入的内容。本书的每一章节，以及 Agda 标准库的每个模块都导入了相等性。 我们在此定义相等性，导入其他内容将会产生冲突。</p>
<!--
## Equality
-->
<h2 id="相等性">相等性</h2>
<!--
We declare equality as follows:
-->
<p>我们如下定义相等性：</p>
<pre class="Agda"><a id="1014" class="Keyword">data</a> <a id="_≡_"></a><a id="1019" href="../Equality/#1019" class="Datatype Operator">_≡_</a> <a id="1023" class="Symbol">{</a><a id="1024" href="../Equality/#1024" class="Bound">A</a> <a id="1026" class="Symbol">:</a> <a id="1028" class="PrimitiveType">Set</a><a id="1031" class="Symbol">}</a> <a id="1033" class="Symbol">(</a><a id="1034" href="../Equality/#1034" class="Bound">x</a> <a id="1036" class="Symbol">:</a> <a id="1038" href="../Equality/#1024" class="Bound">A</a><a id="1039" class="Symbol">)</a> <a id="1041" class="Symbol">:</a> <a id="1043" href="../Equality/#1024" class="Bound">A</a> <a id="1045" class="Symbol">→</a> <a id="1047" class="PrimitiveType">Set</a> <a id="1051" class="Keyword">where</a>
  <a id="_≡_.refl"></a><a id="1059" href="../Equality/#1059" class="InductiveConstructor">refl</a> <a id="1064" class="Symbol">:</a> <a id="1066" href="../Equality/#1034" class="Bound">x</a> <a id="1068" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="1070" href="../Equality/#1034" class="Bound">x</a>
</pre>
<!--
In other words, for any type `A` and for any `x` of type `A`, the
constructor `refl` provides evidence that `x ≡ x`. Hence, every value
is equal to itself, and we have no other way of showing values
equal.  The definition features an asymmetry, in that the
first argument to `_≡_` is given by the parameter `x : A`, while the
second is given by an index in `A → Set`.  This follows our policy
of using parameters wherever possible.  The first argument to `_≡_`
can be a parameter because it doesn't vary, while the second must be
an index, so it can be required to be equal to the first.
-->
<p>用其他的话来说，对于任意类型 <code>A</code> 和任意 <code>A</code> 类型的 <code>x</code>，构造子 <code>refl</code> 提供了 <code>x ≡ x</code> 的证明。所以，每个值等同于它本身，我们并没有其他办法来证明值的相等性。 这个定义里有不对称的地方，<code>_≡_</code> 的第一个参数（Argument）由 <code>x : A</code> 给出， 而第二个参数（Argument）则是由 <code>A → Set</code> 的索引给出。 这和我们尽可能多的使用参数（Parameter）的理念相符。<code>_≡_</code> 的第一个参数（Argument） 可以作为一个参数（Parameter），因为它不会变，而第二个参数（Argument）则必须是一个索引， 这样它才可以等用于第一个。</p>
<!--
We declare the precedence of equality as follows:
-->
<p>我们如下定义相等性的优先级：</p>
<pre class="Agda"><a id="2056" class="Keyword">infix</a> <a id="2062" class="Number">4</a> <a id="2064" href="../Equality/#1019" class="Datatype Operator">_≡_</a>
</pre>
<!--
We set the precedence of `_≡_` at level 4, the same as `_≤_`,
which means it binds less tightly than any arithmetic operator.
It associates neither to left nor right; writing `x ≡ y ≡ z`
is illegal.
-->
<p>我们将 <code>_≡_</code> 的优先级设置为 4，与 <code>_≤_</code> 相同，所以其它算术运算符的结合都比它紧密。 由于它既不是左结合，也不是右结合的，因此 <code>x ≡ y ≡ z</code> 是不合法的。</p>
<!--
## Equality is an equivalence relation
-->
<h2 id="相等性是一个等价关系equivalence-relation">相等性是一个等价关系（Equivalence Relation）</h2>
<!--
An equivalence relation is one which is reflexive, symmetric, and transitive.
Reflexivity is built-in to the definition of equality, via the
constructor `refl`.  It is straightforward to show symmetry:
-->
<p>一个等价关系是自反、对称和传递的。其中自反性可以通过构造子 <code>refl</code> 直接从相等性的定义中得来。 我们可以直接地证明其对称性：</p>
<pre class="Agda"><a id="sym"></a><a id="2743" href="../Equality/#2743" class="Function">sym</a> <a id="2747" class="Symbol">:</a> <a id="2749" class="Symbol">∀</a> <a id="2751" class="Symbol">{</a><a id="2752" href="../Equality/#2752" class="Bound">A</a> <a id="2754" class="Symbol">:</a> <a id="2756" class="PrimitiveType">Set</a><a id="2759" class="Symbol">}</a> <a id="2761" class="Symbol">{</a><a id="2762" href="../Equality/#2762" class="Bound">x</a> <a id="2764" href="../Equality/#2764" class="Bound">y</a> <a id="2766" class="Symbol">:</a> <a id="2768" href="../Equality/#2752" class="Bound">A</a><a id="2769" class="Symbol">}</a>
  <a id="2773" class="Symbol">→</a> <a id="2775" href="../Equality/#2762" class="Bound">x</a> <a id="2777" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="2779" href="../Equality/#2764" class="Bound">y</a>
    <a id="2785" class="Comment">-----</a>
  <a id="2793" class="Symbol">→</a> <a id="2795" href="../Equality/#2764" class="Bound">y</a> <a id="2797" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="2799" href="../Equality/#2762" class="Bound">x</a>
<a id="2801" href="../Equality/#2743" class="Function">sym</a> <a id="2805" href="../Equality/#1059" class="InductiveConstructor">refl</a> <a id="2810" class="Symbol">=</a> <a id="2812" href="../Equality/#1059" class="InductiveConstructor">refl</a>
</pre>
<!--
How does this proof work? The argument to `sym` has type `x ≡ y`, but
on the left-hand side of the equation the argument has been
instantiated to the pattern `refl`, which requires that `x` and `y`
are the same.  Hence, for the right-hand side of the equation we need
a term of type `x ≡ x`, and `refl` will do.
-->
<p>这个证明是怎么运作的呢？<code>sym</code> 参数的类型是 <code>x ≡ y</code>，但是等式的左手边被 <code>refl</code> 模式实例化了， 这要求 <code>x</code> 和 <code>y</code> 相等。因此，等式的右手边需要一个类型为 <code>x ≡ x</code> 的项，用 <code>refl</code> 即可。</p>
<!--
It is instructive to develop `sym` interactively.  To start, we supply
a variable for the argument on the left, and a hole for the body on
the right:
-->
<p>交互式地证明 <code>sym</code> 很有教育意义。首先，我们在左手边使用一个变量来表示参数，在右手边使用一个洞：</p>
<pre><code>sym : ∀ {A : Set} {x y : A}
  → x ≡ y
    -----
  → y ≡ x
sym e = {! !}</code></pre>
<!--
If we go into the hole and type `C-c C-,` then Agda reports:
-->
<p>如果我们进入这个洞，使用 <code>C-c C-,</code>，Agda 会告诉我们：</p>
<pre><code>Goal: .y ≡ .x
————————————————————————————————————————————————————————————
e  : .x ≡ .y
.y : .A
.x : .A
.A : Set</code></pre>
<!--
If in the hole we type `C-c C-c e` then Agda will instantiate `e` to
all possible constructors, with one equation for each. There is only
one possible constructor:
-->
<p>在这个洞里，我们使用 <code>C-c C-c e</code>，Agda 会将 <code>e</code> 逐一展开为所有可能的构造子。 此处只有一个构造子：</p>
<pre><code>sym : ∀ {A : Set} {x y : A}
  → x ≡ y
    -----
  → y ≡ x
sym refl = {! !}</code></pre>
<!--
If we go into the hole again and type `C-c C-,` then Agda now reports:
-->
<p>如果我们再次进入这个洞，重新使用 <code>C-c C-,</code>，然后 Agda 现在会告诉我们：</p>
<pre><code> Goal: .x ≡ .x
 ————————————————————————————————————————————————————————————
 .x : .A
 .A : Set</code></pre>
<!--
This is the key step---Agda has worked out that `x` and `y` must be
the same to match the pattern `refl`!
-->
<p>这是一个重要的步骤—— Agda 发现了 <code>x</code> 和 <code>y</code> 必须相等，才能与模式 <code>refl</code> 相匹配。</p>
<!--
Finally, if we go back into the hole and type `C-c C-r` it will
instantiate the hole with the one constructor that yields a value of
the expected type:
-->
<p>最后，我们回到洞里，使用 <code>C-c C-r</code>，Agda 将会把洞变成一个可以满足给定类型的构造子实例。</p>
<pre><code>sym : ∀ {A : Set} {x y : A}
  → x ≡ y
    -----
  → y ≡ x
sym refl = refl</code></pre>
<!--
This completes the definition as given above.
-->
<p>我们至此完成了与之前给出证明相同的证明。</p>
<!--
Transitivity is equally straightforward:
-->
<p>传递性亦是很直接：</p>
<pre class="Agda"><a id="trans"></a><a id="5008" href="../Equality/#5008" class="Function">trans</a> <a id="5014" class="Symbol">:</a> <a id="5016" class="Symbol">∀</a> <a id="5018" class="Symbol">{</a><a id="5019" href="../Equality/#5019" class="Bound">A</a> <a id="5021" class="Symbol">:</a> <a id="5023" class="PrimitiveType">Set</a><a id="5026" class="Symbol">}</a> <a id="5028" class="Symbol">{</a><a id="5029" href="../Equality/#5029" class="Bound">x</a> <a id="5031" href="../Equality/#5031" class="Bound">y</a> <a id="5033" href="../Equality/#5033" class="Bound">z</a> <a id="5035" class="Symbol">:</a> <a id="5037" href="../Equality/#5019" class="Bound">A</a><a id="5038" class="Symbol">}</a>
  <a id="5042" class="Symbol">→</a> <a id="5044" href="../Equality/#5029" class="Bound">x</a> <a id="5046" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="5048" href="../Equality/#5031" class="Bound">y</a>
  <a id="5052" class="Symbol">→</a> <a id="5054" href="../Equality/#5031" class="Bound">y</a> <a id="5056" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="5058" href="../Equality/#5033" class="Bound">z</a>
    <a id="5064" class="Comment">-----</a>
  <a id="5072" class="Symbol">→</a> <a id="5074" href="../Equality/#5029" class="Bound">x</a> <a id="5076" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="5078" href="../Equality/#5033" class="Bound">z</a>
<a id="5080" href="../Equality/#5008" class="Function">trans</a> <a id="5086" href="../Equality/#1059" class="InductiveConstructor">refl</a> <a id="5091" href="../Equality/#1059" class="InductiveConstructor">refl</a>  <a id="5097" class="Symbol">=</a>  <a id="5100" href="../Equality/#1059" class="InductiveConstructor">refl</a>
</pre>
<!--
Again, a useful exercise is to carry out an interactive development,
checking how Agda's knowledge changes as each of the two arguments is
instantiated.
-->
<p>同样，交互式地证明这个特性是一个很好的练习，尤其是观察 Agda 的已知内容根据参数的实例而变化的过程。</p>
<!--
## Congruence and substitution {name=cong}
-->
<h2 name="cong" id="合同性和替换性">合同性和替换性</h2>
<!--
Equality satisfies _congruence_.  If two terms are equal,
they remain so after the same function is applied to both:
-->
<p>相等性满足 <em>合同性</em>（Congruence）。如果两个项相等，那么对它们使用相同的函数， 其结果仍然相等：</p>
<pre class="Agda"><a id="cong"></a><a id="5591" href="../Equality/#5591" class="Function">cong</a> <a id="5596" class="Symbol">:</a> <a id="5598" class="Symbol">∀</a> <a id="5600" class="Symbol">{</a><a id="5601" href="../Equality/#5601" class="Bound">A</a> <a id="5603" href="../Equality/#5603" class="Bound">B</a> <a id="5605" class="Symbol">:</a> <a id="5607" class="PrimitiveType">Set</a><a id="5610" class="Symbol">}</a> <a id="5612" class="Symbol">(</a><a id="5613" href="../Equality/#5613" class="Bound">f</a> <a id="5615" class="Symbol">:</a> <a id="5617" href="../Equality/#5601" class="Bound">A</a> <a id="5619" class="Symbol">→</a> <a id="5621" href="../Equality/#5603" class="Bound">B</a><a id="5622" class="Symbol">)</a> <a id="5624" class="Symbol">{</a><a id="5625" href="../Equality/#5625" class="Bound">x</a> <a id="5627" href="../Equality/#5627" class="Bound">y</a> <a id="5629" class="Symbol">:</a> <a id="5631" href="../Equality/#5601" class="Bound">A</a><a id="5632" class="Symbol">}</a>
  <a id="5636" class="Symbol">→</a> <a id="5638" href="../Equality/#5625" class="Bound">x</a> <a id="5640" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="5642" href="../Equality/#5627" class="Bound">y</a>
    <a id="5648" class="Comment">---------</a>
  <a id="5660" class="Symbol">→</a> <a id="5662" href="../Equality/#5613" class="Bound">f</a> <a id="5664" href="../Equality/#5625" class="Bound">x</a> <a id="5666" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="5668" href="../Equality/#5613" class="Bound">f</a> <a id="5670" href="../Equality/#5627" class="Bound">y</a>
<a id="5672" href="../Equality/#5591" class="Function">cong</a> <a id="5677" href="../Equality/#5677" class="Bound">f</a> <a id="5679" href="../Equality/#1059" class="InductiveConstructor">refl</a>  <a id="5685" class="Symbol">=</a>  <a id="5688" href="../Equality/#1059" class="InductiveConstructor">refl</a>
</pre>
<!--
Congruence of functions with two arguments is similar:
-->
<p>两个参数的函数也满足合同性：</p>
<pre class="Agda"><a id="cong₂"></a><a id="5783" href="../Equality/#5783" class="Function">cong₂</a> <a id="5789" class="Symbol">:</a> <a id="5791" class="Symbol">∀</a> <a id="5793" class="Symbol">{</a><a id="5794" href="../Equality/#5794" class="Bound">A</a> <a id="5796" href="../Equality/#5796" class="Bound">B</a> <a id="5798" href="../Equality/#5798" class="Bound">C</a> <a id="5800" class="Symbol">:</a> <a id="5802" class="PrimitiveType">Set</a><a id="5805" class="Symbol">}</a> <a id="5807" class="Symbol">(</a><a id="5808" href="../Equality/#5808" class="Bound">f</a> <a id="5810" class="Symbol">:</a> <a id="5812" href="../Equality/#5794" class="Bound">A</a> <a id="5814" class="Symbol">→</a> <a id="5816" href="../Equality/#5796" class="Bound">B</a> <a id="5818" class="Symbol">→</a> <a id="5820" href="../Equality/#5798" class="Bound">C</a><a id="5821" class="Symbol">)</a> <a id="5823" class="Symbol">{</a><a id="5824" href="../Equality/#5824" class="Bound">u</a> <a id="5826" href="../Equality/#5826" class="Bound">x</a> <a id="5828" class="Symbol">:</a> <a id="5830" href="../Equality/#5794" class="Bound">A</a><a id="5831" class="Symbol">}</a> <a id="5833" class="Symbol">{</a><a id="5834" href="../Equality/#5834" class="Bound">v</a> <a id="5836" href="../Equality/#5836" class="Bound">y</a> <a id="5838" class="Symbol">:</a> <a id="5840" href="../Equality/#5796" class="Bound">B</a><a id="5841" class="Symbol">}</a>
  <a id="5845" class="Symbol">→</a> <a id="5847" href="../Equality/#5824" class="Bound">u</a> <a id="5849" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="5851" href="../Equality/#5826" class="Bound">x</a>
  <a id="5855" class="Symbol">→</a> <a id="5857" href="../Equality/#5834" class="Bound">v</a> <a id="5859" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="5861" href="../Equality/#5836" class="Bound">y</a>
    <a id="5867" class="Comment">-------------</a>
  <a id="5883" class="Symbol">→</a> <a id="5885" href="../Equality/#5808" class="Bound">f</a> <a id="5887" href="../Equality/#5824" class="Bound">u</a> <a id="5889" href="../Equality/#5834" class="Bound">v</a> <a id="5891" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="5893" href="../Equality/#5808" class="Bound">f</a> <a id="5895" href="../Equality/#5826" class="Bound">x</a> <a id="5897" href="../Equality/#5836" class="Bound">y</a>
<a id="5899" href="../Equality/#5783" class="Function">cong₂</a> <a id="5905" href="../Equality/#5905" class="Bound">f</a> <a id="5907" href="../Equality/#1059" class="InductiveConstructor">refl</a> <a id="5912" href="../Equality/#1059" class="InductiveConstructor">refl</a>  <a id="5918" class="Symbol">=</a>  <a id="5921" href="../Equality/#1059" class="InductiveConstructor">refl</a>
</pre>
<!--
Equality is also a congruence in the function position of an application.
If two functions are equal, then applying them to the same term
yields equal terms:
-->
<p>在函数上的等价性也满足合同性。如果两个函数是相等的，那么它们作用在同一项上的结果是相等的：</p>
<pre class="Agda"><a id="cong-app"></a><a id="6150" href="../Equality/#6150" class="Function">cong-app</a> <a id="6159" class="Symbol">:</a> <a id="6161" class="Symbol">∀</a> <a id="6163" class="Symbol">{</a><a id="6164" href="../Equality/#6164" class="Bound">A</a> <a id="6166" href="../Equality/#6166" class="Bound">B</a> <a id="6168" class="Symbol">:</a> <a id="6170" class="PrimitiveType">Set</a><a id="6173" class="Symbol">}</a> <a id="6175" class="Symbol">{</a><a id="6176" href="../Equality/#6176" class="Bound">f</a> <a id="6178" href="../Equality/#6178" class="Bound">g</a> <a id="6180" class="Symbol">:</a> <a id="6182" href="../Equality/#6164" class="Bound">A</a> <a id="6184" class="Symbol">→</a> <a id="6186" href="../Equality/#6166" class="Bound">B</a><a id="6187" class="Symbol">}</a>
  <a id="6191" class="Symbol">→</a> <a id="6193" href="../Equality/#6176" class="Bound">f</a> <a id="6195" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="6197" href="../Equality/#6178" class="Bound">g</a>
    <a id="6203" class="Comment">---------------------</a>
  <a id="6227" class="Symbol">→</a> <a id="6229" class="Symbol">∀</a> <a id="6231" class="Symbol">(</a><a id="6232" href="../Equality/#6232" class="Bound">x</a> <a id="6234" class="Symbol">:</a> <a id="6236" href="../Equality/#6164" class="Bound">A</a><a id="6237" class="Symbol">)</a> <a id="6239" class="Symbol">→</a> <a id="6241" href="../Equality/#6176" class="Bound">f</a> <a id="6243" href="../Equality/#6232" class="Bound">x</a> <a id="6245" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="6247" href="../Equality/#6178" class="Bound">g</a> <a id="6249" href="../Equality/#6232" class="Bound">x</a>
<a id="6251" href="../Equality/#6150" class="Function">cong-app</a> <a id="6260" href="../Equality/#1059" class="InductiveConstructor">refl</a> <a id="6265" href="../Equality/#6265" class="Bound">x</a> <a id="6267" class="Symbol">=</a> <a id="6269" href="../Equality/#1059" class="InductiveConstructor">refl</a>
</pre>
<!--
Equality also satisfies *substitution*.
If two values are equal and a predicate holds of the first then it also holds of the second:
-->
<p>相等性也满足<em>替换性</em>（Substitution）。 如果两个值相等，其中一个满足某谓词，那么另一个也满足此谓词。</p>
<pre class="Agda"><a id="subst"></a><a id="6485" href="../Equality/#6485" class="Function">subst</a> <a id="6491" class="Symbol">:</a> <a id="6493" class="Symbol">∀</a> <a id="6495" class="Symbol">{</a><a id="6496" href="../Equality/#6496" class="Bound">A</a> <a id="6498" class="Symbol">:</a> <a id="6500" class="PrimitiveType">Set</a><a id="6503" class="Symbol">}</a> <a id="6505" class="Symbol">{</a><a id="6506" href="../Equality/#6506" class="Bound">x</a> <a id="6508" href="../Equality/#6508" class="Bound">y</a> <a id="6510" class="Symbol">:</a> <a id="6512" href="../Equality/#6496" class="Bound">A</a><a id="6513" class="Symbol">}</a> <a id="6515" class="Symbol">(</a><a id="6516" href="../Equality/#6516" class="Bound">P</a> <a id="6518" class="Symbol">:</a> <a id="6520" href="../Equality/#6496" class="Bound">A</a> <a id="6522" class="Symbol">→</a> <a id="6524" class="PrimitiveType">Set</a><a id="6527" class="Symbol">)</a>
  <a id="6531" class="Symbol">→</a> <a id="6533" href="../Equality/#6506" class="Bound">x</a> <a id="6535" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="6537" href="../Equality/#6508" class="Bound">y</a>
    <a id="6543" class="Comment">---------</a>
  <a id="6555" class="Symbol">→</a> <a id="6557" href="../Equality/#6516" class="Bound">P</a> <a id="6559" href="../Equality/#6506" class="Bound">x</a> <a id="6561" class="Symbol">→</a> <a id="6563" href="../Equality/#6516" class="Bound">P</a> <a id="6565" href="../Equality/#6508" class="Bound">y</a>
<a id="6567" href="../Equality/#6485" class="Function">subst</a> <a id="6573" href="../Equality/#6573" class="Bound">P</a> <a id="6575" href="../Equality/#1059" class="InductiveConstructor">refl</a> <a id="6580" href="../Equality/#6580" class="Bound">px</a> <a id="6583" class="Symbol">=</a> <a id="6585" href="../Equality/#6580" class="Bound">px</a>
</pre>
<!--
## Chains of equations
-->
<h2 id="等式串">等式串</h2>
<!--
Here we show how to support reasoning with chains of equations, as
used throughout the book.  We package the declarations into a module,
named `≡-Reasoning`, to match the format used in Agda's standard
library:
-->
<p>我们在此演示如何使用等式串来论证，正如本书中使用证明形式。我们讲声明放在一个叫做 <code>≡-Reasoning</code> 的模块里，与 Agda 标准库中的格式相对应。</p>
<pre class="Agda"><a id="6940" class="Keyword">module</a> <a id="≡-Reasoning"></a><a id="6947" href="../Equality/#6947" class="Module">≡-Reasoning</a> <a id="6959" class="Symbol">{</a><a id="6960" href="../Equality/#6960" class="Bound">A</a> <a id="6962" class="Symbol">:</a> <a id="6964" class="PrimitiveType">Set</a><a id="6967" class="Symbol">}</a> <a id="6969" class="Keyword">where</a>

  <a id="6978" class="Keyword">infix</a>  <a id="6985" class="Number">1</a> <a id="6987" href="../Equality/#7035" class="Function Operator">begin_</a>
  <a id="6996" class="Keyword">infixr</a> <a id="7003" class="Number">2</a> <a id="7005" href="../Equality/#7115" class="Function Operator">_≡⟨⟩_</a> <a id="7011" href="../Equality/#7200" class="Function Operator">_≡⟨_⟩_</a>
  <a id="7020" class="Keyword">infix</a>  <a id="7027" class="Number">3</a> <a id="7029" href="../Equality/#7315" class="Function Operator">_∎</a>

  <a id="≡-Reasoning.begin_"></a><a id="7035" href="../Equality/#7035" class="Function Operator">begin_</a> <a id="7042" class="Symbol">:</a> <a id="7044" class="Symbol">∀</a> <a id="7046" class="Symbol">{</a><a id="7047" href="../Equality/#7047" class="Bound">x</a> <a id="7049" href="../Equality/#7049" class="Bound">y</a> <a id="7051" class="Symbol">:</a> <a id="7053" href="../Equality/#6960" class="Bound">A</a><a id="7054" class="Symbol">}</a>
    <a id="7060" class="Symbol">→</a> <a id="7062" href="../Equality/#7047" class="Bound">x</a> <a id="7064" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="7066" href="../Equality/#7049" class="Bound">y</a>
      <a id="7074" class="Comment">-----</a>
    <a id="7084" class="Symbol">→</a> <a id="7086" href="../Equality/#7047" class="Bound">x</a> <a id="7088" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="7090" href="../Equality/#7049" class="Bound">y</a>
  <a id="7094" href="../Equality/#7035" class="Function Operator">begin</a> <a id="7100" href="../Equality/#7100" class="Bound">x≡y</a>  <a id="7105" class="Symbol">=</a>  <a id="7108" href="../Equality/#7100" class="Bound">x≡y</a>

  <a id="≡-Reasoning._≡⟨⟩_"></a><a id="7115" href="../Equality/#7115" class="Function Operator">_≡⟨⟩_</a> <a id="7121" class="Symbol">:</a> <a id="7123" class="Symbol">∀</a> <a id="7125" class="Symbol">(</a><a id="7126" href="../Equality/#7126" class="Bound">x</a> <a id="7128" class="Symbol">:</a> <a id="7130" href="../Equality/#6960" class="Bound">A</a><a id="7131" class="Symbol">)</a> <a id="7133" class="Symbol">{</a><a id="7134" href="../Equality/#7134" class="Bound">y</a> <a id="7136" class="Symbol">:</a> <a id="7138" href="../Equality/#6960" class="Bound">A</a><a id="7139" class="Symbol">}</a>
    <a id="7145" class="Symbol">→</a> <a id="7147" href="../Equality/#7126" class="Bound">x</a> <a id="7149" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="7151" href="../Equality/#7134" class="Bound">y</a>
      <a id="7159" class="Comment">-----</a>
    <a id="7169" class="Symbol">→</a> <a id="7171" href="../Equality/#7126" class="Bound">x</a> <a id="7173" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="7175" href="../Equality/#7134" class="Bound">y</a>
  <a id="7179" href="../Equality/#7179" class="Bound">x</a> <a id="7181" href="../Equality/#7115" class="Function Operator">≡⟨⟩</a> <a id="7185" href="../Equality/#7185" class="Bound">x≡y</a>  <a id="7190" class="Symbol">=</a>  <a id="7193" href="../Equality/#7185" class="Bound">x≡y</a>

  <a id="≡-Reasoning._≡⟨_⟩_"></a><a id="7200" href="../Equality/#7200" class="Function Operator">_≡⟨_⟩_</a> <a id="7207" class="Symbol">:</a> <a id="7209" class="Symbol">∀</a> <a id="7211" class="Symbol">(</a><a id="7212" href="../Equality/#7212" class="Bound">x</a> <a id="7214" class="Symbol">:</a> <a id="7216" href="../Equality/#6960" class="Bound">A</a><a id="7217" class="Symbol">)</a> <a id="7219" class="Symbol">{</a><a id="7220" href="../Equality/#7220" class="Bound">y</a> <a id="7222" href="../Equality/#7222" class="Bound">z</a> <a id="7224" class="Symbol">:</a> <a id="7226" href="../Equality/#6960" class="Bound">A</a><a id="7227" class="Symbol">}</a>
    <a id="7233" class="Symbol">→</a> <a id="7235" href="../Equality/#7212" class="Bound">x</a> <a id="7237" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="7239" href="../Equality/#7220" class="Bound">y</a>
    <a id="7245" class="Symbol">→</a> <a id="7247" href="../Equality/#7220" class="Bound">y</a> <a id="7249" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="7251" href="../Equality/#7222" class="Bound">z</a>
      <a id="7259" class="Comment">-----</a>
    <a id="7269" class="Symbol">→</a> <a id="7271" href="../Equality/#7212" class="Bound">x</a> <a id="7273" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="7275" href="../Equality/#7222" class="Bound">z</a>
  <a id="7279" href="../Equality/#7279" class="Bound">x</a> <a id="7281" href="../Equality/#7200" class="Function Operator">≡⟨</a> <a id="7284" href="../Equality/#7284" class="Bound">x≡y</a> <a id="7288" href="../Equality/#7200" class="Function Operator">⟩</a> <a id="7290" href="../Equality/#7290" class="Bound">y≡z</a>  <a id="7295" class="Symbol">=</a>  <a id="7298" href="../Equality/#5008" class="Function">trans</a> <a id="7304" href="../Equality/#7284" class="Bound">x≡y</a> <a id="7308" href="../Equality/#7290" class="Bound">y≡z</a>

  <a id="≡-Reasoning._∎"></a><a id="7315" href="../Equality/#7315" class="Function Operator">_∎</a> <a id="7318" class="Symbol">:</a> <a id="7320" class="Symbol">∀</a> <a id="7322" class="Symbol">(</a><a id="7323" href="../Equality/#7323" class="Bound">x</a> <a id="7325" class="Symbol">:</a> <a id="7327" href="../Equality/#6960" class="Bound">A</a><a id="7328" class="Symbol">)</a>
      <a id="7336" class="Comment">-----</a>
    <a id="7346" class="Symbol">→</a> <a id="7348" href="../Equality/#7323" class="Bound">x</a> <a id="7350" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="7352" href="../Equality/#7323" class="Bound">x</a>
  <a id="7356" href="../Equality/#7356" class="Bound">x</a> <a id="7358" href="../Equality/#7315" class="Function Operator">∎</a>  <a id="7361" class="Symbol">=</a>  <a id="7364" href="../Equality/#1059" class="InductiveConstructor">refl</a>

<a id="7370" class="Keyword">open</a> <a id="7375" href="../Equality/#6947" class="Module">≡-Reasoning</a>
</pre>
<!--
This is our first use of a nested module. It consists of the keyword
`module` followed by the module name and any parameters, explicit or
implicit, the keyword `where`, and the contents of the module indented.
Modules may contain any sort of declaration, including other nested modules.
Nested modules are similar to the top-level modules that constitute
each chapter of this book, save that the body of a top-level module
need not be indented.  Opening the module makes all of the definitions
available in the current environment.
-->
<p>这是我们第一次使用嵌套的模块。它包括了关键字 <code>module</code> 和后续的模块名、隐式或显式参数， 关键字 <code>where</code>，和模块中的内容（在缩进内）。模块里可以包括任何形式的声明，也可以包括其他模块。 嵌套的模块和本书每章节所定义的顶层模块相似，只是顶层模块不需要缩进。 打开（Open）一个模块会把模块内的所有定义导入进当前的环境中。</p>
<!--
As an example, let's look at a proof of transitivity
as a chain of equations:
-->
<p>举个例子，我们来看看如何用等式串证明传递性：</p>
<pre class="Agda"><a id="trans′"></a><a id="8220" href="../Equality/#8220" class="Function">trans′</a> <a id="8227" class="Symbol">:</a> <a id="8229" class="Symbol">∀</a> <a id="8231" class="Symbol">{</a><a id="8232" href="../Equality/#8232" class="Bound">A</a> <a id="8234" class="Symbol">:</a> <a id="8236" class="PrimitiveType">Set</a><a id="8239" class="Symbol">}</a> <a id="8241" class="Symbol">{</a><a id="8242" href="../Equality/#8242" class="Bound">x</a> <a id="8244" href="../Equality/#8244" class="Bound">y</a> <a id="8246" href="../Equality/#8246" class="Bound">z</a> <a id="8248" class="Symbol">:</a> <a id="8250" href="../Equality/#8232" class="Bound">A</a><a id="8251" class="Symbol">}</a>
  <a id="8255" class="Symbol">→</a> <a id="8257" href="../Equality/#8242" class="Bound">x</a> <a id="8259" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="8261" href="../Equality/#8244" class="Bound">y</a>
  <a id="8265" class="Symbol">→</a> <a id="8267" href="../Equality/#8244" class="Bound">y</a> <a id="8269" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="8271" href="../Equality/#8246" class="Bound">z</a>
    <a id="8277" class="Comment">-----</a>
  <a id="8285" class="Symbol">→</a> <a id="8287" href="../Equality/#8242" class="Bound">x</a> <a id="8289" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="8291" href="../Equality/#8246" class="Bound">z</a>
<a id="8293" href="../Equality/#8220" class="Function">trans′</a> <a id="8300" class="Symbol">{</a><a id="8301" href="../Equality/#8301" class="Bound">A</a><a id="8302" class="Symbol">}</a> <a id="8304" class="Symbol">{</a><a id="8305" href="../Equality/#8305" class="Bound">x</a><a id="8306" class="Symbol">}</a> <a id="8308" class="Symbol">{</a><a id="8309" href="../Equality/#8309" class="Bound">y</a><a id="8310" class="Symbol">}</a> <a id="8312" class="Symbol">{</a><a id="8313" href="../Equality/#8313" class="Bound">z</a><a id="8314" class="Symbol">}</a> <a id="8316" href="../Equality/#8316" class="Bound">x≡y</a> <a id="8320" href="../Equality/#8320" class="Bound">y≡z</a> <a id="8324" class="Symbol">=</a>
  <a id="8328" href="../Equality/#7035" class="Function Operator">begin</a>
    <a id="8338" href="../Equality/#8305" class="Bound">x</a>
  <a id="8342" href="../Equality/#7200" class="Function Operator">≡⟨</a> <a id="8345" href="../Equality/#8316" class="Bound">x≡y</a> <a id="8349" href="../Equality/#7200" class="Function Operator">⟩</a>
    <a id="8355" href="../Equality/#8309" class="Bound">y</a>
  <a id="8359" href="../Equality/#7200" class="Function Operator">≡⟨</a> <a id="8362" href="../Equality/#8320" class="Bound">y≡z</a> <a id="8366" href="../Equality/#7200" class="Function Operator">⟩</a>
    <a id="8372" href="../Equality/#8313" class="Bound">z</a>
  <a id="8376" href="../Equality/#7315" class="Function Operator">∎</a>
</pre>
<!--
According to the fixity declarations, the body parses as follows:
-->
<p>根据其定义，等式右边会被解析成如下：</p>
<pre><code>begin (x ≡⟨ x≡y ⟩ (y ≡⟨ y≡z ⟩ (z ∎)))</code></pre>
<!--
The application of `begin` is purely cosmetic, as it simply returns
its argument.  That argument consists of `_≡⟨_⟩_` applied to `x`,
`x≡y`, and `y ≡⟨ y≡z ⟩ (z ∎)`.  The first argument is a term, `x`,
while the second and third arguments are both proofs of equations, in
particular proofs of `x ≡ y` and `y ≡ z` respectively, which are
combined by `trans` in the body of `_≡⟨_⟩_` to yield a proof of `x ≡
z`.  The proof of `y ≡ z` consists of `_≡⟨_⟩_` applied to `y`, `y≡z`,
and `z ∎`.  The first argument is a term, `y`, while the second and
third arguments are both proofs of equations, in particular proofs of
`y ≡ z` and `z ≡ z` respectively, which are combined by `trans` in the
body of `_≡⟨_⟩_` to yield a proof of `y ≡ z`.  Finally, the proof of
`z ≡ z` consists of `_∎` applied to the term `z`, which yields `refl`.
After simplification, the body is equivalent to the term:
-->
<p>这里 <code>begin</code> 的使用纯粹是装饰性的，因为它直接返回了其参数。其参数包括了 <code>_≡⟨_⟩_</code> 作用于 <code>x</code>、<code>x≡y</code> 和 <code>y ≡⟨ y≡z ⟩ (z ∎)</code>。第一个参数是一个项 <code>x</code>， 而第二、第三个参数分别是等式 <code>x ≡ y</code>、<code>y ≡ z</code> 的证明，它们在 <code>_≡⟨_⟩_</code> 的定义中用 <code>trans</code> 连接起来，形成 <code>x ≡ z</code> 的证明。<code>y ≡ z</code> 的证明包括了 <code>_≡⟨_⟩_</code> 作用于 <code>y</code>、 <code>y≡z</code> 和 <code>z ∎</code>。第一个参数是一个项 <code>y</code>，而第二、第三个参数分别是等式 <code>y ≡ z</code>、<code>z ≡ z</code> 的证明， 它们在 <code>_≡⟨_⟩_</code> 的定义中用 <code>trans</code> 连接起来，形成 <code>y ≡ z</code> 的证明。最后，<code>z ≡ z</code> 的证明包括了 <code>_∎</code> 作用于 <code>z</code> 之上，使用了 <code>refl</code>。经过化简，上述定义等同于：</p>
<pre><code>trans x≡y (trans y≡z refl)</code></pre>
<!--
We could replace any use of a chain of equations by a chain of
applications of `trans`; the result would be more compact but harder
to read.  The trick behind `∎` means that a chain of equalities
simplifies to a chain of applications of `trans` that ends in `trans e
refl`, where `e` is a term that proves some equality, even though `e`
alone would do.
-->
<p>我们可以把任意等式串转化成一系列的 <code>trans</code> 的使用。这样的证明更加精简，但是更难以阅读。 <code>∎</code> 的小窍门意味着等式串化简成为的一系列 <code>trans</code> 会以 <code>trans e refl</code> 结尾，尽管只需要 <code>e</code> 就足够了，这里的 <code>e</code> 是等式的证明。</p>
<h4 id="exercise-trans-and--reasoning-practice">Exercise <code>trans</code> and <code>≡-Reasoning</code> (practice)</h4>
<p>Sadly, we cannot use the definition of trans’ using ≡-Reasoning as the definition for trans. Can you see why? (Hint: look at the definition of <code>_≡⟨_⟩_</code>)</p>
<pre class="Agda"><a id="10538" class="Comment">-- Your code goes here</a>
</pre>
<!--
## Chains of equations, another example
-->
<h2 id="等式串的另外一个例子">等式串的另外一个例子</h2>
<!--
As a second example of chains of equations, we repeat the proof that addition
is commutative.  We first repeat the definitions of naturals and addition.
We cannot import them because (as noted at the beginning of this chapter)
it would cause a conflict:
-->
<p>我们重新证明加法的交换律来作为等式串的第二个例子。我们首先重复自然数和加法的定义。 我们不能导入它们（正如本章节开头中所解释的那样），因为那样会产生一个冲突：</p>
<pre class="Agda"><a id="10980" class="Keyword">data</a> <a id="ℕ"></a><a id="10985" href="../Equality/#10985" class="Datatype">ℕ</a> <a id="10987" class="Symbol">:</a> <a id="10989" class="PrimitiveType">Set</a> <a id="10993" class="Keyword">where</a>
  <a id="ℕ.zero"></a><a id="11001" href="../Equality/#11001" class="InductiveConstructor">zero</a> <a id="11006" class="Symbol">:</a> <a id="11008" href="../Equality/#10985" class="Datatype">ℕ</a>
  <a id="ℕ.suc"></a><a id="11012" href="../Equality/#11012" class="InductiveConstructor">suc</a>  <a id="11017" class="Symbol">:</a> <a id="11019" href="../Equality/#10985" class="Datatype">ℕ</a> <a id="11021" class="Symbol">→</a> <a id="11023" href="../Equality/#10985" class="Datatype">ℕ</a>

<a id="_+_"></a><a id="11026" href="../Equality/#11026" class="Function Operator">_+_</a> <a id="11030" class="Symbol">:</a> <a id="11032" href="../Equality/#10985" class="Datatype">ℕ</a> <a id="11034" class="Symbol">→</a> <a id="11036" href="../Equality/#10985" class="Datatype">ℕ</a> <a id="11038" class="Symbol">→</a> <a id="11040" href="../Equality/#10985" class="Datatype">ℕ</a>
<a id="11042" href="../Equality/#11001" class="InductiveConstructor">zero</a>    <a id="11050" href="../Equality/#11026" class="Function Operator">+</a> <a id="11052" href="../Equality/#11052" class="Bound">n</a>  <a id="11055" class="Symbol">=</a>  <a id="11058" href="../Equality/#11052" class="Bound">n</a>
<a id="11060" class="Symbol">(</a><a id="11061" href="../Equality/#11012" class="InductiveConstructor">suc</a> <a id="11065" href="../Equality/#11065" class="Bound">m</a><a id="11066" class="Symbol">)</a> <a id="11068" href="../Equality/#11026" class="Function Operator">+</a> <a id="11070" href="../Equality/#11070" class="Bound">n</a>  <a id="11073" class="Symbol">=</a>  <a id="11076" href="../Equality/#11012" class="InductiveConstructor">suc</a> <a id="11080" class="Symbol">(</a><a id="11081" href="../Equality/#11065" class="Bound">m</a> <a id="11083" href="../Equality/#11026" class="Function Operator">+</a> <a id="11085" href="../Equality/#11070" class="Bound">n</a><a id="11086" class="Symbol">)</a>
</pre>
<!--
To save space we postulate (rather than prove in full) two lemmas:
-->
<p>为了节约空间，我们假设两条引理（而不是证明它们）：</p>
<pre class="Agda"><a id="11201" class="Keyword">postulate</a>
  <a id="+-identity"></a><a id="11213" href="../Equality/#11213" class="Postulate">+-identity</a> <a id="11224" class="Symbol">:</a> <a id="11226" class="Symbol">∀</a> <a id="11228" class="Symbol">(</a><a id="11229" href="../Equality/#11229" class="Bound">m</a> <a id="11231" class="Symbol">:</a> <a id="11233" href="../Equality/#10985" class="Datatype">ℕ</a><a id="11234" class="Symbol">)</a> <a id="11236" class="Symbol">→</a> <a id="11238" href="../Equality/#11229" class="Bound">m</a> <a id="11240" href="../Equality/#11026" class="Function Operator">+</a> <a id="11242" href="../Equality/#11001" class="InductiveConstructor">zero</a> <a id="11247" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="11249" href="../Equality/#11229" class="Bound">m</a>
  <a id="+-suc"></a><a id="11253" href="../Equality/#11253" class="Postulate">+-suc</a> <a id="11259" class="Symbol">:</a> <a id="11261" class="Symbol">∀</a> <a id="11263" class="Symbol">(</a><a id="11264" href="../Equality/#11264" class="Bound">m</a> <a id="11266" href="../Equality/#11266" class="Bound">n</a> <a id="11268" class="Symbol">:</a> <a id="11270" href="../Equality/#10985" class="Datatype">ℕ</a><a id="11271" class="Symbol">)</a> <a id="11273" class="Symbol">→</a> <a id="11275" href="../Equality/#11264" class="Bound">m</a> <a id="11277" href="../Equality/#11026" class="Function Operator">+</a> <a id="11279" href="../Equality/#11012" class="InductiveConstructor">suc</a> <a id="11283" href="../Equality/#11266" class="Bound">n</a> <a id="11285" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="11287" href="../Equality/#11012" class="InductiveConstructor">suc</a> <a id="11291" class="Symbol">(</a><a id="11292" href="../Equality/#11264" class="Bound">m</a> <a id="11294" href="../Equality/#11026" class="Function Operator">+</a> <a id="11296" href="../Equality/#11266" class="Bound">n</a><a id="11297" class="Symbol">)</a>
</pre>
<!--
This is our first use of a _postulate_.  A postulate specifies a
signature for an identifier but no definition.  Here we postulate
something proved earlier to save space.  Postulates must be used with
caution.  If we postulate something false then we could use Agda to
prove anything whatsoever.
-->
<p>这是我们第一次使用<em>假设</em>（Postulate）。假设为一个标识符指定一个签名，但是不提供定义。 我们在这里假设之前证明过的东西，来节约空间。假设在使用时必须加以注意。如果假设的内容为假， 那么我们可以证明出任何东西。</p>
<!--
We then repeat the proof of commutativity:
-->
<p>我们接下来重复交换律的证明：</p>
<pre class="Agda"><a id="+-comm"></a><a id="11794" href="../Equality/#11794" class="Function">+-comm</a> <a id="11801" class="Symbol">:</a> <a id="11803" class="Symbol">∀</a> <a id="11805" class="Symbol">(</a><a id="11806" href="../Equality/#11806" class="Bound">m</a> <a id="11808" href="../Equality/#11808" class="Bound">n</a> <a id="11810" class="Symbol">:</a> <a id="11812" href="../Equality/#10985" class="Datatype">ℕ</a><a id="11813" class="Symbol">)</a> <a id="11815" class="Symbol">→</a> <a id="11817" href="../Equality/#11806" class="Bound">m</a> <a id="11819" href="../Equality/#11026" class="Function Operator">+</a> <a id="11821" href="../Equality/#11808" class="Bound">n</a> <a id="11823" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="11825" href="../Equality/#11808" class="Bound">n</a> <a id="11827" href="../Equality/#11026" class="Function Operator">+</a> <a id="11829" href="../Equality/#11806" class="Bound">m</a>
<a id="11831" href="../Equality/#11794" class="Function">+-comm</a> <a id="11838" href="../Equality/#11838" class="Bound">m</a> <a id="11840" href="../Equality/#11001" class="InductiveConstructor">zero</a> <a id="11845" class="Symbol">=</a>
  <a id="11849" href="../Equality/#7035" class="Function Operator">begin</a>
    <a id="11859" href="../Equality/#11838" class="Bound">m</a> <a id="11861" href="../Equality/#11026" class="Function Operator">+</a> <a id="11863" href="../Equality/#11001" class="InductiveConstructor">zero</a>
  <a id="11870" href="../Equality/#7200" class="Function Operator">≡⟨</a> <a id="11873" href="../Equality/#11213" class="Postulate">+-identity</a> <a id="11884" href="../Equality/#11838" class="Bound">m</a> <a id="11886" href="../Equality/#7200" class="Function Operator">⟩</a>
    <a id="11892" href="../Equality/#11838" class="Bound">m</a>
  <a id="11896" href="../Equality/#7115" class="Function Operator">≡⟨⟩</a>
    <a id="11904" href="../Equality/#11001" class="InductiveConstructor">zero</a> <a id="11909" href="../Equality/#11026" class="Function Operator">+</a> <a id="11911" href="../Equality/#11838" class="Bound">m</a>
  <a id="11915" href="../Equality/#7315" class="Function Operator">∎</a>
<a id="11917" href="../Equality/#11794" class="Function">+-comm</a> <a id="11924" href="../Equality/#11924" class="Bound">m</a> <a id="11926" class="Symbol">(</a><a id="11927" href="../Equality/#11012" class="InductiveConstructor">suc</a> <a id="11931" href="../Equality/#11931" class="Bound">n</a><a id="11932" class="Symbol">)</a> <a id="11934" class="Symbol">=</a>
  <a id="11938" href="../Equality/#7035" class="Function Operator">begin</a>
    <a id="11948" href="../Equality/#11924" class="Bound">m</a> <a id="11950" href="../Equality/#11026" class="Function Operator">+</a> <a id="11952" href="../Equality/#11012" class="InductiveConstructor">suc</a> <a id="11956" href="../Equality/#11931" class="Bound">n</a>
  <a id="11960" href="../Equality/#7200" class="Function Operator">≡⟨</a> <a id="11963" href="../Equality/#11253" class="Postulate">+-suc</a> <a id="11969" href="../Equality/#11924" class="Bound">m</a> <a id="11971" href="../Equality/#11931" class="Bound">n</a> <a id="11973" href="../Equality/#7200" class="Function Operator">⟩</a>
    <a id="11979" href="../Equality/#11012" class="InductiveConstructor">suc</a> <a id="11983" class="Symbol">(</a><a id="11984" href="../Equality/#11924" class="Bound">m</a> <a id="11986" href="../Equality/#11026" class="Function Operator">+</a> <a id="11988" href="../Equality/#11931" class="Bound">n</a><a id="11989" class="Symbol">)</a>
  <a id="11993" href="../Equality/#7200" class="Function Operator">≡⟨</a> <a id="11996" href="../Equality/#5591" class="Function">cong</a> <a id="12001" href="../Equality/#11012" class="InductiveConstructor">suc</a> <a id="12005" class="Symbol">(</a><a id="12006" href="../Equality/#11794" class="Function">+-comm</a> <a id="12013" href="../Equality/#11924" class="Bound">m</a> <a id="12015" href="../Equality/#11931" class="Bound">n</a><a id="12016" class="Symbol">)</a> <a id="12018" href="../Equality/#7200" class="Function Operator">⟩</a>
    <a id="12024" href="../Equality/#11012" class="InductiveConstructor">suc</a> <a id="12028" class="Symbol">(</a><a id="12029" href="../Equality/#11931" class="Bound">n</a> <a id="12031" href="../Equality/#11026" class="Function Operator">+</a> <a id="12033" href="../Equality/#11924" class="Bound">m</a><a id="12034" class="Symbol">)</a>
  <a id="12038" href="../Equality/#7115" class="Function Operator">≡⟨⟩</a>
    <a id="12046" href="../Equality/#11012" class="InductiveConstructor">suc</a> <a id="12050" href="../Equality/#11931" class="Bound">n</a> <a id="12052" href="../Equality/#11026" class="Function Operator">+</a> <a id="12054" href="../Equality/#11924" class="Bound">m</a>
  <a id="12058" href="../Equality/#7315" class="Function Operator">∎</a>
</pre>
<!--
The reasoning here is similar to that in the
preceding section.  We use
`_≡⟨⟩_` when no justification is required.
One can think of `_≡⟨⟩_` as equivalent to `_≡⟨ refl ⟩_`.
-->
<p>论证的过程和之前的相似。我们在不需要解释的地方使用 <code>_≡⟨⟩_</code>，我们可以认为 <code>_≡⟨⟩_</code> 和 <code>_≡⟨ refl ⟩_</code> 是等价的。</p>
<!--
Agda always treats a term as equivalent to its
simplified term.  The reason that one can write
-->
<p>Agda 总是认为一个项与其化简的项是等价的。我们之所以可以写出</p>
<pre><code>  suc (n + m)
≡⟨⟩
  suc n + m</code></pre>
<!--
is because Agda treats both terms as the same.
This also means that one could instead interchange
the lines and write
-->
<p>是因为 Agda 认为它们是一样的。这也意味着我们可以交换两行的顺序，写出</p>
<pre><code>  suc n + m
≡⟨⟩
  suc (n + m)</code></pre>
<!--
and Agda would not object. Agda only checks that the terms separated
by `≡⟨⟩` have the same simplified form; it's up to us to write them in
an order that will make sense to the reader.
-->
<p>而 Agda 并不会反对。Agda 只会检查由 <code>≡⟨⟩</code> 隔开的项是否化简后相同。 而书写的顺序合不合理则是由我们自行决定。</p>
<!--
#### Exercise `≤-Reasoning` (stretch)
-->
<h4 id="练习--reasoning-延伸">练习 <code>≤-Reasoning</code> (延伸)</h4>
<!--
The proof of monotonicity from
Chapter [Relations](/Relations/)
can be written in a more readable form by using an analogue of our
notation for `≡-Reasoning`.  Define `≤-Reasoning` analogously, and use
it to write out an alternative proof that addition is monotonic with
regard to inequality.  Rewrite all of `+-monoˡ-≤`, `+-monoʳ-≤`, and `+-mono-≤`.
-->
<p><a href="../Relations/">Relations</a> 章节中的单调性证明亦可以用相似于 <code>≡-Reasoning</code> 的，更易于理解的形式给出。 相似地来定义 <code>≤-Reasoning</code>，并用其重新给出加法对于不等式是单调的证明。重写 <code>+-monoˡ-≤</code>、<code>+-monoʳ-≤</code> 和 <code>+-mono-≤</code>。</p>
<!--
<pre class="Agda"><a id="13572" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="13608" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
## Rewriting
-->
<h2 id="重写">重写</h2>
<!--
Consider a property of natural numbers, such as being even.
We repeat the earlier definition:
-->
<p>考虑一个自然数的性质，比如说一个数是偶数。我们重复之前给出的定义：</p>
<pre class="Agda"><a id="13800" class="Keyword">data</a> <a id="even"></a><a id="13805" href="../Equality/#13805" class="Datatype">even</a> <a id="13810" class="Symbol">:</a> <a id="13812" href="../Equality/#10985" class="Datatype">ℕ</a> <a id="13814" class="Symbol">→</a> <a id="13816" class="PrimitiveType">Set</a>
<a id="13820" class="Keyword">data</a> <a id="odd"></a><a id="13825" href="../Equality/#13825" class="Datatype">odd</a>  <a id="13830" class="Symbol">:</a> <a id="13832" href="../Equality/#10985" class="Datatype">ℕ</a> <a id="13834" class="Symbol">→</a> <a id="13836" class="PrimitiveType">Set</a>

<a id="13841" class="Keyword">data</a> <a id="13846" href="../Equality/#13805" class="Datatype">even</a> <a id="13851" class="Keyword">where</a>

  <a id="even.even-zero"></a><a id="13860" href="../Equality/#13860" class="InductiveConstructor">even-zero</a> <a id="13870" class="Symbol">:</a> <a id="13872" href="../Equality/#13805" class="Datatype">even</a> <a id="13877" href="../Equality/#11001" class="InductiveConstructor">zero</a>

  <a id="even.even-suc"></a><a id="13885" href="../Equality/#13885" class="InductiveConstructor">even-suc</a> <a id="13894" class="Symbol">:</a> <a id="13896" class="Symbol">∀</a> <a id="13898" class="Symbol">{</a><a id="13899" href="../Equality/#13899" class="Bound">n</a> <a id="13901" class="Symbol">:</a> <a id="13903" href="../Equality/#10985" class="Datatype">ℕ</a><a id="13904" class="Symbol">}</a>
    <a id="13910" class="Symbol">→</a> <a id="13912" href="../Equality/#13825" class="Datatype">odd</a> <a id="13916" href="../Equality/#13899" class="Bound">n</a>
      <a id="13924" class="Comment">------------</a>
    <a id="13941" class="Symbol">→</a> <a id="13943" href="../Equality/#13805" class="Datatype">even</a> <a id="13948" class="Symbol">(</a><a id="13949" href="../Equality/#11012" class="InductiveConstructor">suc</a> <a id="13953" href="../Equality/#13899" class="Bound">n</a><a id="13954" class="Symbol">)</a>

<a id="13957" class="Keyword">data</a> <a id="13962" href="../Equality/#13825" class="Datatype">odd</a> <a id="13966" class="Keyword">where</a>
  <a id="odd.odd-suc"></a><a id="13974" href="../Equality/#13974" class="InductiveConstructor">odd-suc</a> <a id="13982" class="Symbol">:</a> <a id="13984" class="Symbol">∀</a> <a id="13986" class="Symbol">{</a><a id="13987" href="../Equality/#13987" class="Bound">n</a> <a id="13989" class="Symbol">:</a> <a id="13991" href="../Equality/#10985" class="Datatype">ℕ</a><a id="13992" class="Symbol">}</a>
    <a id="13998" class="Symbol">→</a> <a id="14000" href="../Equality/#13805" class="Datatype">even</a> <a id="14005" href="../Equality/#13987" class="Bound">n</a>
      <a id="14013" class="Comment">-----------</a>
    <a id="14029" class="Symbol">→</a> <a id="14031" href="../Equality/#13825" class="Datatype">odd</a> <a id="14035" class="Symbol">(</a><a id="14036" href="../Equality/#11012" class="InductiveConstructor">suc</a> <a id="14040" href="../Equality/#13987" class="Bound">n</a><a id="14041" class="Symbol">)</a>
</pre>
<!--
In the previous section, we proved addition is commutative.  Given
evidence that `even (m + n)` holds, we ought also to be able to take
that as evidence that `even (n + m)` holds.
-->
<p>在前面的部分中，我们证明了加法满足交换律。给定 <code>even (m + n)</code> 成立的证据，我们应当可以用它来做 <code>even (n + m)</code> 成立的证据。</p>
<!--
Agda includes special notation to support just this kind of reasoning,
the `rewrite` notation we encountered earlier.
To enable this notation, we use pragmas to tell Agda which type
corresponds to equality:
-->
<p>Agda 对这种论证有特殊记法的支持——我们之前提到过的 <code>rewrite</code> 记法。来启用这种记法， 我们只用编译程序指令来告诉 Agda 什么类型对应相等性：</p>
<pre class="Agda"><a id="14620" class="Symbol">{-#</a> <a id="14624" class="Keyword">BUILTIN</a> <a id="14632" class="Keyword">EQUALITY</a> <a id="14641" href="../Equality/#1019" class="Datatype Operator">_≡_</a> <a id="14645" class="Symbol">#-}</a>
</pre>
<!--
We can then prove the desired property as follows:
-->
<p>我们然后就可以如下证明求证的性质：</p>
<pre class="Agda"><a id="even-comm"></a><a id="14738" href="../Equality/#14738" class="Function">even-comm</a> <a id="14748" class="Symbol">:</a> <a id="14750" class="Symbol">∀</a> <a id="14752" class="Symbol">(</a><a id="14753" href="../Equality/#14753" class="Bound">m</a> <a id="14755" href="../Equality/#14755" class="Bound">n</a> <a id="14757" class="Symbol">:</a> <a id="14759" href="../Equality/#10985" class="Datatype">ℕ</a><a id="14760" class="Symbol">)</a>
  <a id="14764" class="Symbol">→</a> <a id="14766" href="../Equality/#13805" class="Datatype">even</a> <a id="14771" class="Symbol">(</a><a id="14772" href="../Equality/#14753" class="Bound">m</a> <a id="14774" href="../Equality/#11026" class="Function Operator">+</a> <a id="14776" href="../Equality/#14755" class="Bound">n</a><a id="14777" class="Symbol">)</a>
    <a id="14783" class="Comment">------------</a>
  <a id="14798" class="Symbol">→</a> <a id="14800" href="../Equality/#13805" class="Datatype">even</a> <a id="14805" class="Symbol">(</a><a id="14806" href="../Equality/#14755" class="Bound">n</a> <a id="14808" href="../Equality/#11026" class="Function Operator">+</a> <a id="14810" href="../Equality/#14753" class="Bound">m</a><a id="14811" class="Symbol">)</a>
<a id="14813" href="../Equality/#14738" class="Function">even-comm</a> <a id="14823" href="../Equality/#14823" class="Bound">m</a> <a id="14825" href="../Equality/#14825" class="Bound">n</a> <a id="14827" href="../Equality/#14827" class="Bound">ev</a>  <a id="14831" class="Keyword">rewrite</a> <a id="14839" href="../Equality/#11794" class="Function">+-comm</a> <a id="14846" href="../Equality/#14825" class="Bound">n</a> <a id="14848" href="../Equality/#14823" class="Bound">m</a>  <a id="14851" class="Symbol">=</a>  <a id="14854" href="../Equality/#14827" class="Bound">ev</a>
</pre>
<!--
Here `ev` ranges over evidence that `even (m + n)` holds, and we show
that it also provides evidence that `even (n + m)` holds.  In
general, the keyword `rewrite` is followed by evidence of an
equality, and that equality is used to rewrite the type of the
goal and of any variable in scope.
-->
<p>在这里，<code>ev</code> 包括了所有 <code>even (m + n)</code> 成立的证据，我们证明它亦可作为 <code>even (n + m)</code> 成立的证据。一般来说，关键字 <code>rewrite</code> 之后跟着一个等式的证明，这个等式被用于重写目标和任意作用域内变量的类型。</p>
<!--
It is instructive to develop `even-comm` interactively.  To start, we
supply variables for the arguments on the left, and a hole for the
body on the right:
-->
<p>交互性地证明 <code>even-comm</code> 是很有帮助的。一开始，我们先给左边的参数赋予变量，给右手边放上一个洞：</p>
<pre><code>even-comm : ∀ (m n : ℕ)
  → even (m + n)
    ------------
  → even (n + m)
even-comm m n ev = {! !}</code></pre>
<!--
If we go into the hole and type `C-c C-,` then Agda reports:
-->
<p>如果我们进入洞里，输入 <code>C-c C-,</code>，Agda 会报告：</p>
<pre><code>Goal: even (n + m)
————————————————————————————————————————————————————————————
ev : even (m + n)
n  : ℕ
m  : ℕ</code></pre>
<!--
Now we add the rewrite:
-->
<p>现在我们加入重写：</p>
<pre><code>even-comm : ∀ (m n : ℕ)
  → even (m + n)
    ------------
  → even (n + m)
even-comm m n ev rewrite +-comm n m = {! !}</code></pre>
<!--
If we go into the hole again and type `C-c C-,` then Agda now reports:
-->
<p>如果我们再次进入洞里，并输入 <code>C-c C-,</code>，Agda 现在会报告：</p>
<pre><code>Goal: even (m + n)
————————————————————————————————————————————————————————————
ev : even (m + n)
n  : ℕ
m  : ℕ</code></pre>
<!--
The arguments have been swapped in the goal.  Now it is trivial to see
that `ev` satisfies the goal, and typing `C-c C-a` in the hole causes
it to be filled with `ev`.  The command `C-c C-a` performs an
automated search, including checking whether a variable in scope has
the same type as the goal.
-->
<p>目标里的参数被交换了。现在 <code>ev</code> 显然满足目标条件，输入 <code>C-c C-a</code> 会用 <code>ev</code> 来填充这个洞。 命令 <code>C-c C-a</code> 可以进行自动搜索，检查作用域内的变量是否和目标有相同的类型。</p>
<!--
## Multiple rewrites
-->
<h2 id="多重重写">多重重写</h2>
<!--
One may perform multiple rewrites, each separated by a vertical bar.  For instance,
here is a second proof that addition is commutative, relying on rewrites rather
than chains of equalities:
-->
<p>我们可以多次使用重写，以竖线隔开。举个例子，这里是加法交换律的第二个证明，使用重写而不是等式串：</p>
<pre class="Agda"><a id="+-comm′"></a><a id="17011" href="../Equality/#17011" class="Function">+-comm′</a> <a id="17019" class="Symbol">:</a> <a id="17021" class="Symbol">∀</a> <a id="17023" class="Symbol">(</a><a id="17024" href="../Equality/#17024" class="Bound">m</a> <a id="17026" href="../Equality/#17026" class="Bound">n</a> <a id="17028" class="Symbol">:</a> <a id="17030" href="../Equality/#10985" class="Datatype">ℕ</a><a id="17031" class="Symbol">)</a> <a id="17033" class="Symbol">→</a> <a id="17035" href="../Equality/#17024" class="Bound">m</a> <a id="17037" href="../Equality/#11026" class="Function Operator">+</a> <a id="17039" href="../Equality/#17026" class="Bound">n</a> <a id="17041" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="17043" href="../Equality/#17026" class="Bound">n</a> <a id="17045" href="../Equality/#11026" class="Function Operator">+</a> <a id="17047" href="../Equality/#17024" class="Bound">m</a>
<a id="17049" href="../Equality/#17011" class="Function">+-comm′</a> <a id="17057" href="../Equality/#11001" class="InductiveConstructor">zero</a>    <a id="17065" href="../Equality/#17065" class="Bound">n</a>  <a id="17068" class="Keyword">rewrite</a> <a id="17076" href="../Equality/#11213" class="Postulate">+-identity</a> <a id="17087" href="../Equality/#17065" class="Bound">n</a>             <a id="17101" class="Symbol">=</a>  <a id="17104" href="../Equality/#1059" class="InductiveConstructor">refl</a>
<a id="17109" href="../Equality/#17011" class="Function">+-comm′</a> <a id="17117" class="Symbol">(</a><a id="17118" href="../Equality/#11012" class="InductiveConstructor">suc</a> <a id="17122" href="../Equality/#17122" class="Bound">m</a><a id="17123" class="Symbol">)</a> <a id="17125" href="../Equality/#17125" class="Bound">n</a>  <a id="17128" class="Keyword">rewrite</a> <a id="17136" href="../Equality/#11253" class="Postulate">+-suc</a> <a id="17142" href="../Equality/#17125" class="Bound">n</a> <a id="17144" href="../Equality/#17122" class="Bound">m</a> <a id="17146" class="Symbol">|</a> <a id="17148" href="../Equality/#17011" class="Function">+-comm′</a> <a id="17156" href="../Equality/#17122" class="Bound">m</a> <a id="17158" href="../Equality/#17125" class="Bound">n</a>  <a id="17161" class="Symbol">=</a>  <a id="17164" href="../Equality/#1059" class="InductiveConstructor">refl</a>
</pre>
<!--
This is far more compact.  Among other things, whereas the previous
proof required `cong suc (+-comm m n)` as the justification to invoke
the inductive hypothesis, here it is sufficient to rewrite with
`+-comm m n`, as rewriting automatically takes congruence into
account.  Although proofs with rewriting are shorter, proofs as chains
of equalities are easier to follow, and we will stick with the latter
when feasible.
-->
<p>这个证明更加的简短。之前的证明用 <code>cong suc (+-comm m n)</code> 作为使用归纳假设的说明， 而这里我们使用 <code>+-comm m n</code> 来重写就足够了，因为重写可以将合同性考虑在其中。尽管使用重写的证明更加的简短， 使用等式串的证明能容易理解，我们将尽可能的使用后者。</p>
<!--
## Rewriting expanded
-->
<h2 id="深入重写">深入重写</h2>
<!--
The `rewrite` notation is in fact shorthand for an appropriate use of `with`
abstraction:
-->
<p><code>rewrite</code> 记法实际上是 <code>with</code> 抽象的一种应用：</p>
<pre class="Agda"><a id="even-comm′"></a><a id="17928" href="../Equality/#17928" class="Function">even-comm′</a> <a id="17939" class="Symbol">:</a> <a id="17941" class="Symbol">∀</a> <a id="17943" class="Symbol">(</a><a id="17944" href="../Equality/#17944" class="Bound">m</a> <a id="17946" href="../Equality/#17946" class="Bound">n</a> <a id="17948" class="Symbol">:</a> <a id="17950" href="../Equality/#10985" class="Datatype">ℕ</a><a id="17951" class="Symbol">)</a>
  <a id="17955" class="Symbol">→</a> <a id="17957" href="../Equality/#13805" class="Datatype">even</a> <a id="17962" class="Symbol">(</a><a id="17963" href="../Equality/#17944" class="Bound">m</a> <a id="17965" href="../Equality/#11026" class="Function Operator">+</a> <a id="17967" href="../Equality/#17946" class="Bound">n</a><a id="17968" class="Symbol">)</a>
    <a id="17974" class="Comment">------------</a>
  <a id="17989" class="Symbol">→</a> <a id="17991" href="../Equality/#13805" class="Datatype">even</a> <a id="17996" class="Symbol">(</a><a id="17997" href="../Equality/#17946" class="Bound">n</a> <a id="17999" href="../Equality/#11026" class="Function Operator">+</a> <a id="18001" href="../Equality/#17944" class="Bound">m</a><a id="18002" class="Symbol">)</a>
<a id="18004" href="../Equality/#17928" class="Function">even-comm′</a> <a id="18015" href="../Equality/#18015" class="Bound">m</a> <a id="18017" href="../Equality/#18017" class="Bound">n</a> <a id="18019" href="../Equality/#18019" class="Bound">ev</a> <a id="18022" class="Keyword">with</a>   <a id="18029" href="../Equality/#18015" class="Bound">m</a> <a id="18031" href="../Equality/#11026" class="Function Operator">+</a> <a id="18033" href="../Equality/#18017" class="Bound">n</a>  <a id="18036" class="Symbol">|</a> <a id="18038" href="../Equality/#11794" class="Function">+-comm</a> <a id="18045" href="../Equality/#18015" class="Bound">m</a> <a id="18047" href="../Equality/#18017" class="Bound">n</a>
<a id="18049" class="Symbol">...</a>                  <a id="18070" class="Symbol">|</a> <a id="18072" class="DottedPattern Symbol">.(</a><a id="18074" class="DottedPattern Bound">n</a> <a id="18076" href="../Equality/#11026" class="DottedPattern Function Operator">+</a> <a id="18078" class="DottedPattern Bound">m</a><a id="18079" class="DottedPattern Symbol">)</a> <a id="18081" class="Symbol">|</a> <a id="18083" href="../Equality/#1059" class="InductiveConstructor">refl</a>       <a id="18094" class="Symbol">=</a> <a id="18096" class="Bound">ev</a>
</pre>
<!--
In general, one can follow `with` by any number of expressions,
separated by bars, where each following equation has the same number
of patterns.  We often write expressions and the corresponding
patterns so they line up in columns, as above. Here the first column
asserts that `m + n` and `n + m` are identical, and the second column
justifies that assertion with evidence of the appropriate equality.
Note also the use of the _dot pattern_, `.(n + m)`.  A dot pattern
consists of a dot followed by an expression, and is used when other
information forces the value matched to be equal to the value of the
expression in the dot pattern.  In this case, the identification of
`m + n` and `n + m` is justified by the subsequent matching of
`+-comm m n` against `refl`.  One might think that the first clause is
redundant as the information is inherent in the second clause, but in
fact Agda is rather picky on this point: omitting the first clause or
reversing the order of the clauses will cause Agda to report an error.
(Try it and see!)
-->
<p>总的来着，我们可以在 <code>with</code> 后面跟上任何数量的表达式，用竖线分隔开，并且在每个等式中使用相同个数的模式。 我们经常将表达式和模式如上对齐。这个第一列表明了 <code>m + n</code> 和 <code>n + m</code> 是相同的，第二列使用相应等式来证明的前述的断言。 注意在这里使用的<em>点模式</em>（Dot Pattern），<code>.(n + m)</code>。点模式由一个点和一个表达式组成， 在其他信息迫使这个值和点模式中的值相等时使用。在这里，<code>m + n</code> 和 <code>n + m</code> 由后续的 <code>+-comm m n</code> 与 <code>refl</code> 的匹配来识别。我们可能会认为第一种情况是多余的，因为第二种情况中才蕴涵了需要的信息。 但实际上 Agda 在这件事上很挑剔——省略第一条或者更换顺序会让 Agda 报告一个错误。（试一试你就知道！）</p>
<!--
In this case, we can avoid rewrite by simply applying the substitution
function defined earlier:
-->
<p>在这种情况中，我们也可以使用之前定义的替换函数来避免使用重写：</p>
<pre class="Agda"><a id="even-comm″"></a><a id="19649" href="../Equality/#19649" class="Function">even-comm″</a> <a id="19660" class="Symbol">:</a> <a id="19662" class="Symbol">∀</a> <a id="19664" class="Symbol">(</a><a id="19665" href="../Equality/#19665" class="Bound">m</a> <a id="19667" href="../Equality/#19667" class="Bound">n</a> <a id="19669" class="Symbol">:</a> <a id="19671" href="../Equality/#10985" class="Datatype">ℕ</a><a id="19672" class="Symbol">)</a>
  <a id="19676" class="Symbol">→</a> <a id="19678" href="../Equality/#13805" class="Datatype">even</a> <a id="19683" class="Symbol">(</a><a id="19684" href="../Equality/#19665" class="Bound">m</a> <a id="19686" href="../Equality/#11026" class="Function Operator">+</a> <a id="19688" href="../Equality/#19667" class="Bound">n</a><a id="19689" class="Symbol">)</a>
    <a id="19695" class="Comment">------------</a>
  <a id="19710" class="Symbol">→</a> <a id="19712" href="../Equality/#13805" class="Datatype">even</a> <a id="19717" class="Symbol">(</a><a id="19718" href="../Equality/#19667" class="Bound">n</a> <a id="19720" href="../Equality/#11026" class="Function Operator">+</a> <a id="19722" href="../Equality/#19665" class="Bound">m</a><a id="19723" class="Symbol">)</a>
<a id="19725" href="../Equality/#19649" class="Function">even-comm″</a> <a id="19736" href="../Equality/#19736" class="Bound">m</a> <a id="19738" href="../Equality/#19738" class="Bound">n</a>  <a id="19741" class="Symbol">=</a>  <a id="19744" href="../Equality/#6485" class="Function">subst</a> <a id="19750" href="../Equality/#13805" class="Datatype">even</a> <a id="19755" class="Symbol">(</a><a id="19756" href="../Equality/#11794" class="Function">+-comm</a> <a id="19763" href="../Equality/#19736" class="Bound">m</a> <a id="19765" href="../Equality/#19738" class="Bound">n</a><a id="19766" class="Symbol">)</a>
</pre>
<!--
Nonetheless, rewrite is a vital part of the Agda toolkit.  We will use
it sparingly, but it is occasionally essential.
-->
<p>尽管如此，重写是 Agda 工具箱中很重要的一部分。我们会偶尔使用它，但是它有的时候是必要的。</p>
<!--
## Leibniz equality
-->
<h2 id="莱布尼兹leibniz相等性">莱布尼兹（Leibniz）相等性</h2>
<!--
The form of asserting equality that we have used is due to Martin-Löf,
and was published in 1975.  An older form is due to Leibniz, and
was published in 1686.  Leibniz asserted the _identity of
indiscernibles_: two objects are equal if and only if they satisfy the
same properties. This principle sometimes goes by the name Leibniz'
Law, and is closely related to Spock's Law, "A difference that makes
no difference is no difference".  Here we define Leibniz equality,
and show that two terms satisfy Leibniz equality if and only if they
satisfy Martin-Löf equality.
-->
<p>我们使用的相等性断言的形式源于 Martin-Löf，于 1975 年发表。一个更早的形式源于莱布尼兹， 于 1686 年发表。莱布尼兹断言的相等性表示<em>不可分辨的实体</em>（Identity of Indiscernibles）： 两个对象相等当且仅当它们满足完全相同的性质。这条原理有时被称作莱布尼兹定律（Leibniz’ Law）， 与史波克定律紧密相关：“一个不造成区别的区别不是区别”。我们在这里定义莱布尼兹相等性， 并证明两个项满足莱布尼兹相等性当且仅当其满足 Martin-Löf 相等性。</p>
<!--
Leibniz equality is usually formalised to state that `x ≐ y` holds if
every property `P` that holds of `x` also holds of `y`.  Perhaps
surprisingly, this definition is sufficient to also ensure the
converse, that every property `P` that holds of `y` also holds of `x`.
-->
<p>莱布尼兹不等式一般如下来定义：<code>x ≐ y</code> 当每个对于 <code>x</code> 成立的性质 <code>P</code> 对于 <code>y</code> 也成立时成立。 可能这有些出乎意料，但是这个定义亦足够保证其相反的命题：每个对于 <code>y</code> 成立的性质 <code>P</code> 对于 <code>x</code> 也成立。</p>
<!--
Let `x` and `y` be objects of type `A`. We say that `x ≐ y` holds if
for every predicate `P` over type `A` we have that `P x` implies `P y`:
-->
<p>令 <code>x</code> 和 <code>y</code> 为类型 <code>A</code> 的对象。我们定义 <code>x ≐ y</code> 成立，当每个对于类型 <code>A</code> 成立的谓词 <code>P</code>， 我们有 <code>P x</code> 蕴涵了 <code>P y</code>：</p>
<pre class="Agda"><a id="_≐_"></a><a id="21469" href="../Equality/#21469" class="Function Operator">_≐_</a> <a id="21473" class="Symbol">:</a> <a id="21475" class="Symbol">∀</a> <a id="21477" class="Symbol">{</a><a id="21478" href="../Equality/#21478" class="Bound">A</a> <a id="21480" class="Symbol">:</a> <a id="21482" class="PrimitiveType">Set</a><a id="21485" class="Symbol">}</a> <a id="21487" class="Symbol">(</a><a id="21488" href="../Equality/#21488" class="Bound">x</a> <a id="21490" href="../Equality/#21490" class="Bound">y</a> <a id="21492" class="Symbol">:</a> <a id="21494" href="../Equality/#21478" class="Bound">A</a><a id="21495" class="Symbol">)</a> <a id="21497" class="Symbol">→</a> <a id="21499" class="PrimitiveType">Set₁</a>
<a id="21504" href="../Equality/#21469" class="Function Operator">_≐_</a> <a id="21508" class="Symbol">{</a><a id="21509" href="../Equality/#21509" class="Bound">A</a><a id="21510" class="Symbol">}</a> <a id="21512" href="../Equality/#21512" class="Bound">x</a> <a id="21514" href="../Equality/#21514" class="Bound">y</a> <a id="21516" class="Symbol">=</a> <a id="21518" class="Symbol">∀</a> <a id="21520" class="Symbol">(</a><a id="21521" href="../Equality/#21521" class="Bound">P</a> <a id="21523" class="Symbol">:</a> <a id="21525" href="../Equality/#21509" class="Bound">A</a> <a id="21527" class="Symbol">→</a> <a id="21529" class="PrimitiveType">Set</a><a id="21532" class="Symbol">)</a> <a id="21534" class="Symbol">→</a> <a id="21536" href="../Equality/#21521" class="Bound">P</a> <a id="21538" href="../Equality/#21512" class="Bound">x</a> <a id="21540" class="Symbol">→</a> <a id="21542" href="../Equality/#21521" class="Bound">P</a> <a id="21544" href="../Equality/#21514" class="Bound">y</a>
</pre>
<!--
We cannot write the left-hand side of the equation as `x ≐ y`,
and instead we write `_≐_ {A} x y` to provide access to the implicit
parameter `A` which appears on the right-hand side.
-->
<p>我们不能在左手边使用 <code>x ≐ y</code>，取而代之我们使用 <code>_≐_ {A} x y</code> 来提供隐式参数 <code>A</code>，这样 <code>A</code> 可以出现在右手边。</p>
<!--
This is our first use of _levels_.  We cannot assign `Set` the type
`Set`, since this would lead to contradictions such as Russell's
Paradox and Girard's Paradox.  Instead, there is a hierarchy of types,
where `Set : Set₁`, `Set₁ : Set₂`, and so on.  In fact, `Set` itself
is just an abbreviation for `Set₀`.  Since the equation defining `_≐_`
mentions `Set` on the right-hand side, the corresponding signature
must use `Set₁`.  We say a bit more about levels below.
-->
<p>这是我们第一次使用<em>等级</em>（Levels）。我们不能将 <code>Set</code> 赋予类型 <code>Set</code>，因为这会导致自相矛盾， 比如罗素悖论（Russell’s Paradox）或者 Girard 悖论。不同的是，我们有一个阶级的类型：其中 <code>Set : Set₁</code>，<code>Set₁ : Set₂</code>，以此类推。实际上，<code>Set</code> 本身就是 <code>Set₀</code> 的缩写。定义 <code>_≐_</code> 的等式在右手边提到了 <code>Set</code>，因此签名中必须使用 <code>Set₁</code>。我们稍后将进一步介绍等级。</p>
<!--
Leibniz equality is reflexive and transitive,
where the first follows by a variant of the identity function
and the second by a variant of function composition:
-->
<p>莱布尼兹相等性是自反和传递的。自反性由恒等函数的变种得来，传递性由函数组合的变种得来：</p>
<pre class="Agda"><a id="refl-≐"></a><a id="22744" href="../Equality/#22744" class="Function">refl-≐</a> <a id="22751" class="Symbol">:</a> <a id="22753" class="Symbol">∀</a> <a id="22755" class="Symbol">{</a><a id="22756" href="../Equality/#22756" class="Bound">A</a> <a id="22758" class="Symbol">:</a> <a id="22760" class="PrimitiveType">Set</a><a id="22763" class="Symbol">}</a> <a id="22765" class="Symbol">{</a><a id="22766" href="../Equality/#22766" class="Bound">x</a> <a id="22768" class="Symbol">:</a> <a id="22770" href="../Equality/#22756" class="Bound">A</a><a id="22771" class="Symbol">}</a>
  <a id="22775" class="Symbol">→</a> <a id="22777" href="../Equality/#22766" class="Bound">x</a> <a id="22779" href="../Equality/#21469" class="Function Operator">≐</a> <a id="22781" href="../Equality/#22766" class="Bound">x</a>
<a id="22783" href="../Equality/#22744" class="Function">refl-≐</a> <a id="22790" href="../Equality/#22790" class="Bound">P</a> <a id="22792" href="../Equality/#22792" class="Bound">Px</a>  <a id="22796" class="Symbol">=</a>  <a id="22799" href="../Equality/#22792" class="Bound">Px</a>

<a id="trans-≐"></a><a id="22803" href="../Equality/#22803" class="Function">trans-≐</a> <a id="22811" class="Symbol">:</a> <a id="22813" class="Symbol">∀</a> <a id="22815" class="Symbol">{</a><a id="22816" href="../Equality/#22816" class="Bound">A</a> <a id="22818" class="Symbol">:</a> <a id="22820" class="PrimitiveType">Set</a><a id="22823" class="Symbol">}</a> <a id="22825" class="Symbol">{</a><a id="22826" href="../Equality/#22826" class="Bound">x</a> <a id="22828" href="../Equality/#22828" class="Bound">y</a> <a id="22830" href="../Equality/#22830" class="Bound">z</a> <a id="22832" class="Symbol">:</a> <a id="22834" href="../Equality/#22816" class="Bound">A</a><a id="22835" class="Symbol">}</a>
  <a id="22839" class="Symbol">→</a> <a id="22841" href="../Equality/#22826" class="Bound">x</a> <a id="22843" href="../Equality/#21469" class="Function Operator">≐</a> <a id="22845" href="../Equality/#22828" class="Bound">y</a>
  <a id="22849" class="Symbol">→</a> <a id="22851" href="../Equality/#22828" class="Bound">y</a> <a id="22853" href="../Equality/#21469" class="Function Operator">≐</a> <a id="22855" href="../Equality/#22830" class="Bound">z</a>
    <a id="22861" class="Comment">-----</a>
  <a id="22869" class="Symbol">→</a> <a id="22871" href="../Equality/#22826" class="Bound">x</a> <a id="22873" href="../Equality/#21469" class="Function Operator">≐</a> <a id="22875" href="../Equality/#22830" class="Bound">z</a>
<a id="22877" href="../Equality/#22803" class="Function">trans-≐</a> <a id="22885" href="../Equality/#22885" class="Bound">x≐y</a> <a id="22889" href="../Equality/#22889" class="Bound">y≐z</a> <a id="22893" href="../Equality/#22893" class="Bound">P</a> <a id="22895" href="../Equality/#22895" class="Bound">Px</a>  <a id="22899" class="Symbol">=</a>  <a id="22902" href="../Equality/#22889" class="Bound">y≐z</a> <a id="22906" href="../Equality/#22893" class="Bound">P</a> <a id="22908" class="Symbol">(</a><a id="22909" href="../Equality/#22885" class="Bound">x≐y</a> <a id="22913" href="../Equality/#22893" class="Bound">P</a> <a id="22915" href="../Equality/#22895" class="Bound">Px</a><a id="22917" class="Symbol">)</a>
</pre>
<!--
Symmetry is less obvious.  We have to show that if `P x` implies `P y`
for all predicates `P`, then the implication holds the other way round
as well:
-->
<p>对称性就没有那么显然了。我们需要证明如果对于所有谓词 <code>P</code>，<code>P x</code> 蕴涵 <code>P y</code>， 那么反方向的蕴涵也成立。</p>
<pre class="Agda"><a id="sym-≐"></a><a id="23150" href="../Equality/#23150" class="Function">sym-≐</a> <a id="23156" class="Symbol">:</a> <a id="23158" class="Symbol">∀</a> <a id="23160" class="Symbol">{</a><a id="23161" href="../Equality/#23161" class="Bound">A</a> <a id="23163" class="Symbol">:</a> <a id="23165" class="PrimitiveType">Set</a><a id="23168" class="Symbol">}</a> <a id="23170" class="Symbol">{</a><a id="23171" href="../Equality/#23171" class="Bound">x</a> <a id="23173" href="../Equality/#23173" class="Bound">y</a> <a id="23175" class="Symbol">:</a> <a id="23177" href="../Equality/#23161" class="Bound">A</a><a id="23178" class="Symbol">}</a>
  <a id="23182" class="Symbol">→</a> <a id="23184" href="../Equality/#23171" class="Bound">x</a> <a id="23186" href="../Equality/#21469" class="Function Operator">≐</a> <a id="23188" href="../Equality/#23173" class="Bound">y</a>
    <a id="23194" class="Comment">-----</a>
  <a id="23202" class="Symbol">→</a> <a id="23204" href="../Equality/#23173" class="Bound">y</a> <a id="23206" href="../Equality/#21469" class="Function Operator">≐</a> <a id="23208" href="../Equality/#23171" class="Bound">x</a>
<a id="23210" href="../Equality/#23150" class="Function">sym-≐</a> <a id="23216" class="Symbol">{</a><a id="23217" href="../Equality/#23217" class="Bound">A</a><a id="23218" class="Symbol">}</a> <a id="23220" class="Symbol">{</a><a id="23221" href="../Equality/#23221" class="Bound">x</a><a id="23222" class="Symbol">}</a> <a id="23224" class="Symbol">{</a><a id="23225" href="../Equality/#23225" class="Bound">y</a><a id="23226" class="Symbol">}</a> <a id="23228" href="../Equality/#23228" class="Bound">x≐y</a> <a id="23232" href="../Equality/#23232" class="Bound">P</a>  <a id="23235" class="Symbol">=</a>  <a id="23238" href="../Equality/#23320" class="Function">Qy</a>
  <a id="23243" class="Keyword">where</a>
    <a id="23253" href="../Equality/#23253" class="Function">Q</a> <a id="23255" class="Symbol">:</a> <a id="23257" href="../Equality/#23217" class="Bound">A</a> <a id="23259" class="Symbol">→</a> <a id="23261" class="PrimitiveType">Set</a>
    <a id="23269" href="../Equality/#23253" class="Function">Q</a> <a id="23271" href="../Equality/#23271" class="Bound">z</a> <a id="23273" class="Symbol">=</a> <a id="23275" href="../Equality/#23232" class="Bound">P</a> <a id="23277" href="../Equality/#23271" class="Bound">z</a> <a id="23279" class="Symbol">→</a> <a id="23281" href="../Equality/#23232" class="Bound">P</a> <a id="23283" href="../Equality/#23221" class="Bound">x</a>
    <a id="23289" href="../Equality/#23289" class="Function">Qx</a> <a id="23292" class="Symbol">:</a> <a id="23294" href="../Equality/#23253" class="Function">Q</a> <a id="23296" href="../Equality/#23221" class="Bound">x</a>
    <a id="23302" href="../Equality/#23289" class="Function">Qx</a> <a id="23305" class="Symbol">=</a> <a id="23307" href="../Equality/#22744" class="Function">refl-≐</a> <a id="23314" href="../Equality/#23232" class="Bound">P</a>
    <a id="23320" href="../Equality/#23320" class="Function">Qy</a> <a id="23323" class="Symbol">:</a> <a id="23325" href="../Equality/#23253" class="Function">Q</a> <a id="23327" href="../Equality/#23225" class="Bound">y</a>
    <a id="23333" href="../Equality/#23320" class="Function">Qy</a> <a id="23336" class="Symbol">=</a> <a id="23338" href="../Equality/#23228" class="Bound">x≐y</a> <a id="23342" href="../Equality/#23253" class="Function">Q</a> <a id="23344" href="../Equality/#23289" class="Function">Qx</a>
</pre>
<!--
Given `x ≐ y`, a specific `P`, we have to construct a proof that `P y`
implies `P x`.  To do so, we instantiate the equality with a predicate
`Q` such that `Q z` holds if `P z` implies `P x`.  The property `Q x`
is trivial by reflexivity, and hence `Q y` follows from `x ≐ y`.  But
`Q y` is exactly a proof of what we require, that `P y` implies `P x`.
-->
<p>给定 <code>x ≐ y</code> 和一个特定的 <code>P</code>，我们需要构造一个 <code>P y</code> 蕴涵 <code>P x</code> 的证明。 我们首先用一个谓词 <code>Q</code> 将相等性实例化，使得 <code>Q z</code> 在 <code>P z</code> 蕴涵 <code>P x</code> 时成立。 <code>Q x</code> 这个性质是显然的，由自反性可以得出，由此通过 <code>x ≐ y</code> 就能推出 <code>Q y</code> 成立。而 <code>Q y</code> 正是我们需要的证明，即 <code>P y</code> 蕴涵 <code>P x</code>。</p>
<!--
We now show that Martin-Löf equality implies
Leibniz equality, and vice versa.  In the forward direction, if we know
`x ≡ y` we need for any `P` to take evidence of `P x` to evidence of `P y`,
which is easy since equality of `x` and `y` implies that any proof
of `P x` is also a proof of `P y`:
-->
<p>我们现在来证明 Martin-Löf 相等性蕴涵了莱布尼兹相等性，以及其逆命题。在正方向上， 如果我们已知 <code>x ≡ y</code>，我们需要对于任意的 <code>P</code>，将 <code>P x</code> 的证明转换为 <code>P y</code> 的证明。 我们很容易就可以做到这一点，因为 <code>x</code> 与 <code>y</code> 相等意味着任何 <code>P x</code> 的证明即是 <code>P y</code> 的证明。</p>
<pre class="Agda"><a id="≡-implies-≐"></a><a id="24377" href="../Equality/#24377" class="Function">≡-implies-≐</a> <a id="24389" class="Symbol">:</a> <a id="24391" class="Symbol">∀</a> <a id="24393" class="Symbol">{</a><a id="24394" href="../Equality/#24394" class="Bound">A</a> <a id="24396" class="Symbol">:</a> <a id="24398" class="PrimitiveType">Set</a><a id="24401" class="Symbol">}</a> <a id="24403" class="Symbol">{</a><a id="24404" href="../Equality/#24404" class="Bound">x</a> <a id="24406" href="../Equality/#24406" class="Bound">y</a> <a id="24408" class="Symbol">:</a> <a id="24410" href="../Equality/#24394" class="Bound">A</a><a id="24411" class="Symbol">}</a>
  <a id="24415" class="Symbol">→</a> <a id="24417" href="../Equality/#24404" class="Bound">x</a> <a id="24419" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="24421" href="../Equality/#24406" class="Bound">y</a>
    <a id="24427" class="Comment">-----</a>
  <a id="24435" class="Symbol">→</a> <a id="24437" href="../Equality/#24404" class="Bound">x</a> <a id="24439" href="../Equality/#21469" class="Function Operator">≐</a> <a id="24441" href="../Equality/#24406" class="Bound">y</a>
<a id="24443" href="../Equality/#24377" class="Function">≡-implies-≐</a> <a id="24455" href="../Equality/#24455" class="Bound">x≡y</a> <a id="24459" href="../Equality/#24459" class="Bound">P</a>  <a id="24462" class="Symbol">=</a>  <a id="24465" href="../Equality/#6485" class="Function">subst</a> <a id="24471" href="../Equality/#24459" class="Bound">P</a> <a id="24473" href="../Equality/#24455" class="Bound">x≡y</a>
</pre>
<!--
This direction follows from substitution, which we showed earlier.
-->
<p>因为这个方向由替换性可以得来，如之前证明的那样。</p>
<!--
In the reverse direction, given that for any `P` we can take a proof of `P x`
to a proof of `P y` we need to show `x ≡ y`:
-->
<p>在反方向上，我们已知对于任何 <code>P</code>，我们可以将 <code>P x</code> 的证明转换成 <code>P y</code> 的证明， 我们需要证明 <code>x ≡ y</code>：</p>
<pre class="Agda"><a id="≐-implies-≡"></a><a id="24788" href="../Equality/#24788" class="Function">≐-implies-≡</a> <a id="24800" class="Symbol">:</a> <a id="24802" class="Symbol">∀</a> <a id="24804" class="Symbol">{</a><a id="24805" href="../Equality/#24805" class="Bound">A</a> <a id="24807" class="Symbol">:</a> <a id="24809" class="PrimitiveType">Set</a><a id="24812" class="Symbol">}</a> <a id="24814" class="Symbol">{</a><a id="24815" href="../Equality/#24815" class="Bound">x</a> <a id="24817" href="../Equality/#24817" class="Bound">y</a> <a id="24819" class="Symbol">:</a> <a id="24821" href="../Equality/#24805" class="Bound">A</a><a id="24822" class="Symbol">}</a>
  <a id="24826" class="Symbol">→</a> <a id="24828" href="../Equality/#24815" class="Bound">x</a> <a id="24830" href="../Equality/#21469" class="Function Operator">≐</a> <a id="24832" href="../Equality/#24817" class="Bound">y</a>
    <a id="24838" class="Comment">-----</a>
  <a id="24846" class="Symbol">→</a> <a id="24848" href="../Equality/#24815" class="Bound">x</a> <a id="24850" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="24852" href="../Equality/#24817" class="Bound">y</a>
<a id="24854" href="../Equality/#24788" class="Function">≐-implies-≡</a> <a id="24866" class="Symbol">{</a><a id="24867" href="../Equality/#24867" class="Bound">A</a><a id="24868" class="Symbol">}</a> <a id="24870" class="Symbol">{</a><a id="24871" href="../Equality/#24871" class="Bound">x</a><a id="24872" class="Symbol">}</a> <a id="24874" class="Symbol">{</a><a id="24875" href="../Equality/#24875" class="Bound">y</a><a id="24876" class="Symbol">}</a> <a id="24878" href="../Equality/#24878" class="Bound">x≐y</a>  <a id="24883" class="Symbol">=</a>  <a id="24886" href="../Equality/#24960" class="Function">Qy</a>
  <a id="24891" class="Keyword">where</a>
    <a id="24901" href="../Equality/#24901" class="Function">Q</a> <a id="24903" class="Symbol">:</a> <a id="24905" href="../Equality/#24867" class="Bound">A</a> <a id="24907" class="Symbol">→</a> <a id="24909" class="PrimitiveType">Set</a>
    <a id="24917" href="../Equality/#24901" class="Function">Q</a> <a id="24919" href="../Equality/#24919" class="Bound">z</a> <a id="24921" class="Symbol">=</a> <a id="24923" href="../Equality/#24871" class="Bound">x</a> <a id="24925" href="../Equality/#1019" class="Datatype Operator">≡</a> <a id="24927" href="../Equality/#24919" class="Bound">z</a>
    <a id="24933" href="../Equality/#24933" class="Function">Qx</a> <a id="24936" class="Symbol">:</a> <a id="24938" href="../Equality/#24901" class="Function">Q</a> <a id="24940" href="../Equality/#24871" class="Bound">x</a>
    <a id="24946" href="../Equality/#24933" class="Function">Qx</a> <a id="24949" class="Symbol">=</a> <a id="24951" href="../Equality/#1059" class="InductiveConstructor">refl</a>
    <a id="24960" href="../Equality/#24960" class="Function">Qy</a> <a id="24963" class="Symbol">:</a> <a id="24965" href="../Equality/#24901" class="Function">Q</a> <a id="24967" href="../Equality/#24875" class="Bound">y</a>
    <a id="24973" href="../Equality/#24960" class="Function">Qy</a> <a id="24976" class="Symbol">=</a> <a id="24978" href="../Equality/#24878" class="Bound">x≐y</a> <a id="24982" href="../Equality/#24901" class="Function">Q</a> <a id="24984" href="../Equality/#24933" class="Function">Qx</a>
</pre>
<!--
The proof is similar to that for symmetry of Leibniz equality. We take
`Q` to be the predicate that holds of `z` if `x ≡ z`. Then `Q x` is
trivial by reflexivity of Martin-Löf equality, and hence `Q y`
follows from `x ≐ y`.  But `Q y` is exactly a proof of what we
require, that `x ≡ y`.
-->
<p>此证明与莱布尼兹相等性的对称性证明相似。我们取谓词 <code>Q</code>，使得 <code>Q z</code> 在 <code>x ≡ z</code> 成立时成立。 那么 <code>Q x</code> 是显然的，由 Martin Löf 相等性的自反性得来。从而 <code>Q y</code> 由 <code>x ≐ y</code> 可得， 而 <code>Q y</code> 即是我们所需要的 <code>x ≡ y</code> 的证明。</p>
<!--
(Parts of this section are adapted from *≐≃≡: Leibniz Equality is
Isomorphic to Martin-Löf Identity, Parametrically*, by Andreas Abel,
Jesper Cockx, Dominique Devries, Andreas Nuyts, and Philip Wadler,
draft, 2017.)
-->
<p>（本部分的内容由此处改编得来： <em>≐≃≡: Leibniz Equality is Isomorphic to Martin-Löf Identity, Parametrically</em> 作者：Andreas Abel、Jesper Cockx、Dominique Devries、Andreas Nuyts 与 Philip Wadler， 草稿，2017）</p>
<!--
## Universe polymorphism {name=unipoly}
-->
<h2 name="unipoly" id="全体多态">全体多态</h2>
<!--
As we have seen, not every type belongs to `Set`, but instead every
type belongs somewhere in the hierarchy `Set₀`, `Set₁`, `Set₂`, and so on,
where `Set` abbreviates `Set₀`, and `Set₀ : Set₁`, `Set₁ : Set₂`, and so on.
The definition of equality given above is fine if we want to compare two
values of a type that belongs to `Set`, but what if we want to compare
two values of a type that belongs to `Set ℓ` for some arbitrary level `ℓ`?
-->
<p>正如我们之前看到的那样，不是每个类型都属于 <code>Set</code>，但是每个类型都属于类型阶级的某处， <code>Set₀</code>、<code>Set₁</code>、<code>Set₂</code>等等。其中 <code>Set</code> 是 <code>Set₀</code> 的缩写，此外 <code>Set₀ : Set₁</code>，<code>Set₁ : Set₂</code>，以此类推。 当我们需要比较两个属于 <code>Set</code> 的类型的值时，我们之前给出的定义是足够的， 但如果我们需要比较对于任何等级 <code>ℓ</code>，两个属于 <code>Set ℓ</code> 的类型的值该怎么办呢？</p>
<!--
The answer is _universe polymorphism_, where a definition is made
with respect to an arbitrary level `ℓ`. To make use of levels, we
first import the following:
-->
<p>答案是<em>全体多态</em>（Universe Polymorphism），一个定义可以根据任何等级 <code>ℓ</code> 来做出。 为了使用等级，我们首先导入下列内容：</p>
<pre class="Agda"><a id="26831" class="Keyword">open</a> <a id="26836" class="Keyword">import</a> <a id="26843" href="https://agda.github.io/agda-stdlib/v1.3/Level.html" class="Module">Level</a> <a id="26849" class="Keyword">using</a> <a id="26855" class="Symbol">(</a><a id="26856" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Primitive.html#423" class="Postulate">Level</a><a id="26861" class="Symbol">;</a> <a id="26863" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Primitive.html#636" class="Primitive Operator">_⊔_</a><a id="26866" class="Symbol">)</a> <a id="26868" class="Keyword">renaming</a> <a id="26877" class="Symbol">(</a><a id="26878" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Primitive.html#590" class="Primitive">zero</a> <a id="26883" class="Symbol">to</a> <a id="lzero"></a><a id="26886" href="../Equality/#26886" class="Primitive">lzero</a><a id="26891" class="Symbol">;</a> <a id="26893" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Primitive.html#606" class="Primitive">suc</a> <a id="26897" class="Symbol">to</a> <a id="lsuc"></a><a id="26900" href="../Equality/#26900" class="Primitive">lsuc</a><a id="26904" class="Symbol">)</a>
</pre>
<!--
We rename constructors `zero` and `suc` to `lzero` and `lsuc` to avoid confusion
between levels and naturals.
-->
<p>我们将构造子 <code>zero</code> 和 <code>suc</code> 重命名至 <code>lzero</code> 和 <code>lsuc</code>，为了防止自然数和等级之间的混淆。</p>
<!--
Levels are isomorphic to natural numbers, and have similar constructors:
-->
<p>等级与自然数是同构的，有相似的构造子：</p>
<pre><code>lzero : Level
lsuc  : Level → Level</code></pre>
<!--
The names `Set₀`, `Set₁`, `Set₂`, and so on, are abbreviations for
-->
<p><code>Set₀</code>、<code>Set₁</code>、<code>Set₂</code> 等名称，是下列的简写：</p>
<pre><code>Set lzero
Set (lsuc lzero)
Set (lsuc (lsuc lzero))</code></pre>
<!--
and so on. There is also an operator
-->
<p>以此类推。我们还有一个运算符：</p>
<pre><code>_⊔_ : Level → Level → Level</code></pre>
<!--
that given two levels returns the larger of the two.
-->
<p>给定两个等级，返回两者中较大的那个。</p>
<!--
Here is the definition of equality, generalised to an arbitrary level:
-->
<p>下面是相等性的定义，推广到任意等级：</p>
<pre class="Agda"><a id="27702" class="Keyword">data</a> <a id="_≡′_"></a><a id="27707" href="../Equality/#27707" class="Datatype Operator">_≡′_</a> <a id="27712" class="Symbol">{</a><a id="27713" href="../Equality/#27713" class="Bound">ℓ</a> <a id="27715" class="Symbol">:</a> <a id="27717" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Primitive.html#423" class="Postulate">Level</a><a id="27722" class="Symbol">}</a> <a id="27724" class="Symbol">{</a><a id="27725" href="../Equality/#27725" class="Bound">A</a> <a id="27727" class="Symbol">:</a> <a id="27729" class="PrimitiveType">Set</a> <a id="27733" href="../Equality/#27713" class="Bound">ℓ</a><a id="27734" class="Symbol">}</a> <a id="27736" class="Symbol">(</a><a id="27737" href="../Equality/#27737" class="Bound">x</a> <a id="27739" class="Symbol">:</a> <a id="27741" href="../Equality/#27725" class="Bound">A</a><a id="27742" class="Symbol">)</a> <a id="27744" class="Symbol">:</a> <a id="27746" href="../Equality/#27725" class="Bound">A</a> <a id="27748" class="Symbol">→</a> <a id="27750" class="PrimitiveType">Set</a> <a id="27754" href="../Equality/#27713" class="Bound">ℓ</a> <a id="27756" class="Keyword">where</a>
  <a id="_≡′_.refl′"></a><a id="27764" href="../Equality/#27764" class="InductiveConstructor">refl′</a> <a id="27770" class="Symbol">:</a> <a id="27772" href="../Equality/#27737" class="Bound">x</a> <a id="27774" href="../Equality/#27707" class="Datatype Operator">≡′</a> <a id="27777" href="../Equality/#27737" class="Bound">x</a>
</pre>
<!--
Similarly, here is the generalised definition of symmetry:
-->
<p>相似的，下面是对称性的推广定义：</p>
<pre class="Agda"><a id="sym′"></a><a id="27875" href="../Equality/#27875" class="Function">sym′</a> <a id="27880" class="Symbol">:</a> <a id="27882" class="Symbol">∀</a> <a id="27884" class="Symbol">{</a><a id="27885" href="../Equality/#27885" class="Bound">ℓ</a> <a id="27887" class="Symbol">:</a> <a id="27889" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Primitive.html#423" class="Postulate">Level</a><a id="27894" class="Symbol">}</a> <a id="27896" class="Symbol">{</a><a id="27897" href="../Equality/#27897" class="Bound">A</a> <a id="27899" class="Symbol">:</a> <a id="27901" class="PrimitiveType">Set</a> <a id="27905" href="../Equality/#27885" class="Bound">ℓ</a><a id="27906" class="Symbol">}</a> <a id="27908" class="Symbol">{</a><a id="27909" href="../Equality/#27909" class="Bound">x</a> <a id="27911" href="../Equality/#27911" class="Bound">y</a> <a id="27913" class="Symbol">:</a> <a id="27915" href="../Equality/#27897" class="Bound">A</a><a id="27916" class="Symbol">}</a>
  <a id="27920" class="Symbol">→</a> <a id="27922" href="../Equality/#27909" class="Bound">x</a> <a id="27924" href="../Equality/#27707" class="Datatype Operator">≡′</a> <a id="27927" href="../Equality/#27911" class="Bound">y</a>
    <a id="27933" class="Comment">------</a>
  <a id="27942" class="Symbol">→</a> <a id="27944" href="../Equality/#27911" class="Bound">y</a> <a id="27946" href="../Equality/#27707" class="Datatype Operator">≡′</a> <a id="27949" href="../Equality/#27909" class="Bound">x</a>
<a id="27951" href="../Equality/#27875" class="Function">sym′</a> <a id="27956" href="../Equality/#27764" class="InductiveConstructor">refl′</a> <a id="27962" class="Symbol">=</a> <a id="27964" href="../Equality/#27764" class="InductiveConstructor">refl′</a>
</pre>
<!--
For simplicity, we avoid universe polymorphism in the definitions given in
the text, but most definitions in the standard library, including those for
equality, are generalised to arbitrary levels as above.
-->
<p>为了简介，我们在本书中给出的定义将避免使用全体多态，但是大多数标准库中的定义， 包括相等性的定义，都推广到了任意等级，如上所示。</p>
<!--
Here is the generalised definition of Leibniz equality:
-->
<p>下面是莱布尼兹相等性的推广定义：</p>
<pre class="Agda"><a id="_≐′_"></a><a id="28346" href="../Equality/#28346" class="Function Operator">_≐′_</a> <a id="28351" class="Symbol">:</a> <a id="28353" class="Symbol">∀</a> <a id="28355" class="Symbol">{</a><a id="28356" href="../Equality/#28356" class="Bound">ℓ</a> <a id="28358" class="Symbol">:</a> <a id="28360" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Primitive.html#423" class="Postulate">Level</a><a id="28365" class="Symbol">}</a> <a id="28367" class="Symbol">{</a><a id="28368" href="../Equality/#28368" class="Bound">A</a> <a id="28370" class="Symbol">:</a> <a id="28372" class="PrimitiveType">Set</a> <a id="28376" href="../Equality/#28356" class="Bound">ℓ</a><a id="28377" class="Symbol">}</a> <a id="28379" class="Symbol">(</a><a id="28380" href="../Equality/#28380" class="Bound">x</a> <a id="28382" href="../Equality/#28382" class="Bound">y</a> <a id="28384" class="Symbol">:</a> <a id="28386" href="../Equality/#28368" class="Bound">A</a><a id="28387" class="Symbol">)</a> <a id="28389" class="Symbol">→</a> <a id="28391" class="PrimitiveType">Set</a> <a id="28395" class="Symbol">(</a><a id="28396" href="../Equality/#26900" class="Primitive">lsuc</a> <a id="28401" href="../Equality/#28356" class="Bound">ℓ</a><a id="28402" class="Symbol">)</a>
<a id="28404" href="../Equality/#28346" class="Function Operator">_≐′_</a> <a id="28409" class="Symbol">{</a><a id="28410" href="../Equality/#28410" class="Bound">ℓ</a><a id="28411" class="Symbol">}</a> <a id="28413" class="Symbol">{</a><a id="28414" href="../Equality/#28414" class="Bound">A</a><a id="28415" class="Symbol">}</a> <a id="28417" href="../Equality/#28417" class="Bound">x</a> <a id="28419" href="../Equality/#28419" class="Bound">y</a> <a id="28421" class="Symbol">=</a> <a id="28423" class="Symbol">∀</a> <a id="28425" class="Symbol">(</a><a id="28426" href="../Equality/#28426" class="Bound">P</a> <a id="28428" class="Symbol">:</a> <a id="28430" href="../Equality/#28414" class="Bound">A</a> <a id="28432" class="Symbol">→</a> <a id="28434" class="PrimitiveType">Set</a> <a id="28438" href="../Equality/#28410" class="Bound">ℓ</a><a id="28439" class="Symbol">)</a> <a id="28441" class="Symbol">→</a> <a id="28443" href="../Equality/#28426" class="Bound">P</a> <a id="28445" href="../Equality/#28417" class="Bound">x</a> <a id="28447" class="Symbol">→</a> <a id="28449" href="../Equality/#28426" class="Bound">P</a> <a id="28451" href="../Equality/#28419" class="Bound">y</a>
</pre>
<!--
Before the signature used `Set₁` as the type of a term that includes
`Set`, whereas here the signature uses `Set (lsuc ℓ)` as the type of a
term that includes `Set ℓ`.
-->
<p>之前，签名中使用了 <code>Set₁</code> 来作为一个值包括了 <code>Set</code> 的类型；而此处，我们使用 <code>Set (lsuc ℓ)</code> 来作为一个值包括了 <code>Set ℓ</code> 的类型。</p>
<!--
Most other functions in the standard library are also generalised to
arbitrary levels. For instance, here is the definition of composition.
-->
<p>标准库中的大部分函数都泛化到了任意层级。例如，以下是复合的定义。</p>
<pre class="Agda"><a id="_∘_"></a><a id="28909" href="../Equality/#28909" class="Function Operator">_∘_</a> <a id="28913" class="Symbol">:</a> <a id="28915" class="Symbol">∀</a> <a id="28917" class="Symbol">{</a><a id="28918" href="../Equality/#28918" class="Bound">ℓ₁</a> <a id="28921" href="../Equality/#28921" class="Bound">ℓ₂</a> <a id="28924" href="../Equality/#28924" class="Bound">ℓ₃</a> <a id="28927" class="Symbol">:</a> <a id="28929" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Primitive.html#423" class="Postulate">Level</a><a id="28934" class="Symbol">}</a> <a id="28936" class="Symbol">{</a><a id="28937" href="../Equality/#28937" class="Bound">A</a> <a id="28939" class="Symbol">:</a> <a id="28941" class="PrimitiveType">Set</a> <a id="28945" href="../Equality/#28918" class="Bound">ℓ₁</a><a id="28947" class="Symbol">}</a> <a id="28949" class="Symbol">{</a><a id="28950" href="../Equality/#28950" class="Bound">B</a> <a id="28952" class="Symbol">:</a> <a id="28954" class="PrimitiveType">Set</a> <a id="28958" href="../Equality/#28921" class="Bound">ℓ₂</a><a id="28960" class="Symbol">}</a> <a id="28962" class="Symbol">{</a><a id="28963" href="../Equality/#28963" class="Bound">C</a> <a id="28965" class="Symbol">:</a> <a id="28967" class="PrimitiveType">Set</a> <a id="28971" href="../Equality/#28924" class="Bound">ℓ₃</a><a id="28973" class="Symbol">}</a>
  <a id="28977" class="Symbol">→</a> <a id="28979" class="Symbol">(</a><a id="28980" href="../Equality/#28950" class="Bound">B</a> <a id="28982" class="Symbol">→</a> <a id="28984" href="../Equality/#28963" class="Bound">C</a><a id="28985" class="Symbol">)</a> <a id="28987" class="Symbol">→</a> <a id="28989" class="Symbol">(</a><a id="28990" href="../Equality/#28937" class="Bound">A</a> <a id="28992" class="Symbol">→</a> <a id="28994" href="../Equality/#28950" class="Bound">B</a><a id="28995" class="Symbol">)</a> <a id="28997" class="Symbol">→</a> <a id="28999" href="../Equality/#28937" class="Bound">A</a> <a id="29001" class="Symbol">→</a> <a id="29003" href="../Equality/#28963" class="Bound">C</a>
<a id="29005" class="Symbol">(</a><a id="29006" href="../Equality/#29006" class="Bound">g</a> <a id="29008" href="../Equality/#28909" class="Function Operator">∘</a> <a id="29010" href="../Equality/#29010" class="Bound">f</a><a id="29011" class="Symbol">)</a> <a id="29013" href="../Equality/#29013" class="Bound">x</a>  <a id="29016" class="Symbol">=</a>  <a id="29019" href="../Equality/#29006" class="Bound">g</a> <a id="29021" class="Symbol">(</a><a id="29022" href="../Equality/#29010" class="Bound">f</a> <a id="29024" href="../Equality/#29013" class="Bound">x</a><a id="29025" class="Symbol">)</a>
</pre>
<!--
Further information on levels can be found in the [Agda docs][docs].
-->
<p>更多关于层级的信息可以从<a href="https://agda.readthedocs.io/en/v2.6.1/language/universe-levels.html">Agda 文档</a>中查询。</p>
<!--
## Standard library
-->
<h2 id="标准库">标准库</h2>
<!--
Definitions similar to those in this chapter can be found in the standard
library. The Agda standard library defines `_≡⟨_⟩_` as `step-≡`, [which reverses
the order of the arguments][step-≡]. The standard library also defines a syntax
macro, which is automatically imported whenever you import `step-≡`, which
recovers the original argument order:
-->
<p>标准库中可以找到与本章节中相似的定义。Agda 标准库将 <code>_≡⟨_⟩_</code> 定义为 <code>step-≡</code>， <a href="https://github.com/agda/agda-stdlib/blob/master/CHANGELOG/v1.3.md#changes-to-how-equational-reasoning-is-implemented">它反转了参数的顺序</a>。标准库还定义了一个语法宏，它可以在你导入 <code>step-≡</code> 时被自动导入，它能够恢复原始的参数顺序：</p>
<pre class="Agda"><a id="29746" class="Comment">-- import Relation.Binary.PropositionalEquality as Eq</a>
<a id="29800" class="Comment">-- open Eq using (_≡_; refl; trans; sym; cong; cong-app; subst)</a>
<a id="29864" class="Comment">-- open Eq.≡-Reasoning using (begin_; _≡⟨⟩_; step-≡; _∎)</a>
</pre>
<!--
Here the imports are shown as comments rather than code to avoid
collisions, as mentioned in the introduction.
-->
<p>这里的导入以注释的形式给出，以防止冲突，如引言中解释的那样。</p>
<h2 id="unicode">Unicode</h2>
<!--
This chapter uses the following unicode:

    ≡  U+2261  IDENTICAL TO (\==, \equiv)
    ⟨  U+27E8  MATHEMATICAL LEFT ANGLE BRACKET (\<)
    ⟩  U+27E9  MATHEMATICAL RIGHT ANGLE BRACKET (\>)
    ∎  U+220E  END OF PROOF (\qed)
    ≐  U+2250  APPROACHES THE LIMIT (\.=)
    ℓ  U+2113  SCRIPT SMALL L (\ell)
    ⊔  U+2294  SQUARE CUP (\lub)
    ₀  U+2080  SUBSCRIPT ZERO (\_0)
    ₁  U+2081  SUBSCRIPT ONE (\_1)
    ₂  U+2082  SUBSCRIPT TWO (\_2)
-->
<p>本章节使用下列 Unicode：</p>
<pre><code>≡  U+2261  等同于 (\==, \equiv)
⟨  U+27E8  数学左尖括号 (\&lt;)
⟩  U+27E9  数学右尖括号 (\&gt;)
∎  U+220E  证毕 (\qed)
≐  U+2250  趋近于极限 (\.=)
ℓ  U+2113  手写小写 L (\ell)
⊔  U+2294  正方形向上开口 (\lub)
₀  U+2080  下标 0 (\_0)
₁  U+2081  下标 1 (\_1)
₂  U+2082  下标 2 (\_2)</code></pre>
    </div>
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Relations/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Equality.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Isomorphism/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

</article>

            </div>
        </main>
        <footer class="site-footer h-card">
    <data class="u-url" href="../"></data>
    <div class="wrapper">
        <h2 class="footer-heading">编程语言基础：Agda 语言描述</h2>
        
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Philip Wadler</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wadler" title="wadler"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wadler</a></li>
    
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Wen Kokke</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wenkokke</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;wenkokke</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Jeremy G. Siek</li>
                    <li>
                        
                        <a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/jsiek" title="jsiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;jsiek</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;jeremysiek</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        
        This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
    </div>
</footer>

    </body>
</html>
