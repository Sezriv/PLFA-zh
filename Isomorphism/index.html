<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../public/css/style.css">
  
  <title>编程语言基础：Agda 语言描述 – Isomorphism</title>
  
  
  
</head>

    <body>
        <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="../">编程语言基础：Agda 语言描述</a>
        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="../">主页</a>
                <a class="page-link" href="../Announcements/">公告</a>
                <a class="page-link" href="../GettingStarted/">使用说明</a>
                <a class="page-link" href="../Citing/">引用</a>
                <a class="page-link" href="https://plfa.github.io/">English</a>
            </div>
        </nav>
    </div>
</header>

        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Equality/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Isomorphism.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Connectives/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

    <header class="post-header">
        <h1 class="post-title" id="isomorphism">Isomorphism: 同构与嵌入</h1>
    </header>
    <div class="post-content">
        <pre class="Agda"><a id="185" class="Keyword">module</a> <a id="192" href="../Isomorphism/" class="Module">plfa.part1.Isomorphism</a> <a id="215" class="Keyword">where</a>
</pre>
<!--
This section introduces isomorphism as a way of asserting that two
types are equal, and embedding as a way of asserting that one type is
smaller than another.  We apply isomorphisms in the next chapter
to demonstrate that operations on types such as product and sum
satisfy properties akin to associativity, commutativity, and
distributivity.
-->
<p>本部分介绍同构（Isomorphism）与嵌入（Embedding）。 同构可以断言两个类型是相等的，嵌入可以断言一个类型比另一个类型小。 我们会在下一章中使用同构来展示类型上的运算，例如积或者和，满足类似于交换律、结合律和分配律的性质。</p>
<!--
## Imports
-->
<h2 id="导入">导入</h2>
<pre class="Agda"><a id="733" class="Keyword">import</a> <a id="740" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="778" class="Symbol">as</a> <a id="781" class="Module">Eq</a>
<a id="784" class="Keyword">open</a> <a id="789" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="792" class="Keyword">using</a> <a id="798" class="Symbol">(</a><a id="799" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="802" class="Symbol">;</a> <a id="804" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="808" class="Symbol">;</a> <a id="810" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a><a id="814" class="Symbol">;</a> <a id="816" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html#1396" class="Function">cong-app</a><a id="824" class="Symbol">)</a>
<a id="826" class="Keyword">open</a> <a id="831" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2419" class="Module">Eq.≡-Reasoning</a>
<a id="846" class="Keyword">open</a> <a id="851" class="Keyword">import</a> <a id="858" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.html" class="Module">Data.Nat</a> <a id="867" class="Keyword">using</a> <a id="873" class="Symbol">(</a><a id="874" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="875" class="Symbol">;</a> <a id="877" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="881" class="Symbol">;</a> <a id="883" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="886" class="Symbol">;</a> <a id="888" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a><a id="891" class="Symbol">)</a>
<a id="893" class="Keyword">open</a> <a id="898" class="Keyword">import</a> <a id="905" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="925" class="Keyword">using</a> <a id="931" class="Symbol">(</a><a id="932" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#12823" class="Function">+-comm</a><a id="938" class="Symbol">)</a>
</pre>
<!--
## Lambda expressions
-->
<h2 id="lambda-表达式">Lambda 表达式</h2>
<!--
The chapter begins with a few preliminaries that will be useful
here and elsewhere: lambda expressions, function composition, and
extensionality.
-->
<p>本章节开头将补充一些有用的基础知识：lambda 表达式，函数组合，以及外延性。</p>
<!--
_Lambda expressions_ provide a compact way to define functions without
naming them.  A term of the form
-->
<p><strong>Lambda 表达式</strong>提供了一种简洁的定义函数的方法，且不需要提供函数名。一个如同这样的项：</p>
<pre><code>λ{ P₁ → N₁; ⋯ ; Pₙ → Nₙ }</code></pre>
<!--
is equivalent to a function `f` defined by the equations
-->
<p>等同于定义一个函数 <code>f</code>，使用下列等式：</p>
<pre><code>f P₁ = N₁
⋯
f Pₙ = Nₙ</code></pre>
<!--
where the `Pₙ` are patterns (left-hand sides of an equation) and the
`Nₙ` are expressions (right-hand side of an equation).
-->
<p>其中 <code>Pₙ</code> 是模式（即等式的左手边），<code>Nₙ</code> 是表达式（即等式的右手边）。</p>
<!--
In the case that there is one equation and the pattern is a variable,
we may also use the syntax
-->
<p>如果只有一个等式，且模式是一个变量，我们亦可使用下面的语法：</p>
<pre><code>λ x → N</code></pre>
<!--
or
-->
<p>或者</p>
<pre><code>λ (x : A) → N</code></pre>
<!--
both of which are equivalent to `λ{x → N}`. The latter allows one to
specify the domain of the function.
-->
<p>两个都与 <code>λ{x → N}</code> 等价。后者可以指定函数的作用域。</p>
<!--
Often using an anonymous lambda expression is more convenient than
using a named function: it avoids a lengthy type declaration; and the
definition appears exactly where the function is used, so there is no
need for the writer to remember to declare it in advance, or for the
reader to search for the definition in the code.
-->
<p>往往使用匿名的 lambda 表达式比使用带名字的函数要方便：它避免了冗长的类型声明； 其定义出现在其使用的地方，所以在书写时不需要记得提前声明，在阅读时不需要上下搜索函数定义。</p>
<!--
## Function composition
-->
<h2 id="函数组合-function-composition">函数组合 （Function Composition）</h2>
<!--
In what follows, we will make use of function composition:
-->
<p>接下来，我们将使用函数组合：</p>
<pre class="Agda"><a id="_∘_"></a><a id="2607" href="../Isomorphism/#2607" class="Function Operator">_∘_</a> <a id="2611" class="Symbol">:</a> <a id="2613" class="Symbol">∀</a> <a id="2615" class="Symbol">{</a><a id="2616" href="../Isomorphism/#2616" class="Bound">A</a> <a id="2618" href="../Isomorphism/#2618" class="Bound">B</a> <a id="2620" href="../Isomorphism/#2620" class="Bound">C</a> <a id="2622" class="Symbol">:</a> <a id="2624" class="PrimitiveType">Set</a><a id="2627" class="Symbol">}</a> <a id="2629" class="Symbol">→</a> <a id="2631" class="Symbol">(</a><a id="2632" href="../Isomorphism/#2618" class="Bound">B</a> <a id="2634" class="Symbol">→</a> <a id="2636" href="../Isomorphism/#2620" class="Bound">C</a><a id="2637" class="Symbol">)</a> <a id="2639" class="Symbol">→</a> <a id="2641" class="Symbol">(</a><a id="2642" href="../Isomorphism/#2616" class="Bound">A</a> <a id="2644" class="Symbol">→</a> <a id="2646" href="../Isomorphism/#2618" class="Bound">B</a><a id="2647" class="Symbol">)</a> <a id="2649" class="Symbol">→</a> <a id="2651" class="Symbol">(</a><a id="2652" href="../Isomorphism/#2616" class="Bound">A</a> <a id="2654" class="Symbol">→</a> <a id="2656" href="../Isomorphism/#2620" class="Bound">C</a><a id="2657" class="Symbol">)</a>
<a id="2659" class="Symbol">(</a><a id="2660" href="../Isomorphism/#2660" class="Bound">g</a> <a id="2662" href="../Isomorphism/#2607" class="Function Operator">∘</a> <a id="2664" href="../Isomorphism/#2664" class="Bound">f</a><a id="2665" class="Symbol">)</a> <a id="2667" href="../Isomorphism/#2667" class="Bound">x</a>  <a id="2670" class="Symbol">=</a> <a id="2672" href="../Isomorphism/#2660" class="Bound">g</a> <a id="2674" class="Symbol">(</a><a id="2675" href="../Isomorphism/#2664" class="Bound">f</a> <a id="2677" href="../Isomorphism/#2667" class="Bound">x</a><a id="2678" class="Symbol">)</a>
</pre>
<!--
Thus, `g ∘ f` is the function that first applies `f` and
then applies `g`.  An equivalent definition, exploiting lambda
expressions, is as follows:
-->
<p><code>g ∘ f</code> 是一个函数，先使用函数 <code>f</code>，再使用函数 <code>g</code>。 一个等价的定义，使用 lambda 表达式，如下：</p>
<pre class="Agda"><a id="_∘′_"></a><a id="2909" href="../Isomorphism/#2909" class="Function Operator">_∘′_</a> <a id="2914" class="Symbol">:</a> <a id="2916" class="Symbol">∀</a> <a id="2918" class="Symbol">{</a><a id="2919" href="../Isomorphism/#2919" class="Bound">A</a> <a id="2921" href="../Isomorphism/#2921" class="Bound">B</a> <a id="2923" href="../Isomorphism/#2923" class="Bound">C</a> <a id="2925" class="Symbol">:</a> <a id="2927" class="PrimitiveType">Set</a><a id="2930" class="Symbol">}</a> <a id="2932" class="Symbol">→</a> <a id="2934" class="Symbol">(</a><a id="2935" href="../Isomorphism/#2921" class="Bound">B</a> <a id="2937" class="Symbol">→</a> <a id="2939" href="../Isomorphism/#2923" class="Bound">C</a><a id="2940" class="Symbol">)</a> <a id="2942" class="Symbol">→</a> <a id="2944" class="Symbol">(</a><a id="2945" href="../Isomorphism/#2919" class="Bound">A</a> <a id="2947" class="Symbol">→</a> <a id="2949" href="../Isomorphism/#2921" class="Bound">B</a><a id="2950" class="Symbol">)</a> <a id="2952" class="Symbol">→</a> <a id="2954" class="Symbol">(</a><a id="2955" href="../Isomorphism/#2919" class="Bound">A</a> <a id="2957" class="Symbol">→</a> <a id="2959" href="../Isomorphism/#2923" class="Bound">C</a><a id="2960" class="Symbol">)</a>
<a id="2962" href="../Isomorphism/#2962" class="Bound">g</a> <a id="2964" href="../Isomorphism/#2909" class="Function Operator">∘′</a> <a id="2967" href="../Isomorphism/#2967" class="Bound">f</a>  <a id="2970" class="Symbol">=</a>  <a id="2973" class="Symbol">λ</a> <a id="2975" href="../Isomorphism/#2975" class="Bound">x</a> <a id="2977" class="Symbol">→</a> <a id="2979" href="../Isomorphism/#2962" class="Bound">g</a> <a id="2981" class="Symbol">(</a><a id="2982" href="../Isomorphism/#2967" class="Bound">f</a> <a id="2984" href="../Isomorphism/#2975" class="Bound">x</a><a id="2985" class="Symbol">)</a>
</pre>
<!--
## Extensionality {name=extensionality}
-->
<h2 name="extensionality" id="外延性extensionality">外延性（Extensionality）</h2>
<!--
Extensionality asserts that the only way to distinguish functions is
by applying them; if two functions applied to the same argument always
yield the same result, then they are the same function.  It is the
converse of `cong-app`, as introduced
[earlier](/Equality/#cong).
-->
<p>外延性断言了区分函数的唯一方法是应用它们。如果两个函数作用在相同的参数上永远返回相同的结果， 那么两个函数相同。这是 <code>cong-app</code> 的逆命题，在<a href="../Equality/#cong">之前</a>有所介绍。</p>
<!--
Agda does not presume extensionality, but we can postulate that it holds:
-->
<p>Agda 并不预设外延性，但我们可以假设其成立：</p>
<pre class="Agda"><a id="3590" class="Keyword">postulate</a>
  <a id="extensionality"></a><a id="3602" href="../Isomorphism/#3602" class="Postulate">extensionality</a> <a id="3617" class="Symbol">:</a> <a id="3619" class="Symbol">∀</a> <a id="3621" class="Symbol">{</a><a id="3622" href="../Isomorphism/#3622" class="Bound">A</a> <a id="3624" href="../Isomorphism/#3624" class="Bound">B</a> <a id="3626" class="Symbol">:</a> <a id="3628" class="PrimitiveType">Set</a><a id="3631" class="Symbol">}</a> <a id="3633" class="Symbol">{</a><a id="3634" href="../Isomorphism/#3634" class="Bound">f</a> <a id="3636" href="../Isomorphism/#3636" class="Bound">g</a> <a id="3638" class="Symbol">:</a> <a id="3640" href="../Isomorphism/#3622" class="Bound">A</a> <a id="3642" class="Symbol">→</a> <a id="3644" href="../Isomorphism/#3624" class="Bound">B</a><a id="3645" class="Symbol">}</a>
    <a id="3651" class="Symbol">→</a> <a id="3653" class="Symbol">(∀</a> <a id="3656" class="Symbol">(</a><a id="3657" href="../Isomorphism/#3657" class="Bound">x</a> <a id="3659" class="Symbol">:</a> <a id="3661" href="../Isomorphism/#3622" class="Bound">A</a><a id="3662" class="Symbol">)</a> <a id="3664" class="Symbol">→</a> <a id="3666" href="../Isomorphism/#3634" class="Bound">f</a> <a id="3668" href="../Isomorphism/#3657" class="Bound">x</a> <a id="3670" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3672" href="../Isomorphism/#3636" class="Bound">g</a> <a id="3674" href="../Isomorphism/#3657" class="Bound">x</a><a id="3675" class="Symbol">)</a>
      <a id="3683" class="Comment">-----------------------</a>
    <a id="3711" class="Symbol">→</a> <a id="3713" href="../Isomorphism/#3634" class="Bound">f</a> <a id="3715" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3717" href="../Isomorphism/#3636" class="Bound">g</a>
</pre>
<!--
Postulating extensionality does not lead to difficulties, as it is
known to be consistent with the theory that underlies Agda.
-->
<p>假设外延性不会造成困顿，因为我们知道它与 Agda 使用的理论是连贯一致的。</p>
<!--
As an example, consider that we need results from two libraries,
one where addition is defined, as in
Chapter [Naturals](/Naturals/),
and one where it is defined the other way around.
-->
<p>举个例子，我们考虑两个库都定义了加法，一个按照我们在 <a href="../Naturals/">Naturals</a> 章节中那样定义，另一个如下，反过来定义：</p>
<pre class="Agda"><a id="_+′_"></a><a id="4171" href="../Isomorphism/#4171" class="Function Operator">_+′_</a> <a id="4176" class="Symbol">:</a> <a id="4178" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="4180" class="Symbol">→</a> <a id="4182" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="4184" class="Symbol">→</a> <a id="4186" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="4188" href="../Isomorphism/#4188" class="Bound">m</a> <a id="4190" href="../Isomorphism/#4171" class="Function Operator">+′</a> <a id="4193" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="4199" class="Symbol">=</a> <a id="4201" href="../Isomorphism/#4188" class="Bound">m</a>
<a id="4203" href="../Isomorphism/#4203" class="Bound">m</a> <a id="4205" href="../Isomorphism/#4171" class="Function Operator">+′</a> <a id="4208" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4212" href="../Isomorphism/#4212" class="Bound">n</a> <a id="4214" class="Symbol">=</a> <a id="4216" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4220" class="Symbol">(</a><a id="4221" href="../Isomorphism/#4203" class="Bound">m</a> <a id="4223" href="../Isomorphism/#4171" class="Function Operator">+′</a> <a id="4226" href="../Isomorphism/#4212" class="Bound">n</a><a id="4227" class="Symbol">)</a>
</pre>
<!--
Applying commutativity, it is easy to show that both operators always
return the same result given the same arguments:
-->
<p>通过使用交换律，我们可以简单地证明两个运算符在给定相同参数的情况下， 会返回相同的值：</p>
<pre class="Agda"><a id="same-app"></a><a id="4412" href="../Isomorphism/#4412" class="Function">same-app</a> <a id="4421" class="Symbol">:</a> <a id="4423" class="Symbol">∀</a> <a id="4425" class="Symbol">(</a><a id="4426" href="../Isomorphism/#4426" class="Bound">m</a> <a id="4428" href="../Isomorphism/#4428" class="Bound">n</a> <a id="4430" class="Symbol">:</a> <a id="4432" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="4433" class="Symbol">)</a> <a id="4435" class="Symbol">→</a> <a id="4437" href="../Isomorphism/#4426" class="Bound">m</a> <a id="4439" href="../Isomorphism/#4171" class="Function Operator">+′</a> <a id="4442" href="../Isomorphism/#4428" class="Bound">n</a> <a id="4444" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4446" href="../Isomorphism/#4426" class="Bound">m</a> <a id="4448" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="4450" href="../Isomorphism/#4428" class="Bound">n</a>
<a id="4452" href="../Isomorphism/#4412" class="Function">same-app</a> <a id="4461" href="../Isomorphism/#4461" class="Bound">m</a> <a id="4463" href="../Isomorphism/#4463" class="Bound">n</a> <a id="4465" class="Keyword">rewrite</a> <a id="4473" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#12823" class="Function">+-comm</a> <a id="4480" href="../Isomorphism/#4461" class="Bound">m</a> <a id="4482" href="../Isomorphism/#4463" class="Bound">n</a> <a id="4484" class="Symbol">=</a> <a id="4486" href="../Isomorphism/#4507" class="Function">helper</a> <a id="4493" href="../Isomorphism/#4461" class="Bound">m</a> <a id="4495" href="../Isomorphism/#4463" class="Bound">n</a>
  <a id="4499" class="Keyword">where</a>
  <a id="4507" href="../Isomorphism/#4507" class="Function">helper</a> <a id="4514" class="Symbol">:</a> <a id="4516" class="Symbol">∀</a> <a id="4518" class="Symbol">(</a><a id="4519" href="../Isomorphism/#4519" class="Bound">m</a> <a id="4521" href="../Isomorphism/#4521" class="Bound">n</a> <a id="4523" class="Symbol">:</a> <a id="4525" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="4526" class="Symbol">)</a> <a id="4528" class="Symbol">→</a> <a id="4530" href="../Isomorphism/#4519" class="Bound">m</a> <a id="4532" href="../Isomorphism/#4171" class="Function Operator">+′</a> <a id="4535" href="../Isomorphism/#4521" class="Bound">n</a> <a id="4537" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4539" href="../Isomorphism/#4521" class="Bound">n</a> <a id="4541" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="4543" href="../Isomorphism/#4519" class="Bound">m</a>
  <a id="4547" href="../Isomorphism/#4507" class="Function">helper</a> <a id="4554" href="../Isomorphism/#4554" class="Bound">m</a> <a id="4556" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="4564" class="Symbol">=</a> <a id="4566" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="4573" href="../Isomorphism/#4507" class="Function">helper</a> <a id="4580" href="../Isomorphism/#4580" class="Bound">m</a> <a id="4582" class="Symbol">(</a><a id="4583" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4587" href="../Isomorphism/#4587" class="Bound">n</a><a id="4588" class="Symbol">)</a> <a id="4590" class="Symbol">=</a> <a id="4592" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="4597" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4601" class="Symbol">(</a><a id="4602" href="../Isomorphism/#4507" class="Function">helper</a> <a id="4609" href="../Isomorphism/#4580" class="Bound">m</a> <a id="4611" href="../Isomorphism/#4587" class="Bound">n</a><a id="4612" class="Symbol">)</a>
</pre>
<!--
However, it might be convenient to assert that the two operators are
actually indistinguishable. This we can do via two applications of
extensionality:
-->
<p>然而，有时断言两个运算符是无法区分的会更加方便。我们可以使用两次外延性：</p>
<pre class="Agda"><a id="same"></a><a id="4823" href="../Isomorphism/#4823" class="Function">same</a> <a id="4828" class="Symbol">:</a> <a id="4830" href="../Isomorphism/#4171" class="Function Operator">_+′_</a> <a id="4835" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4837" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a>
<a id="4841" href="../Isomorphism/#4823" class="Function">same</a> <a id="4846" class="Symbol">=</a> <a id="4848" href="../Isomorphism/#3602" class="Postulate">extensionality</a> <a id="4863" class="Symbol">(λ</a> <a id="4866" href="../Isomorphism/#4866" class="Bound">m</a> <a id="4868" class="Symbol">→</a> <a id="4870" href="../Isomorphism/#3602" class="Postulate">extensionality</a> <a id="4885" class="Symbol">(λ</a> <a id="4888" href="../Isomorphism/#4888" class="Bound">n</a> <a id="4890" class="Symbol">→</a> <a id="4892" href="../Isomorphism/#4412" class="Function">same-app</a> <a id="4901" href="../Isomorphism/#4866" class="Bound">m</a> <a id="4903" href="../Isomorphism/#4888" class="Bound">n</a><a id="4904" class="Symbol">))</a>
</pre>
<!--
We occasionally need to postulate extensionality in what follows.
-->
<p>我们偶尔需要在之后的情况中假设外延性。</p>
More generally, we may wish to postulate extensionality for dependent functions.
<pre class="Agda"><a id="5094" class="Keyword">postulate</a>
  <a id="∀-extensionality"></a><a id="5106" href="../Isomorphism/#5106" class="Postulate">∀-extensionality</a> <a id="5123" class="Symbol">:</a> <a id="5125" class="Symbol">∀</a> <a id="5127" class="Symbol">{</a><a id="5128" href="../Isomorphism/#5128" class="Bound">A</a> <a id="5130" class="Symbol">:</a> <a id="5132" class="PrimitiveType">Set</a><a id="5135" class="Symbol">}</a> <a id="5137" class="Symbol">{</a><a id="5138" href="../Isomorphism/#5138" class="Bound">B</a> <a id="5140" class="Symbol">:</a> <a id="5142" href="../Isomorphism/#5128" class="Bound">A</a> <a id="5144" class="Symbol">→</a> <a id="5146" class="PrimitiveType">Set</a><a id="5149" class="Symbol">}</a> <a id="5151" class="Symbol">{</a><a id="5152" href="../Isomorphism/#5152" class="Bound">f</a> <a id="5154" href="../Isomorphism/#5154" class="Bound">g</a> <a id="5156" class="Symbol">:</a> <a id="5158" class="Symbol">∀(</a><a id="5160" href="../Isomorphism/#5160" class="Bound">x</a> <a id="5162" class="Symbol">:</a> <a id="5164" href="../Isomorphism/#5128" class="Bound">A</a><a id="5165" class="Symbol">)</a> <a id="5167" class="Symbol">→</a> <a id="5169" href="../Isomorphism/#5138" class="Bound">B</a> <a id="5171" href="../Isomorphism/#5160" class="Bound">x</a><a id="5172" class="Symbol">}</a>
    <a id="5178" class="Symbol">→</a> <a id="5180" class="Symbol">(∀</a> <a id="5183" class="Symbol">(</a><a id="5184" href="../Isomorphism/#5184" class="Bound">x</a> <a id="5186" class="Symbol">:</a> <a id="5188" href="../Isomorphism/#5128" class="Bound">A</a><a id="5189" class="Symbol">)</a> <a id="5191" class="Symbol">→</a> <a id="5193" href="../Isomorphism/#5152" class="Bound">f</a> <a id="5195" href="../Isomorphism/#5184" class="Bound">x</a> <a id="5197" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="5199" href="../Isomorphism/#5154" class="Bound">g</a> <a id="5201" href="../Isomorphism/#5184" class="Bound">x</a><a id="5202" class="Symbol">)</a>
      <a id="5210" class="Comment">-----------------------</a>
    <a id="5238" class="Symbol">→</a> <a id="5240" href="../Isomorphism/#5152" class="Bound">f</a> <a id="5242" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="5244" href="../Isomorphism/#5154" class="Bound">g</a>
</pre>
<p>Here the type of <code>f</code> and <code>g</code> has changed from <code>A → B</code> to <code>∀ (x : A) → B x</code>, generalising ordinary functions to dependent functions.</p>
<!--
## Isomorphism
-->
<h2 id="同构isomorphism">同构（Isomorphism）</h2>
<!--
Two sets are isomorphic if they are in one-to-one correspondence.
Here is a formal definition of isomorphism:
-->
<p>如果两个集合有一一对应的关系，那么它们是同构的。 下面是同构的正式定义：</p>
<pre class="Agda"><a id="5591" class="Keyword">infix</a> <a id="5597" class="Number">0</a> <a id="5599" href="../Isomorphism/#5610" class="Record Operator">_≃_</a>
<a id="5603" class="Keyword">record</a> <a id="_≃_"></a><a id="5610" href="../Isomorphism/#5610" class="Record Operator">_≃_</a> <a id="5614" class="Symbol">(</a><a id="5615" href="../Isomorphism/#5615" class="Bound">A</a> <a id="5617" href="../Isomorphism/#5617" class="Bound">B</a> <a id="5619" class="Symbol">:</a> <a id="5621" class="PrimitiveType">Set</a><a id="5624" class="Symbol">)</a> <a id="5626" class="Symbol">:</a> <a id="5628" class="PrimitiveType">Set</a> <a id="5632" class="Keyword">where</a>
  <a id="5640" class="Keyword">field</a>
    <a id="_≃_.to"></a><a id="5650" href="../Isomorphism/#5650" class="Field">to</a>   <a id="5655" class="Symbol">:</a> <a id="5657" href="../Isomorphism/#5615" class="Bound">A</a> <a id="5659" class="Symbol">→</a> <a id="5661" href="../Isomorphism/#5617" class="Bound">B</a>
    <a id="_≃_.from"></a><a id="5667" href="../Isomorphism/#5667" class="Field">from</a> <a id="5672" class="Symbol">:</a> <a id="5674" href="../Isomorphism/#5617" class="Bound">B</a> <a id="5676" class="Symbol">→</a> <a id="5678" href="../Isomorphism/#5615" class="Bound">A</a>
    <a id="_≃_.from∘to"></a><a id="5684" href="../Isomorphism/#5684" class="Field">from∘to</a> <a id="5692" class="Symbol">:</a> <a id="5694" class="Symbol">∀</a> <a id="5696" class="Symbol">(</a><a id="5697" href="../Isomorphism/#5697" class="Bound">x</a> <a id="5699" class="Symbol">:</a> <a id="5701" href="../Isomorphism/#5615" class="Bound">A</a><a id="5702" class="Symbol">)</a> <a id="5704" class="Symbol">→</a> <a id="5706" href="../Isomorphism/#5667" class="Field">from</a> <a id="5711" class="Symbol">(</a><a id="5712" href="../Isomorphism/#5650" class="Field">to</a> <a id="5715" href="../Isomorphism/#5697" class="Bound">x</a><a id="5716" class="Symbol">)</a> <a id="5718" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="5720" href="../Isomorphism/#5697" class="Bound">x</a>
    <a id="_≃_.to∘from"></a><a id="5726" href="../Isomorphism/#5726" class="Field">to∘from</a> <a id="5734" class="Symbol">:</a> <a id="5736" class="Symbol">∀</a> <a id="5738" class="Symbol">(</a><a id="5739" href="../Isomorphism/#5739" class="Bound">y</a> <a id="5741" class="Symbol">:</a> <a id="5743" href="../Isomorphism/#5617" class="Bound">B</a><a id="5744" class="Symbol">)</a> <a id="5746" class="Symbol">→</a> <a id="5748" href="../Isomorphism/#5650" class="Field">to</a> <a id="5751" class="Symbol">(</a><a id="5752" href="../Isomorphism/#5667" class="Field">from</a> <a id="5757" href="../Isomorphism/#5739" class="Bound">y</a><a id="5758" class="Symbol">)</a> <a id="5760" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="5762" href="../Isomorphism/#5739" class="Bound">y</a>
<a id="5764" class="Keyword">open</a> <a id="5769" href="../Isomorphism/#5610" class="Module Operator">_≃_</a>
</pre>
<!--
Let's unpack the definition. An isomorphism between sets `A` and `B` consists
of four things:
  1. A function `to` from `A` to `B`,
  2. A function `from` from `B` back to `A`,
  3. Evidence `from∘to` asserting that `from` is a *left-inverse* for `to`,
  4. Evidence `to∘from` asserting that `from` is a *right-inverse* for `to`.
-->
<p>我们来一一展开这个定义。一个集合 <code>A</code> 和 <code>B</code> 之间的同构有四个要素： 1. 从 <code>A</code> 到 <code>B</code> 的函数 <code>to</code> 2. 从 <code>B</code> 回到 <code>A</code> 的函数 <code>from</code> 3. <code>from</code> 是 <code>to</code> 的<strong>左逆（left-inverse）</strong>的证明 <code>from∘to</code> 4. <code>from</code> 是 <code>to</code> 的<strong>右逆（right-inverse）</strong>的证明 <code>to∘from</code></p>
<!--
In particular, the third asserts that `from ∘ to` is the identity, and
the fourth that `to ∘ from` is the identity, hence the names.
The declaration `open _≃_` makes available the names `to`, `from`,
`from∘to`, and `to∘from`, otherwise we would need to write `_≃_.to` and so on.
-->
<p>具体来说，第三条断言了 <code>from ∘ to</code> 是恒等函数，第四条断言了 <code>to ∘ from</code> 是恒等函数， 它们的名称由此得来。声明 <code>open _≃_</code> 使得 <code>to</code>、<code>from</code>、<code>from∘to</code> 和 <code>to∘from</code> 在当前作用域内可用，否则我们需要使用类似 <code>_≃_.to</code> 的写法。</p>
<!--
The above is our first use of records. A record declaration behaves similar to a single-constructor data declaration (there are minor differences, which we discuss in [Connectives](/Connectives/)):
-->
<p>这是我们第一次使用<strong>记录（Record）</strong>。记录声明的行为类似于一个单构造子的数据声明 （二者稍微有些不同，我们会在 <a href="../Connectives/">Connectives</a> 一章中讨论）：</p>
<pre class="Agda"><a id="7075" class="Keyword">data</a> <a id="_≃′_"></a><a id="7080" href="../Isomorphism/#7080" class="Datatype Operator">_≃′_</a> <a id="7085" class="Symbol">(</a><a id="7086" href="../Isomorphism/#7086" class="Bound">A</a> <a id="7088" href="../Isomorphism/#7088" class="Bound">B</a> <a id="7090" class="Symbol">:</a> <a id="7092" class="PrimitiveType">Set</a><a id="7095" class="Symbol">):</a> <a id="7098" class="PrimitiveType">Set</a> <a id="7102" class="Keyword">where</a>
  <a id="_≃′_.mk-≃′"></a><a id="7110" href="../Isomorphism/#7110" class="InductiveConstructor">mk-≃′</a> <a id="7116" class="Symbol">:</a> <a id="7118" class="Symbol">∀</a> <a id="7120" class="Symbol">(</a><a id="7121" href="../Isomorphism/#7121" class="Bound">to</a> <a id="7124" class="Symbol">:</a> <a id="7126" href="../Isomorphism/#7086" class="Bound">A</a> <a id="7128" class="Symbol">→</a> <a id="7130" href="../Isomorphism/#7088" class="Bound">B</a><a id="7131" class="Symbol">)</a> <a id="7133" class="Symbol">→</a>
          <a id="7145" class="Symbol">∀</a> <a id="7147" class="Symbol">(</a><a id="7148" href="../Isomorphism/#7148" class="Bound">from</a> <a id="7153" class="Symbol">:</a> <a id="7155" href="../Isomorphism/#7088" class="Bound">B</a> <a id="7157" class="Symbol">→</a> <a id="7159" href="../Isomorphism/#7086" class="Bound">A</a><a id="7160" class="Symbol">)</a> <a id="7162" class="Symbol">→</a>
          <a id="7174" class="Symbol">∀</a> <a id="7176" class="Symbol">(</a><a id="7177" href="../Isomorphism/#7177" class="Bound">from∘to</a> <a id="7185" class="Symbol">:</a> <a id="7187" class="Symbol">(∀</a> <a id="7190" class="Symbol">(</a><a id="7191" href="../Isomorphism/#7191" class="Bound">x</a> <a id="7193" class="Symbol">:</a> <a id="7195" href="../Isomorphism/#7086" class="Bound">A</a><a id="7196" class="Symbol">)</a> <a id="7198" class="Symbol">→</a> <a id="7200" href="../Isomorphism/#7148" class="Bound">from</a> <a id="7205" class="Symbol">(</a><a id="7206" href="../Isomorphism/#7121" class="Bound">to</a> <a id="7209" href="../Isomorphism/#7191" class="Bound">x</a><a id="7210" class="Symbol">)</a> <a id="7212" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="7214" href="../Isomorphism/#7191" class="Bound">x</a><a id="7215" class="Symbol">))</a> <a id="7218" class="Symbol">→</a>
          <a id="7230" class="Symbol">∀</a> <a id="7232" class="Symbol">(</a><a id="7233" href="../Isomorphism/#7233" class="Bound">to∘from</a> <a id="7241" class="Symbol">:</a> <a id="7243" class="Symbol">(∀</a> <a id="7246" class="Symbol">(</a><a id="7247" href="../Isomorphism/#7247" class="Bound">y</a> <a id="7249" class="Symbol">:</a> <a id="7251" href="../Isomorphism/#7088" class="Bound">B</a><a id="7252" class="Symbol">)</a> <a id="7254" class="Symbol">→</a> <a id="7256" href="../Isomorphism/#7121" class="Bound">to</a> <a id="7259" class="Symbol">(</a><a id="7260" href="../Isomorphism/#7148" class="Bound">from</a> <a id="7265" href="../Isomorphism/#7247" class="Bound">y</a><a id="7266" class="Symbol">)</a> <a id="7268" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="7270" href="../Isomorphism/#7247" class="Bound">y</a><a id="7271" class="Symbol">))</a> <a id="7274" class="Symbol">→</a>
          <a id="7286" href="../Isomorphism/#7086" class="Bound">A</a> <a id="7288" href="../Isomorphism/#7080" class="Datatype Operator">≃′</a> <a id="7291" href="../Isomorphism/#7088" class="Bound">B</a>

<a id="to′"></a><a id="7294" href="../Isomorphism/#7294" class="Function">to′</a> <a id="7298" class="Symbol">:</a> <a id="7300" class="Symbol">∀</a> <a id="7302" class="Symbol">{</a><a id="7303" href="../Isomorphism/#7303" class="Bound">A</a> <a id="7305" href="../Isomorphism/#7305" class="Bound">B</a> <a id="7307" class="Symbol">:</a> <a id="7309" class="PrimitiveType">Set</a><a id="7312" class="Symbol">}</a> <a id="7314" class="Symbol">→</a> <a id="7316" class="Symbol">(</a><a id="7317" href="../Isomorphism/#7303" class="Bound">A</a> <a id="7319" href="../Isomorphism/#7080" class="Datatype Operator">≃′</a> <a id="7322" href="../Isomorphism/#7305" class="Bound">B</a><a id="7323" class="Symbol">)</a> <a id="7325" class="Symbol">→</a> <a id="7327" class="Symbol">(</a><a id="7328" href="../Isomorphism/#7303" class="Bound">A</a> <a id="7330" class="Symbol">→</a> <a id="7332" href="../Isomorphism/#7305" class="Bound">B</a><a id="7333" class="Symbol">)</a>
<a id="7335" href="../Isomorphism/#7294" class="Function">to′</a> <a id="7339" class="Symbol">(</a><a id="7340" href="../Isomorphism/#7110" class="InductiveConstructor">mk-≃′</a> <a id="7346" href="../Isomorphism/#7346" class="Bound">f</a> <a id="7348" href="../Isomorphism/#7348" class="Bound">g</a> <a id="7350" href="../Isomorphism/#7350" class="Bound">g∘f</a> <a id="7354" href="../Isomorphism/#7354" class="Bound">f∘g</a><a id="7357" class="Symbol">)</a> <a id="7359" class="Symbol">=</a> <a id="7361" href="../Isomorphism/#7346" class="Bound">f</a>

<a id="from′"></a><a id="7364" href="../Isomorphism/#7364" class="Function">from′</a> <a id="7370" class="Symbol">:</a> <a id="7372" class="Symbol">∀</a> <a id="7374" class="Symbol">{</a><a id="7375" href="../Isomorphism/#7375" class="Bound">A</a> <a id="7377" href="../Isomorphism/#7377" class="Bound">B</a> <a id="7379" class="Symbol">:</a> <a id="7381" class="PrimitiveType">Set</a><a id="7384" class="Symbol">}</a> <a id="7386" class="Symbol">→</a> <a id="7388" class="Symbol">(</a><a id="7389" href="../Isomorphism/#7375" class="Bound">A</a> <a id="7391" href="../Isomorphism/#7080" class="Datatype Operator">≃′</a> <a id="7394" href="../Isomorphism/#7377" class="Bound">B</a><a id="7395" class="Symbol">)</a> <a id="7397" class="Symbol">→</a> <a id="7399" class="Symbol">(</a><a id="7400" href="../Isomorphism/#7377" class="Bound">B</a> <a id="7402" class="Symbol">→</a> <a id="7404" href="../Isomorphism/#7375" class="Bound">A</a><a id="7405" class="Symbol">)</a>
<a id="7407" href="../Isomorphism/#7364" class="Function">from′</a> <a id="7413" class="Symbol">(</a><a id="7414" href="../Isomorphism/#7110" class="InductiveConstructor">mk-≃′</a> <a id="7420" href="../Isomorphism/#7420" class="Bound">f</a> <a id="7422" href="../Isomorphism/#7422" class="Bound">g</a> <a id="7424" href="../Isomorphism/#7424" class="Bound">g∘f</a> <a id="7428" href="../Isomorphism/#7428" class="Bound">f∘g</a><a id="7431" class="Symbol">)</a> <a id="7433" class="Symbol">=</a> <a id="7435" href="../Isomorphism/#7422" class="Bound">g</a>

<a id="from∘to′"></a><a id="7438" href="../Isomorphism/#7438" class="Function">from∘to′</a> <a id="7447" class="Symbol">:</a> <a id="7449" class="Symbol">∀</a> <a id="7451" class="Symbol">{</a><a id="7452" href="../Isomorphism/#7452" class="Bound">A</a> <a id="7454" href="../Isomorphism/#7454" class="Bound">B</a> <a id="7456" class="Symbol">:</a> <a id="7458" class="PrimitiveType">Set</a><a id="7461" class="Symbol">}</a> <a id="7463" class="Symbol">→</a> <a id="7465" class="Symbol">(</a><a id="7466" href="../Isomorphism/#7466" class="Bound">A≃B</a> <a id="7470" class="Symbol">:</a> <a id="7472" href="../Isomorphism/#7452" class="Bound">A</a> <a id="7474" href="../Isomorphism/#7080" class="Datatype Operator">≃′</a> <a id="7477" href="../Isomorphism/#7454" class="Bound">B</a><a id="7478" class="Symbol">)</a> <a id="7480" class="Symbol">→</a> <a id="7482" class="Symbol">(∀</a> <a id="7485" class="Symbol">(</a><a id="7486" href="../Isomorphism/#7486" class="Bound">x</a> <a id="7488" class="Symbol">:</a> <a id="7490" href="../Isomorphism/#7452" class="Bound">A</a><a id="7491" class="Symbol">)</a> <a id="7493" class="Symbol">→</a> <a id="7495" href="../Isomorphism/#7364" class="Function">from′</a> <a id="7501" href="../Isomorphism/#7466" class="Bound">A≃B</a> <a id="7505" class="Symbol">(</a><a id="7506" href="../Isomorphism/#7294" class="Function">to′</a> <a id="7510" href="../Isomorphism/#7466" class="Bound">A≃B</a> <a id="7514" href="../Isomorphism/#7486" class="Bound">x</a><a id="7515" class="Symbol">)</a> <a id="7517" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="7519" href="../Isomorphism/#7486" class="Bound">x</a><a id="7520" class="Symbol">)</a>
<a id="7522" href="../Isomorphism/#7438" class="Function">from∘to′</a> <a id="7531" class="Symbol">(</a><a id="7532" href="../Isomorphism/#7110" class="InductiveConstructor">mk-≃′</a> <a id="7538" href="../Isomorphism/#7538" class="Bound">f</a> <a id="7540" href="../Isomorphism/#7540" class="Bound">g</a> <a id="7542" href="../Isomorphism/#7542" class="Bound">g∘f</a> <a id="7546" href="../Isomorphism/#7546" class="Bound">f∘g</a><a id="7549" class="Symbol">)</a> <a id="7551" class="Symbol">=</a> <a id="7553" href="../Isomorphism/#7542" class="Bound">g∘f</a>

<a id="to∘from′"></a><a id="7558" href="../Isomorphism/#7558" class="Function">to∘from′</a> <a id="7567" class="Symbol">:</a> <a id="7569" class="Symbol">∀</a> <a id="7571" class="Symbol">{</a><a id="7572" href="../Isomorphism/#7572" class="Bound">A</a> <a id="7574" href="../Isomorphism/#7574" class="Bound">B</a> <a id="7576" class="Symbol">:</a> <a id="7578" class="PrimitiveType">Set</a><a id="7581" class="Symbol">}</a> <a id="7583" class="Symbol">→</a> <a id="7585" class="Symbol">(</a><a id="7586" href="../Isomorphism/#7586" class="Bound">A≃B</a> <a id="7590" class="Symbol">:</a> <a id="7592" href="../Isomorphism/#7572" class="Bound">A</a> <a id="7594" href="../Isomorphism/#7080" class="Datatype Operator">≃′</a> <a id="7597" href="../Isomorphism/#7574" class="Bound">B</a><a id="7598" class="Symbol">)</a> <a id="7600" class="Symbol">→</a> <a id="7602" class="Symbol">(∀</a> <a id="7605" class="Symbol">(</a><a id="7606" href="../Isomorphism/#7606" class="Bound">y</a> <a id="7608" class="Symbol">:</a> <a id="7610" href="../Isomorphism/#7574" class="Bound">B</a><a id="7611" class="Symbol">)</a> <a id="7613" class="Symbol">→</a> <a id="7615" href="../Isomorphism/#7294" class="Function">to′</a> <a id="7619" href="../Isomorphism/#7586" class="Bound">A≃B</a> <a id="7623" class="Symbol">(</a><a id="7624" href="../Isomorphism/#7364" class="Function">from′</a> <a id="7630" href="../Isomorphism/#7586" class="Bound">A≃B</a> <a id="7634" href="../Isomorphism/#7606" class="Bound">y</a><a id="7635" class="Symbol">)</a> <a id="7637" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="7639" href="../Isomorphism/#7606" class="Bound">y</a><a id="7640" class="Symbol">)</a>
<a id="7642" href="../Isomorphism/#7558" class="Function">to∘from′</a> <a id="7651" class="Symbol">(</a><a id="7652" href="../Isomorphism/#7110" class="InductiveConstructor">mk-≃′</a> <a id="7658" href="../Isomorphism/#7658" class="Bound">f</a> <a id="7660" href="../Isomorphism/#7660" class="Bound">g</a> <a id="7662" href="../Isomorphism/#7662" class="Bound">g∘f</a> <a id="7666" href="../Isomorphism/#7666" class="Bound">f∘g</a><a id="7669" class="Symbol">)</a> <a id="7671" class="Symbol">=</a> <a id="7673" href="../Isomorphism/#7666" class="Bound">f∘g</a>
</pre>
<!--
We construct values of the record type with the syntax
-->
<p>我们用下面的语法来构造一个记录类型的值：</p>
<pre><code>record
  { to    = f
  ; from  = g
  ; from∘to = g∘f
  ; to∘from = f∘g
  }</code></pre>
<!--
which corresponds to using the constructor of the corresponding
inductive type
-->
<p>这与使用相应的归纳类型的构造子对应：</p>
<pre><code>mk-≃′ f g g∘f f∘g</code></pre>
<!--
where `f`, `g`, `g∘f`, and `f∘g` are values of suitable types.
-->
<p>其中 <code>f</code>、<code>g</code>、<code>g∘f</code> 和 <code>f∘g</code> 是相应类型的值。</p>
<!--
## Isomorphism is an equivalence
-->
<h2 id="同构是一个等价关系">同构是一个等价关系</h2>
<!--
Isomorphism is an equivalence, meaning that it is reflexive, symmetric,
and transitive.  To show isomorphism is reflexive, we take both `to`
and `from` to be the identity function:
-->
<p>同构是一个等价关系。这意味着它自反、对称、传递。要证明同构是自反的，我们用恒等函数 作为 <code>to</code> 和 <code>from</code>：</p>
<pre class="Agda"><a id="≃-refl"></a><a id="8423" href="../Isomorphism/#8423" class="Function">≃-refl</a> <a id="8430" class="Symbol">:</a> <a id="8432" class="Symbol">∀</a> <a id="8434" class="Symbol">{</a><a id="8435" href="../Isomorphism/#8435" class="Bound">A</a> <a id="8437" class="Symbol">:</a> <a id="8439" class="PrimitiveType">Set</a><a id="8442" class="Symbol">}</a>
    <a id="8448" class="Comment">-----</a>
  <a id="8456" class="Symbol">→</a> <a id="8458" href="../Isomorphism/#8435" class="Bound">A</a> <a id="8460" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="8462" href="../Isomorphism/#8435" class="Bound">A</a>
<a id="8464" href="../Isomorphism/#8423" class="Function">≃-refl</a> <a id="8471" class="Symbol">=</a>
  <a id="8475" class="Keyword">record</a>
    <a id="8486" class="Symbol">{</a> <a id="8488" href="../Isomorphism/#5650" class="Field">to</a>      <a id="8496" class="Symbol">=</a> <a id="8498" class="Symbol">λ{</a><a id="8500" href="../Isomorphism/#8500" class="Bound">x</a> <a id="8502" class="Symbol">→</a> <a id="8504" href="../Isomorphism/#8500" class="Bound">x</a><a id="8505" class="Symbol">}</a>
    <a id="8511" class="Symbol">;</a> <a id="8513" href="../Isomorphism/#5667" class="Field">from</a>    <a id="8521" class="Symbol">=</a> <a id="8523" class="Symbol">λ{</a><a id="8525" href="../Isomorphism/#8525" class="Bound">y</a> <a id="8527" class="Symbol">→</a> <a id="8529" href="../Isomorphism/#8525" class="Bound">y</a><a id="8530" class="Symbol">}</a>
    <a id="8536" class="Symbol">;</a> <a id="8538" href="../Isomorphism/#5684" class="Field">from∘to</a> <a id="8546" class="Symbol">=</a> <a id="8548" class="Symbol">λ{</a><a id="8550" href="../Isomorphism/#8550" class="Bound">x</a> <a id="8552" class="Symbol">→</a> <a id="8554" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="8558" class="Symbol">}</a>
    <a id="8564" class="Symbol">;</a> <a id="8566" href="../Isomorphism/#5726" class="Field">to∘from</a> <a id="8574" class="Symbol">=</a> <a id="8576" class="Symbol">λ{</a><a id="8578" href="../Isomorphism/#8578" class="Bound">y</a> <a id="8580" class="Symbol">→</a> <a id="8582" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="8586" class="Symbol">}</a>
    <a id="8592" class="Symbol">}</a>
</pre>
<!--
In the above, `to` and `from` are both bound to identity functions,
and `from∘to` and `to∘from` are both bound to functions that discard
their argument and return `refl`.  In this case, `refl` alone is an
adequate proof since for the left inverse, `from (to x)`
simplifies to `x`, and similarly for the right inverse.
-->
<p>如上，<code>to</code> 和 <code>from</code> 都是恒等函数，<code>from∘to</code> 和 <code>to∘from</code> 都是丢弃参数、返回 <code>refl</code> 的函数。在这样的情况下，<code>refl</code> 足够可以证明左逆，因为 <code>from (to x)</code> 化简为 <code>x</code>。右逆的证明同理。</p>
<!--
To show isomorphism is symmetric, we simply swap the roles of `to`
and `from`, and `from∘to` and `to∘from`:
-->
<p>要证明同构是对称的，我们把 <code>to</code> 和 <code>from</code>、<code>from∘to</code> 和 <code>to∘from</code> 互换：</p>
<pre class="Agda"><a id="≃-sym"></a><a id="9230" href="../Isomorphism/#9230" class="Function">≃-sym</a> <a id="9236" class="Symbol">:</a> <a id="9238" class="Symbol">∀</a> <a id="9240" class="Symbol">{</a><a id="9241" href="../Isomorphism/#9241" class="Bound">A</a> <a id="9243" href="../Isomorphism/#9243" class="Bound">B</a> <a id="9245" class="Symbol">:</a> <a id="9247" class="PrimitiveType">Set</a><a id="9250" class="Symbol">}</a>
  <a id="9254" class="Symbol">→</a> <a id="9256" href="../Isomorphism/#9241" class="Bound">A</a> <a id="9258" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="9260" href="../Isomorphism/#9243" class="Bound">B</a>
    <a id="9266" class="Comment">-----</a>
  <a id="9274" class="Symbol">→</a> <a id="9276" href="../Isomorphism/#9243" class="Bound">B</a> <a id="9278" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="9280" href="../Isomorphism/#9241" class="Bound">A</a>
<a id="9282" href="../Isomorphism/#9230" class="Function">≃-sym</a> <a id="9288" href="../Isomorphism/#9288" class="Bound">A≃B</a> <a id="9292" class="Symbol">=</a>
  <a id="9296" class="Keyword">record</a>
    <a id="9307" class="Symbol">{</a> <a id="9309" href="../Isomorphism/#5650" class="Field">to</a>      <a id="9317" class="Symbol">=</a> <a id="9319" href="../Isomorphism/#5667" class="Field">from</a> <a id="9324" href="../Isomorphism/#9288" class="Bound">A≃B</a>
    <a id="9332" class="Symbol">;</a> <a id="9334" href="../Isomorphism/#5667" class="Field">from</a>    <a id="9342" class="Symbol">=</a> <a id="9344" href="../Isomorphism/#5650" class="Field">to</a>   <a id="9349" href="../Isomorphism/#9288" class="Bound">A≃B</a>
    <a id="9357" class="Symbol">;</a> <a id="9359" href="../Isomorphism/#5684" class="Field">from∘to</a> <a id="9367" class="Symbol">=</a> <a id="9369" href="../Isomorphism/#5726" class="Field">to∘from</a> <a id="9377" href="../Isomorphism/#9288" class="Bound">A≃B</a>
    <a id="9385" class="Symbol">;</a> <a id="9387" href="../Isomorphism/#5726" class="Field">to∘from</a> <a id="9395" class="Symbol">=</a> <a id="9397" href="../Isomorphism/#5684" class="Field">from∘to</a> <a id="9405" href="../Isomorphism/#9288" class="Bound">A≃B</a>
    <a id="9413" class="Symbol">}</a>
</pre>
<!--
To show isomorphism is transitive, we compose the `to` and `from`
functions, and use equational reasoning to combine the inverses:
-->
<p>要证明同构是传递的，我们将 <code>to</code> 和 <code>from</code> 函数进行组合，并使用相等性论证来结合左逆和右逆：</p>
<pre class="Agda"><a id="≃-trans"></a><a id="9619" href="../Isomorphism/#9619" class="Function">≃-trans</a> <a id="9627" class="Symbol">:</a> <a id="9629" class="Symbol">∀</a> <a id="9631" class="Symbol">{</a><a id="9632" href="../Isomorphism/#9632" class="Bound">A</a> <a id="9634" href="../Isomorphism/#9634" class="Bound">B</a> <a id="9636" href="../Isomorphism/#9636" class="Bound">C</a> <a id="9638" class="Symbol">:</a> <a id="9640" class="PrimitiveType">Set</a><a id="9643" class="Symbol">}</a>
  <a id="9647" class="Symbol">→</a> <a id="9649" href="../Isomorphism/#9632" class="Bound">A</a> <a id="9651" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="9653" href="../Isomorphism/#9634" class="Bound">B</a>
  <a id="9657" class="Symbol">→</a> <a id="9659" href="../Isomorphism/#9634" class="Bound">B</a> <a id="9661" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="9663" href="../Isomorphism/#9636" class="Bound">C</a>
    <a id="9669" class="Comment">-----</a>
  <a id="9677" class="Symbol">→</a> <a id="9679" href="../Isomorphism/#9632" class="Bound">A</a> <a id="9681" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="9683" href="../Isomorphism/#9636" class="Bound">C</a>
<a id="9685" href="../Isomorphism/#9619" class="Function">≃-trans</a> <a id="9693" href="../Isomorphism/#9693" class="Bound">A≃B</a> <a id="9697" href="../Isomorphism/#9697" class="Bound">B≃C</a> <a id="9701" class="Symbol">=</a>
  <a id="9705" class="Keyword">record</a>
    <a id="9716" class="Symbol">{</a> <a id="9718" href="../Isomorphism/#5650" class="Field">to</a>       <a id="9727" class="Symbol">=</a> <a id="9729" href="../Isomorphism/#5650" class="Field">to</a>   <a id="9734" href="../Isomorphism/#9697" class="Bound">B≃C</a> <a id="9738" href="../Isomorphism/#2607" class="Function Operator">∘</a> <a id="9740" href="../Isomorphism/#5650" class="Field">to</a>   <a id="9745" href="../Isomorphism/#9693" class="Bound">A≃B</a>
    <a id="9753" class="Symbol">;</a> <a id="9755" href="../Isomorphism/#5667" class="Field">from</a>     <a id="9764" class="Symbol">=</a> <a id="9766" href="../Isomorphism/#5667" class="Field">from</a> <a id="9771" href="../Isomorphism/#9693" class="Bound">A≃B</a> <a id="9775" href="../Isomorphism/#2607" class="Function Operator">∘</a> <a id="9777" href="../Isomorphism/#5667" class="Field">from</a> <a id="9782" href="../Isomorphism/#9697" class="Bound">B≃C</a>
    <a id="9790" class="Symbol">;</a> <a id="9792" href="../Isomorphism/#5684" class="Field">from∘to</a>  <a id="9801" class="Symbol">=</a> <a id="9803" class="Symbol">λ{</a><a id="9805" href="../Isomorphism/#9805" class="Bound">x</a> <a id="9807" class="Symbol">→</a>
        <a id="9817" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
          <a id="9833" class="Symbol">(</a><a id="9834" href="../Isomorphism/#5667" class="Field">from</a> <a id="9839" href="../Isomorphism/#9693" class="Bound">A≃B</a> <a id="9843" href="../Isomorphism/#2607" class="Function Operator">∘</a> <a id="9845" href="../Isomorphism/#5667" class="Field">from</a> <a id="9850" href="../Isomorphism/#9697" class="Bound">B≃C</a><a id="9853" class="Symbol">)</a> <a id="9855" class="Symbol">((</a><a id="9857" href="../Isomorphism/#5650" class="Field">to</a> <a id="9860" href="../Isomorphism/#9697" class="Bound">B≃C</a> <a id="9864" href="../Isomorphism/#2607" class="Function Operator">∘</a> <a id="9866" href="../Isomorphism/#5650" class="Field">to</a> <a id="9869" href="../Isomorphism/#9693" class="Bound">A≃B</a><a id="9872" class="Symbol">)</a> <a id="9874" href="../Isomorphism/#9805" class="Bound">x</a><a id="9875" class="Symbol">)</a>
        <a id="9885" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
          <a id="9899" href="../Isomorphism/#5667" class="Field">from</a> <a id="9904" href="../Isomorphism/#9693" class="Bound">A≃B</a> <a id="9908" class="Symbol">(</a><a id="9909" href="../Isomorphism/#5667" class="Field">from</a> <a id="9914" href="../Isomorphism/#9697" class="Bound">B≃C</a> <a id="9918" class="Symbol">(</a><a id="9919" href="../Isomorphism/#5650" class="Field">to</a> <a id="9922" href="../Isomorphism/#9697" class="Bound">B≃C</a> <a id="9926" class="Symbol">(</a><a id="9927" href="../Isomorphism/#5650" class="Field">to</a> <a id="9930" href="../Isomorphism/#9693" class="Bound">A≃B</a> <a id="9934" href="../Isomorphism/#9805" class="Bound">x</a><a id="9935" class="Symbol">)))</a>
        <a id="9947" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="9950" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="9955" class="Symbol">(</a><a id="9956" href="../Isomorphism/#5667" class="Field">from</a> <a id="9961" href="../Isomorphism/#9693" class="Bound">A≃B</a><a id="9964" class="Symbol">)</a> <a id="9966" class="Symbol">(</a><a id="9967" href="../Isomorphism/#5684" class="Field">from∘to</a> <a id="9975" href="../Isomorphism/#9697" class="Bound">B≃C</a> <a id="9979" class="Symbol">(</a><a id="9980" href="../Isomorphism/#5650" class="Field">to</a> <a id="9983" href="../Isomorphism/#9693" class="Bound">A≃B</a> <a id="9987" href="../Isomorphism/#9805" class="Bound">x</a><a id="9988" class="Symbol">))</a> <a id="9991" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
          <a id="10003" href="../Isomorphism/#5667" class="Field">from</a> <a id="10008" href="../Isomorphism/#9693" class="Bound">A≃B</a> <a id="10012" class="Symbol">(</a><a id="10013" href="../Isomorphism/#5650" class="Field">to</a> <a id="10016" href="../Isomorphism/#9693" class="Bound">A≃B</a> <a id="10020" href="../Isomorphism/#9805" class="Bound">x</a><a id="10021" class="Symbol">)</a>
        <a id="10031" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="10034" href="../Isomorphism/#5684" class="Field">from∘to</a> <a id="10042" href="../Isomorphism/#9693" class="Bound">A≃B</a> <a id="10046" href="../Isomorphism/#9805" class="Bound">x</a> <a id="10048" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
          <a id="10060" href="../Isomorphism/#9805" class="Bound">x</a>
        <a id="10070" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a><a id="10071" class="Symbol">}</a>
    <a id="10077" class="Symbol">;</a> <a id="10079" href="../Isomorphism/#5726" class="Field">to∘from</a> <a id="10087" class="Symbol">=</a> <a id="10089" class="Symbol">λ{</a><a id="10091" href="../Isomorphism/#10091" class="Bound">y</a> <a id="10093" class="Symbol">→</a>
        <a id="10103" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
          <a id="10119" class="Symbol">(</a><a id="10120" href="../Isomorphism/#5650" class="Field">to</a> <a id="10123" href="../Isomorphism/#9697" class="Bound">B≃C</a> <a id="10127" href="../Isomorphism/#2607" class="Function Operator">∘</a> <a id="10129" href="../Isomorphism/#5650" class="Field">to</a> <a id="10132" href="../Isomorphism/#9693" class="Bound">A≃B</a><a id="10135" class="Symbol">)</a> <a id="10137" class="Symbol">((</a><a id="10139" href="../Isomorphism/#5667" class="Field">from</a> <a id="10144" href="../Isomorphism/#9693" class="Bound">A≃B</a> <a id="10148" href="../Isomorphism/#2607" class="Function Operator">∘</a> <a id="10150" href="../Isomorphism/#5667" class="Field">from</a> <a id="10155" href="../Isomorphism/#9697" class="Bound">B≃C</a><a id="10158" class="Symbol">)</a> <a id="10160" href="../Isomorphism/#10091" class="Bound">y</a><a id="10161" class="Symbol">)</a>
        <a id="10171" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
          <a id="10185" href="../Isomorphism/#5650" class="Field">to</a> <a id="10188" href="../Isomorphism/#9697" class="Bound">B≃C</a> <a id="10192" class="Symbol">(</a><a id="10193" href="../Isomorphism/#5650" class="Field">to</a> <a id="10196" href="../Isomorphism/#9693" class="Bound">A≃B</a> <a id="10200" class="Symbol">(</a><a id="10201" href="../Isomorphism/#5667" class="Field">from</a> <a id="10206" href="../Isomorphism/#9693" class="Bound">A≃B</a> <a id="10210" class="Symbol">(</a><a id="10211" href="../Isomorphism/#5667" class="Field">from</a> <a id="10216" href="../Isomorphism/#9697" class="Bound">B≃C</a> <a id="10220" href="../Isomorphism/#10091" class="Bound">y</a><a id="10221" class="Symbol">)))</a>
        <a id="10233" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="10236" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="10241" class="Symbol">(</a><a id="10242" href="../Isomorphism/#5650" class="Field">to</a> <a id="10245" href="../Isomorphism/#9697" class="Bound">B≃C</a><a id="10248" class="Symbol">)</a> <a id="10250" class="Symbol">(</a><a id="10251" href="../Isomorphism/#5726" class="Field">to∘from</a> <a id="10259" href="../Isomorphism/#9693" class="Bound">A≃B</a> <a id="10263" class="Symbol">(</a><a id="10264" href="../Isomorphism/#5667" class="Field">from</a> <a id="10269" href="../Isomorphism/#9697" class="Bound">B≃C</a> <a id="10273" href="../Isomorphism/#10091" class="Bound">y</a><a id="10274" class="Symbol">))</a> <a id="10277" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
          <a id="10289" href="../Isomorphism/#5650" class="Field">to</a> <a id="10292" href="../Isomorphism/#9697" class="Bound">B≃C</a> <a id="10296" class="Symbol">(</a><a id="10297" href="../Isomorphism/#5667" class="Field">from</a> <a id="10302" href="../Isomorphism/#9697" class="Bound">B≃C</a> <a id="10306" href="../Isomorphism/#10091" class="Bound">y</a><a id="10307" class="Symbol">)</a>
        <a id="10317" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="10320" href="../Isomorphism/#5726" class="Field">to∘from</a> <a id="10328" href="../Isomorphism/#9697" class="Bound">B≃C</a> <a id="10332" href="../Isomorphism/#10091" class="Bound">y</a> <a id="10334" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
          <a id="10346" href="../Isomorphism/#10091" class="Bound">y</a>
        <a id="10356" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a><a id="10357" class="Symbol">}</a>
     <a id="10364" class="Symbol">}</a>
</pre>
<!--
## Equational reasoning for isomorphism
-->
<h2 id="同构的相等性论证">同构的相等性论证</h2>
<!--
It is straightforward to support a variant of equational reasoning for
isomorphism.  We essentially copy the previous definition
of equality for isomorphism.  We omit the form that corresponds to `_≡⟨⟩_`, since
trivial isomorphisms arise far less often than trivial equalities:
-->
<p>我们可以直接的构造一种同构的相等性论证方法。我们对之前的相等性论证定义进行修改。 我们省略 <code>_≡⟨⟩_</code> 的定义，因为简单的同构比简单的相等性出现的少很多：</p>
<pre class="Agda"><a id="10808" class="Keyword">module</a> <a id="≃-Reasoning"></a><a id="10815" href="../Isomorphism/#10815" class="Module">≃-Reasoning</a> <a id="10827" class="Keyword">where</a>

  <a id="10836" class="Keyword">infix</a>  <a id="10843" class="Number">1</a> <a id="10845" href="../Isomorphism/#10891" class="Function Operator">≃-begin_</a>
  <a id="10856" class="Keyword">infixr</a> <a id="10863" class="Number">2</a> <a id="10865" href="../Isomorphism/#10975" class="Function Operator">_≃⟨_⟩_</a>
  <a id="10874" class="Keyword">infix</a>  <a id="10881" class="Number">3</a> <a id="10883" href="../Isomorphism/#11094" class="Function Operator">_≃-∎</a>

  <a id="≃-Reasoning.≃-begin_"></a><a id="10891" href="../Isomorphism/#10891" class="Function Operator">≃-begin_</a> <a id="10900" class="Symbol">:</a> <a id="10902" class="Symbol">∀</a> <a id="10904" class="Symbol">{</a><a id="10905" href="../Isomorphism/#10905" class="Bound">A</a> <a id="10907" href="../Isomorphism/#10907" class="Bound">B</a> <a id="10909" class="Symbol">:</a> <a id="10911" class="PrimitiveType">Set</a><a id="10914" class="Symbol">}</a>
    <a id="10920" class="Symbol">→</a> <a id="10922" href="../Isomorphism/#10905" class="Bound">A</a> <a id="10924" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="10926" href="../Isomorphism/#10907" class="Bound">B</a>
      <a id="10934" class="Comment">-----</a>
    <a id="10944" class="Symbol">→</a> <a id="10946" href="../Isomorphism/#10905" class="Bound">A</a> <a id="10948" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="10950" href="../Isomorphism/#10907" class="Bound">B</a>
  <a id="10954" href="../Isomorphism/#10891" class="Function Operator">≃-begin</a> <a id="10962" href="../Isomorphism/#10962" class="Bound">A≃B</a> <a id="10966" class="Symbol">=</a> <a id="10968" href="../Isomorphism/#10962" class="Bound">A≃B</a>

  <a id="≃-Reasoning._≃⟨_⟩_"></a><a id="10975" href="../Isomorphism/#10975" class="Function Operator">_≃⟨_⟩_</a> <a id="10982" class="Symbol">:</a> <a id="10984" class="Symbol">∀</a> <a id="10986" class="Symbol">(</a><a id="10987" href="../Isomorphism/#10987" class="Bound">A</a> <a id="10989" class="Symbol">:</a> <a id="10991" class="PrimitiveType">Set</a><a id="10994" class="Symbol">)</a> <a id="10996" class="Symbol">{</a><a id="10997" href="../Isomorphism/#10997" class="Bound">B</a> <a id="10999" href="../Isomorphism/#10999" class="Bound">C</a> <a id="11001" class="Symbol">:</a> <a id="11003" class="PrimitiveType">Set</a><a id="11006" class="Symbol">}</a>
    <a id="11012" class="Symbol">→</a> <a id="11014" href="../Isomorphism/#10987" class="Bound">A</a> <a id="11016" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="11018" href="../Isomorphism/#10997" class="Bound">B</a>
    <a id="11024" class="Symbol">→</a> <a id="11026" href="../Isomorphism/#10997" class="Bound">B</a> <a id="11028" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="11030" href="../Isomorphism/#10999" class="Bound">C</a>
      <a id="11038" class="Comment">-----</a>
    <a id="11048" class="Symbol">→</a> <a id="11050" href="../Isomorphism/#10987" class="Bound">A</a> <a id="11052" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="11054" href="../Isomorphism/#10999" class="Bound">C</a>
  <a id="11058" href="../Isomorphism/#11058" class="Bound">A</a> <a id="11060" href="../Isomorphism/#10975" class="Function Operator">≃⟨</a> <a id="11063" href="../Isomorphism/#11063" class="Bound">A≃B</a> <a id="11067" href="../Isomorphism/#10975" class="Function Operator">⟩</a> <a id="11069" href="../Isomorphism/#11069" class="Bound">B≃C</a> <a id="11073" class="Symbol">=</a> <a id="11075" href="../Isomorphism/#9619" class="Function">≃-trans</a> <a id="11083" href="../Isomorphism/#11063" class="Bound">A≃B</a> <a id="11087" href="../Isomorphism/#11069" class="Bound">B≃C</a>

  <a id="≃-Reasoning._≃-∎"></a><a id="11094" href="../Isomorphism/#11094" class="Function Operator">_≃-∎</a> <a id="11099" class="Symbol">:</a> <a id="11101" class="Symbol">∀</a> <a id="11103" class="Symbol">(</a><a id="11104" href="../Isomorphism/#11104" class="Bound">A</a> <a id="11106" class="Symbol">:</a> <a id="11108" class="PrimitiveType">Set</a><a id="11111" class="Symbol">)</a>
      <a id="11119" class="Comment">-----</a>
    <a id="11129" class="Symbol">→</a> <a id="11131" href="../Isomorphism/#11104" class="Bound">A</a> <a id="11133" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="11135" href="../Isomorphism/#11104" class="Bound">A</a>
  <a id="11139" href="../Isomorphism/#11139" class="Bound">A</a> <a id="11141" href="../Isomorphism/#11094" class="Function Operator">≃-∎</a> <a id="11145" class="Symbol">=</a> <a id="11147" href="../Isomorphism/#8423" class="Function">≃-refl</a>

<a id="11155" class="Keyword">open</a> <a id="11160" href="../Isomorphism/#10815" class="Module">≃-Reasoning</a>
</pre>
<!--
## Embedding
-->
<h2 id="嵌入embedding">嵌入（Embedding）</h2>
<!--
We also need the notion of _embedding_, which is a weakening of
isomorphism.  While an isomorphism shows that two types are in
one-to-one correspondence, an embedding shows that the first type is
included in the second; or, equivalently, that there is a many-to-one
correspondence between the second type and the first.
-->
<p>我们同时也需要<strong>嵌入</strong>的概念，它是同构的弱化概念。同构要求证明两个类型之间的一一对应， 而嵌入只需要第一种类型涵盖在第二种类型内，所以两个类型之间有一对多的对应关系。</p>
<!--
Here is the formal definition of embedding:
-->
<p>嵌入的正式定义如下：</p>
<pre class="Agda"><a id="11706" class="Keyword">infix</a> <a id="11712" class="Number">0</a> <a id="11714" href="../Isomorphism/#11725" class="Record Operator">_≲_</a>
<a id="11718" class="Keyword">record</a> <a id="_≲_"></a><a id="11725" href="../Isomorphism/#11725" class="Record Operator">_≲_</a> <a id="11729" class="Symbol">(</a><a id="11730" href="../Isomorphism/#11730" class="Bound">A</a> <a id="11732" href="../Isomorphism/#11732" class="Bound">B</a> <a id="11734" class="Symbol">:</a> <a id="11736" class="PrimitiveType">Set</a><a id="11739" class="Symbol">)</a> <a id="11741" class="Symbol">:</a> <a id="11743" class="PrimitiveType">Set</a> <a id="11747" class="Keyword">where</a>
  <a id="11755" class="Keyword">field</a>
    <a id="_≲_.to"></a><a id="11765" href="../Isomorphism/#11765" class="Field">to</a>      <a id="11773" class="Symbol">:</a> <a id="11775" href="../Isomorphism/#11730" class="Bound">A</a> <a id="11777" class="Symbol">→</a> <a id="11779" href="../Isomorphism/#11732" class="Bound">B</a>
    <a id="_≲_.from"></a><a id="11785" href="../Isomorphism/#11785" class="Field">from</a>    <a id="11793" class="Symbol">:</a> <a id="11795" href="../Isomorphism/#11732" class="Bound">B</a> <a id="11797" class="Symbol">→</a> <a id="11799" href="../Isomorphism/#11730" class="Bound">A</a>
    <a id="_≲_.from∘to"></a><a id="11805" href="../Isomorphism/#11805" class="Field">from∘to</a> <a id="11813" class="Symbol">:</a> <a id="11815" class="Symbol">∀</a> <a id="11817" class="Symbol">(</a><a id="11818" href="../Isomorphism/#11818" class="Bound">x</a> <a id="11820" class="Symbol">:</a> <a id="11822" href="../Isomorphism/#11730" class="Bound">A</a><a id="11823" class="Symbol">)</a> <a id="11825" class="Symbol">→</a> <a id="11827" class="Field">from</a> <a id="11832" class="Symbol">(</a><a id="11833" class="Field">to</a> <a id="11836" href="../Isomorphism/#11818" class="Bound">x</a><a id="11837" class="Symbol">)</a> <a id="11839" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="11841" href="../Isomorphism/#11818" class="Bound">x</a>
<a id="11843" class="Keyword">open</a> <a id="11848" href="../Isomorphism/#11725" class="Module Operator">_≲_</a>
</pre>
<!--
It is the same as an isomorphism, save that it lacks the `to∘from` field.
Hence, we know that `from` is left-inverse to `to`, but not that `from`
is right-inverse to `to`.
-->
<p>除了它缺少了 <code>to∘from</code> 字段以外，嵌入的定义和同构是一样的。因此，我们可以得知 <code>from</code> 是 <code>to</code> 的左逆，但是 <code>from</code> 不是 <code>to</code> 的右逆。</p>
<!--
Embedding is reflexive and transitive, but not symmetric.  The proofs
are cut down versions of the similar proofs for isomorphism:
-->
<p>嵌入是自反和传递的，但不是对称的。证明与同构类似，不过去除了不需要的部分：</p>
<pre class="Agda"><a id="≲-refl"></a><a id="12310" href="../Isomorphism/#12310" class="Function">≲-refl</a> <a id="12317" class="Symbol">:</a> <a id="12319" class="Symbol">∀</a> <a id="12321" class="Symbol">{</a><a id="12322" href="../Isomorphism/#12322" class="Bound">A</a> <a id="12324" class="Symbol">:</a> <a id="12326" class="PrimitiveType">Set</a><a id="12329" class="Symbol">}</a> <a id="12331" class="Symbol">→</a> <a id="12333" href="../Isomorphism/#12322" class="Bound">A</a> <a id="12335" href="../Isomorphism/#11725" class="Record Operator">≲</a> <a id="12337" href="../Isomorphism/#12322" class="Bound">A</a>
<a id="12339" href="../Isomorphism/#12310" class="Function">≲-refl</a> <a id="12346" class="Symbol">=</a>
  <a id="12350" class="Keyword">record</a>
    <a id="12361" class="Symbol">{</a> <a id="12363" href="../Isomorphism/#11765" class="Field">to</a>      <a id="12371" class="Symbol">=</a> <a id="12373" class="Symbol">λ{</a><a id="12375" href="../Isomorphism/#12375" class="Bound">x</a> <a id="12377" class="Symbol">→</a> <a id="12379" href="../Isomorphism/#12375" class="Bound">x</a><a id="12380" class="Symbol">}</a>
    <a id="12386" class="Symbol">;</a> <a id="12388" href="../Isomorphism/#11785" class="Field">from</a>    <a id="12396" class="Symbol">=</a> <a id="12398" class="Symbol">λ{</a><a id="12400" href="../Isomorphism/#12400" class="Bound">y</a> <a id="12402" class="Symbol">→</a> <a id="12404" href="../Isomorphism/#12400" class="Bound">y</a><a id="12405" class="Symbol">}</a>
    <a id="12411" class="Symbol">;</a> <a id="12413" href="../Isomorphism/#11805" class="Field">from∘to</a> <a id="12421" class="Symbol">=</a> <a id="12423" class="Symbol">λ{</a><a id="12425" href="../Isomorphism/#12425" class="Bound">x</a> <a id="12427" class="Symbol">→</a> <a id="12429" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="12433" class="Symbol">}</a>
    <a id="12439" class="Symbol">}</a>

<a id="≲-trans"></a><a id="12442" href="../Isomorphism/#12442" class="Function">≲-trans</a> <a id="12450" class="Symbol">:</a> <a id="12452" class="Symbol">∀</a> <a id="12454" class="Symbol">{</a><a id="12455" href="../Isomorphism/#12455" class="Bound">A</a> <a id="12457" href="../Isomorphism/#12457" class="Bound">B</a> <a id="12459" href="../Isomorphism/#12459" class="Bound">C</a> <a id="12461" class="Symbol">:</a> <a id="12463" class="PrimitiveType">Set</a><a id="12466" class="Symbol">}</a> <a id="12468" class="Symbol">→</a> <a id="12470" href="../Isomorphism/#12455" class="Bound">A</a> <a id="12472" href="../Isomorphism/#11725" class="Record Operator">≲</a> <a id="12474" href="../Isomorphism/#12457" class="Bound">B</a> <a id="12476" class="Symbol">→</a> <a id="12478" href="../Isomorphism/#12457" class="Bound">B</a> <a id="12480" href="../Isomorphism/#11725" class="Record Operator">≲</a> <a id="12482" href="../Isomorphism/#12459" class="Bound">C</a> <a id="12484" class="Symbol">→</a> <a id="12486" href="../Isomorphism/#12455" class="Bound">A</a> <a id="12488" href="../Isomorphism/#11725" class="Record Operator">≲</a> <a id="12490" href="../Isomorphism/#12459" class="Bound">C</a>
<a id="12492" href="../Isomorphism/#12442" class="Function">≲-trans</a> <a id="12500" href="../Isomorphism/#12500" class="Bound">A≲B</a> <a id="12504" href="../Isomorphism/#12504" class="Bound">B≲C</a> <a id="12508" class="Symbol">=</a>
  <a id="12512" class="Keyword">record</a>
    <a id="12523" class="Symbol">{</a> <a id="12525" href="../Isomorphism/#11765" class="Field">to</a>      <a id="12533" class="Symbol">=</a> <a id="12535" class="Symbol">λ{</a><a id="12537" href="../Isomorphism/#12537" class="Bound">x</a> <a id="12539" class="Symbol">→</a> <a id="12541" href="../Isomorphism/#11765" class="Field">to</a>   <a id="12546" href="../Isomorphism/#12504" class="Bound">B≲C</a> <a id="12550" class="Symbol">(</a><a id="12551" href="../Isomorphism/#11765" class="Field">to</a>   <a id="12556" href="../Isomorphism/#12500" class="Bound">A≲B</a> <a id="12560" href="../Isomorphism/#12537" class="Bound">x</a><a id="12561" class="Symbol">)}</a>
    <a id="12568" class="Symbol">;</a> <a id="12570" href="../Isomorphism/#11785" class="Field">from</a>    <a id="12578" class="Symbol">=</a> <a id="12580" class="Symbol">λ{</a><a id="12582" href="../Isomorphism/#12582" class="Bound">y</a> <a id="12584" class="Symbol">→</a> <a id="12586" href="../Isomorphism/#11785" class="Field">from</a> <a id="12591" href="../Isomorphism/#12500" class="Bound">A≲B</a> <a id="12595" class="Symbol">(</a><a id="12596" href="../Isomorphism/#11785" class="Field">from</a> <a id="12601" href="../Isomorphism/#12504" class="Bound">B≲C</a> <a id="12605" href="../Isomorphism/#12582" class="Bound">y</a><a id="12606" class="Symbol">)}</a>
    <a id="12613" class="Symbol">;</a> <a id="12615" href="../Isomorphism/#11805" class="Field">from∘to</a> <a id="12623" class="Symbol">=</a> <a id="12625" class="Symbol">λ{</a><a id="12627" href="../Isomorphism/#12627" class="Bound">x</a> <a id="12629" class="Symbol">→</a>
        <a id="12639" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
          <a id="12655" href="../Isomorphism/#11785" class="Field">from</a> <a id="12660" href="../Isomorphism/#12500" class="Bound">A≲B</a> <a id="12664" class="Symbol">(</a><a id="12665" href="../Isomorphism/#11785" class="Field">from</a> <a id="12670" href="../Isomorphism/#12504" class="Bound">B≲C</a> <a id="12674" class="Symbol">(</a><a id="12675" href="../Isomorphism/#11765" class="Field">to</a> <a id="12678" href="../Isomorphism/#12504" class="Bound">B≲C</a> <a id="12682" class="Symbol">(</a><a id="12683" href="../Isomorphism/#11765" class="Field">to</a> <a id="12686" href="../Isomorphism/#12500" class="Bound">A≲B</a> <a id="12690" href="../Isomorphism/#12627" class="Bound">x</a><a id="12691" class="Symbol">)))</a>
        <a id="12703" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="12706" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="12711" class="Symbol">(</a><a id="12712" href="../Isomorphism/#11785" class="Field">from</a> <a id="12717" href="../Isomorphism/#12500" class="Bound">A≲B</a><a id="12720" class="Symbol">)</a> <a id="12722" class="Symbol">(</a><a id="12723" href="../Isomorphism/#11805" class="Field">from∘to</a> <a id="12731" href="../Isomorphism/#12504" class="Bound">B≲C</a> <a id="12735" class="Symbol">(</a><a id="12736" href="../Isomorphism/#11765" class="Field">to</a> <a id="12739" href="../Isomorphism/#12500" class="Bound">A≲B</a> <a id="12743" href="../Isomorphism/#12627" class="Bound">x</a><a id="12744" class="Symbol">))</a> <a id="12747" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
          <a id="12759" href="../Isomorphism/#11785" class="Field">from</a> <a id="12764" href="../Isomorphism/#12500" class="Bound">A≲B</a> <a id="12768" class="Symbol">(</a><a id="12769" href="../Isomorphism/#11765" class="Field">to</a> <a id="12772" href="../Isomorphism/#12500" class="Bound">A≲B</a> <a id="12776" href="../Isomorphism/#12627" class="Bound">x</a><a id="12777" class="Symbol">)</a>
        <a id="12787" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="12790" href="../Isomorphism/#11805" class="Field">from∘to</a> <a id="12798" href="../Isomorphism/#12500" class="Bound">A≲B</a> <a id="12802" href="../Isomorphism/#12627" class="Bound">x</a> <a id="12804" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
          <a id="12816" href="../Isomorphism/#12627" class="Bound">x</a>
        <a id="12826" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a><a id="12827" class="Symbol">}</a>
     <a id="12834" class="Symbol">}</a>
</pre>
<!--
It is also easy to see that if two types embed in each other, and the
embedding functions correspond, then they are isomorphic.  This is a
weak form of anti-symmetry:
-->
<p>显而易见的是，如果两个类型相互嵌入，且其嵌入函数相互对应，那么它们是同构的。 这个一种反对称性的弱化形式：</p>
<pre class="Agda"><a id="≲-antisym"></a><a id="13077" href="../Isomorphism/#13077" class="Function">≲-antisym</a> <a id="13087" class="Symbol">:</a> <a id="13089" class="Symbol">∀</a> <a id="13091" class="Symbol">{</a><a id="13092" href="../Isomorphism/#13092" class="Bound">A</a> <a id="13094" href="../Isomorphism/#13094" class="Bound">B</a> <a id="13096" class="Symbol">:</a> <a id="13098" class="PrimitiveType">Set</a><a id="13101" class="Symbol">}</a>
  <a id="13105" class="Symbol">→</a> <a id="13107" class="Symbol">(</a><a id="13108" href="../Isomorphism/#13108" class="Bound">A≲B</a> <a id="13112" class="Symbol">:</a> <a id="13114" href="../Isomorphism/#13092" class="Bound">A</a> <a id="13116" href="../Isomorphism/#11725" class="Record Operator">≲</a> <a id="13118" href="../Isomorphism/#13094" class="Bound">B</a><a id="13119" class="Symbol">)</a>
  <a id="13123" class="Symbol">→</a> <a id="13125" class="Symbol">(</a><a id="13126" href="../Isomorphism/#13126" class="Bound">B≲A</a> <a id="13130" class="Symbol">:</a> <a id="13132" href="../Isomorphism/#13094" class="Bound">B</a> <a id="13134" href="../Isomorphism/#11725" class="Record Operator">≲</a> <a id="13136" href="../Isomorphism/#13092" class="Bound">A</a><a id="13137" class="Symbol">)</a>
  <a id="13141" class="Symbol">→</a> <a id="13143" class="Symbol">(</a><a id="13144" href="../Isomorphism/#11765" class="Field">to</a> <a id="13147" href="../Isomorphism/#13108" class="Bound">A≲B</a> <a id="13151" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="13153" href="../Isomorphism/#11785" class="Field">from</a> <a id="13158" href="../Isomorphism/#13126" class="Bound">B≲A</a><a id="13161" class="Symbol">)</a>
  <a id="13165" class="Symbol">→</a> <a id="13167" class="Symbol">(</a><a id="13168" href="../Isomorphism/#11785" class="Field">from</a> <a id="13173" href="../Isomorphism/#13108" class="Bound">A≲B</a> <a id="13177" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="13179" href="../Isomorphism/#11765" class="Field">to</a> <a id="13182" href="../Isomorphism/#13126" class="Bound">B≲A</a><a id="13185" class="Symbol">)</a>
    <a id="13191" class="Comment">-------------------</a>
  <a id="13213" class="Symbol">→</a> <a id="13215" href="../Isomorphism/#13092" class="Bound">A</a> <a id="13217" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="13219" href="../Isomorphism/#13094" class="Bound">B</a>
<a id="13221" href="../Isomorphism/#13077" class="Function">≲-antisym</a> <a id="13231" href="../Isomorphism/#13231" class="Bound">A≲B</a> <a id="13235" href="../Isomorphism/#13235" class="Bound">B≲A</a> <a id="13239" href="../Isomorphism/#13239" class="Bound">to≡from</a> <a id="13247" href="../Isomorphism/#13247" class="Bound">from≡to</a> <a id="13255" class="Symbol">=</a>
  <a id="13259" class="Keyword">record</a>
    <a id="13270" class="Symbol">{</a> <a id="13272" href="../Isomorphism/#5650" class="Field">to</a>      <a id="13280" class="Symbol">=</a> <a id="13282" href="../Isomorphism/#11765" class="Field">to</a> <a id="13285" href="../Isomorphism/#13231" class="Bound">A≲B</a>
    <a id="13293" class="Symbol">;</a> <a id="13295" href="../Isomorphism/#5667" class="Field">from</a>    <a id="13303" class="Symbol">=</a> <a id="13305" href="../Isomorphism/#11785" class="Field">from</a> <a id="13310" href="../Isomorphism/#13231" class="Bound">A≲B</a>
    <a id="13318" class="Symbol">;</a> <a id="13320" href="../Isomorphism/#5684" class="Field">from∘to</a> <a id="13328" class="Symbol">=</a> <a id="13330" href="../Isomorphism/#11805" class="Field">from∘to</a> <a id="13338" href="../Isomorphism/#13231" class="Bound">A≲B</a>
    <a id="13346" class="Symbol">;</a> <a id="13348" href="../Isomorphism/#5726" class="Field">to∘from</a> <a id="13356" class="Symbol">=</a> <a id="13358" class="Symbol">λ{</a><a id="13360" href="../Isomorphism/#13360" class="Bound">y</a> <a id="13362" class="Symbol">→</a>
        <a id="13372" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
          <a id="13388" href="../Isomorphism/#11765" class="Field">to</a> <a id="13391" href="../Isomorphism/#13231" class="Bound">A≲B</a> <a id="13395" class="Symbol">(</a><a id="13396" href="../Isomorphism/#11785" class="Field">from</a> <a id="13401" href="../Isomorphism/#13231" class="Bound">A≲B</a> <a id="13405" href="../Isomorphism/#13360" class="Bound">y</a><a id="13406" class="Symbol">)</a>
        <a id="13416" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="13419" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="13424" class="Symbol">(</a><a id="13425" href="../Isomorphism/#11765" class="Field">to</a> <a id="13428" href="../Isomorphism/#13231" class="Bound">A≲B</a><a id="13431" class="Symbol">)</a> <a id="13433" class="Symbol">(</a><a id="13434" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html#1396" class="Function">cong-app</a> <a id="13443" href="../Isomorphism/#13247" class="Bound">from≡to</a> <a id="13451" href="../Isomorphism/#13360" class="Bound">y</a><a id="13452" class="Symbol">)</a> <a id="13454" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
          <a id="13466" href="../Isomorphism/#11765" class="Field">to</a> <a id="13469" href="../Isomorphism/#13231" class="Bound">A≲B</a> <a id="13473" class="Symbol">(</a><a id="13474" href="../Isomorphism/#11765" class="Field">to</a> <a id="13477" href="../Isomorphism/#13235" class="Bound">B≲A</a> <a id="13481" href="../Isomorphism/#13360" class="Bound">y</a><a id="13482" class="Symbol">)</a>
        <a id="13492" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="13495" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html#1396" class="Function">cong-app</a> <a id="13504" href="../Isomorphism/#13239" class="Bound">to≡from</a> <a id="13512" class="Symbol">(</a><a id="13513" href="../Isomorphism/#11765" class="Field">to</a> <a id="13516" href="../Isomorphism/#13235" class="Bound">B≲A</a> <a id="13520" href="../Isomorphism/#13360" class="Bound">y</a><a id="13521" class="Symbol">)</a> <a id="13523" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
          <a id="13535" href="../Isomorphism/#11785" class="Field">from</a> <a id="13540" href="../Isomorphism/#13235" class="Bound">B≲A</a> <a id="13544" class="Symbol">(</a><a id="13545" href="../Isomorphism/#11765" class="Field">to</a> <a id="13548" href="../Isomorphism/#13235" class="Bound">B≲A</a> <a id="13552" href="../Isomorphism/#13360" class="Bound">y</a><a id="13553" class="Symbol">)</a>
        <a id="13563" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="13566" href="../Isomorphism/#11805" class="Field">from∘to</a> <a id="13574" href="../Isomorphism/#13235" class="Bound">B≲A</a> <a id="13578" href="../Isomorphism/#13360" class="Bound">y</a> <a id="13580" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
          <a id="13592" href="../Isomorphism/#13360" class="Bound">y</a>
        <a id="13602" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a><a id="13603" class="Symbol">}</a>
    <a id="13609" class="Symbol">}</a>
</pre>
<!--
The first three components are copied from the embedding, while the
last combines the left inverse of `B ≲ A` with the equivalences of
the `to` and `from` components from the two embeddings to obtain
the right inverse of the isomorphism.
-->
<p>前三部分可以直接从嵌入中得来，最后一部分我们可以把 <code>B ≲ A</code> 中的左逆和 两个嵌入中的 <code>to</code> 与 <code>from</code> 部分的相等性来获得同构中的右逆。</p>
<!--
## Equational reasoning for embedding
-->
<h2 id="嵌入的相等性论证">嵌入的相等性论证</h2>
<!--
We can also support tabular reasoning for embedding,
analogous to that used for isomorphism:
-->
<p>和同构类似，我们亦支持嵌入的相等性论证：</p>
<pre class="Agda"><a id="14134" class="Keyword">module</a> <a id="≲-Reasoning"></a><a id="14141" href="../Isomorphism/#14141" class="Module">≲-Reasoning</a> <a id="14153" class="Keyword">where</a>

  <a id="14162" class="Keyword">infix</a>  <a id="14169" class="Number">1</a> <a id="14171" href="../Isomorphism/#14217" class="Function Operator">≲-begin_</a>
  <a id="14182" class="Keyword">infixr</a> <a id="14189" class="Number">2</a> <a id="14191" href="../Isomorphism/#14301" class="Function Operator">_≲⟨_⟩_</a>
  <a id="14200" class="Keyword">infix</a>  <a id="14207" class="Number">3</a> <a id="14209" href="../Isomorphism/#14420" class="Function Operator">_≲-∎</a>

  <a id="≲-Reasoning.≲-begin_"></a><a id="14217" href="../Isomorphism/#14217" class="Function Operator">≲-begin_</a> <a id="14226" class="Symbol">:</a> <a id="14228" class="Symbol">∀</a> <a id="14230" class="Symbol">{</a><a id="14231" href="../Isomorphism/#14231" class="Bound">A</a> <a id="14233" href="../Isomorphism/#14233" class="Bound">B</a> <a id="14235" class="Symbol">:</a> <a id="14237" class="PrimitiveType">Set</a><a id="14240" class="Symbol">}</a>
    <a id="14246" class="Symbol">→</a> <a id="14248" href="../Isomorphism/#14231" class="Bound">A</a> <a id="14250" href="../Isomorphism/#11725" class="Record Operator">≲</a> <a id="14252" href="../Isomorphism/#14233" class="Bound">B</a>
      <a id="14260" class="Comment">-----</a>
    <a id="14270" class="Symbol">→</a> <a id="14272" href="../Isomorphism/#14231" class="Bound">A</a> <a id="14274" href="../Isomorphism/#11725" class="Record Operator">≲</a> <a id="14276" href="../Isomorphism/#14233" class="Bound">B</a>
  <a id="14280" href="../Isomorphism/#14217" class="Function Operator">≲-begin</a> <a id="14288" href="../Isomorphism/#14288" class="Bound">A≲B</a> <a id="14292" class="Symbol">=</a> <a id="14294" href="../Isomorphism/#14288" class="Bound">A≲B</a>

  <a id="≲-Reasoning._≲⟨_⟩_"></a><a id="14301" href="../Isomorphism/#14301" class="Function Operator">_≲⟨_⟩_</a> <a id="14308" class="Symbol">:</a> <a id="14310" class="Symbol">∀</a> <a id="14312" class="Symbol">(</a><a id="14313" href="../Isomorphism/#14313" class="Bound">A</a> <a id="14315" class="Symbol">:</a> <a id="14317" class="PrimitiveType">Set</a><a id="14320" class="Symbol">)</a> <a id="14322" class="Symbol">{</a><a id="14323" href="../Isomorphism/#14323" class="Bound">B</a> <a id="14325" href="../Isomorphism/#14325" class="Bound">C</a> <a id="14327" class="Symbol">:</a> <a id="14329" class="PrimitiveType">Set</a><a id="14332" class="Symbol">}</a>
    <a id="14338" class="Symbol">→</a> <a id="14340" href="../Isomorphism/#14313" class="Bound">A</a> <a id="14342" href="../Isomorphism/#11725" class="Record Operator">≲</a> <a id="14344" href="../Isomorphism/#14323" class="Bound">B</a>
    <a id="14350" class="Symbol">→</a> <a id="14352" href="../Isomorphism/#14323" class="Bound">B</a> <a id="14354" href="../Isomorphism/#11725" class="Record Operator">≲</a> <a id="14356" href="../Isomorphism/#14325" class="Bound">C</a>
      <a id="14364" class="Comment">-----</a>
    <a id="14374" class="Symbol">→</a> <a id="14376" href="../Isomorphism/#14313" class="Bound">A</a> <a id="14378" href="../Isomorphism/#11725" class="Record Operator">≲</a> <a id="14380" href="../Isomorphism/#14325" class="Bound">C</a>
  <a id="14384" href="../Isomorphism/#14384" class="Bound">A</a> <a id="14386" href="../Isomorphism/#14301" class="Function Operator">≲⟨</a> <a id="14389" href="../Isomorphism/#14389" class="Bound">A≲B</a> <a id="14393" href="../Isomorphism/#14301" class="Function Operator">⟩</a> <a id="14395" href="../Isomorphism/#14395" class="Bound">B≲C</a> <a id="14399" class="Symbol">=</a> <a id="14401" href="../Isomorphism/#12442" class="Function">≲-trans</a> <a id="14409" href="../Isomorphism/#14389" class="Bound">A≲B</a> <a id="14413" href="../Isomorphism/#14395" class="Bound">B≲C</a>

  <a id="≲-Reasoning._≲-∎"></a><a id="14420" href="../Isomorphism/#14420" class="Function Operator">_≲-∎</a> <a id="14425" class="Symbol">:</a> <a id="14427" class="Symbol">∀</a> <a id="14429" class="Symbol">(</a><a id="14430" href="../Isomorphism/#14430" class="Bound">A</a> <a id="14432" class="Symbol">:</a> <a id="14434" class="PrimitiveType">Set</a><a id="14437" class="Symbol">)</a>
      <a id="14445" class="Comment">-----</a>
    <a id="14455" class="Symbol">→</a> <a id="14457" href="../Isomorphism/#14430" class="Bound">A</a> <a id="14459" href="../Isomorphism/#11725" class="Record Operator">≲</a> <a id="14461" href="../Isomorphism/#14430" class="Bound">A</a>
  <a id="14465" href="../Isomorphism/#14465" class="Bound">A</a> <a id="14467" href="../Isomorphism/#14420" class="Function Operator">≲-∎</a> <a id="14471" class="Symbol">=</a> <a id="14473" href="../Isomorphism/#12310" class="Function">≲-refl</a>

<a id="14481" class="Keyword">open</a> <a id="14486" href="../Isomorphism/#14141" class="Module">≲-Reasoning</a>
</pre>
<!--
#### Exercise `≃-implies-≲` (practice)
-->
<h4 id="练习--implies-实践">练习 <code>≃-implies-≲</code>（实践）</h4>
<!--
Show that every isomorphism implies an embedding.
-->
<p>证明每个同构蕴涵了一个嵌入。</p>
<pre class="Agda"><a id="14659" class="Keyword">postulate</a>
  <a id="≃-implies-≲"></a><a id="14671" href="../Isomorphism/#14671" class="Postulate">≃-implies-≲</a> <a id="14683" class="Symbol">:</a> <a id="14685" class="Symbol">∀</a> <a id="14687" class="Symbol">{</a><a id="14688" href="../Isomorphism/#14688" class="Bound">A</a> <a id="14690" href="../Isomorphism/#14690" class="Bound">B</a> <a id="14692" class="Symbol">:</a> <a id="14694" class="PrimitiveType">Set</a><a id="14697" class="Symbol">}</a>
    <a id="14703" class="Symbol">→</a> <a id="14705" href="../Isomorphism/#14688" class="Bound">A</a> <a id="14707" href="../Isomorphism/#5610" class="Record Operator">≃</a> <a id="14709" href="../Isomorphism/#14690" class="Bound">B</a>
      <a id="14717" class="Comment">-----</a>
    <a id="14727" class="Symbol">→</a> <a id="14729" href="../Isomorphism/#14688" class="Bound">A</a> <a id="14731" href="../Isomorphism/#11725" class="Record Operator">≲</a> <a id="14733" href="../Isomorphism/#14690" class="Bound">B</a>
</pre>
<!--
<pre class="Agda"><a id="14749" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="14785" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
#### Exercise `_⇔_` (practice) {name=iff}
-->
<h4 name="iff" id="练习-__实践">练习 <code>_⇔_</code>（实践）</h4>
<!--
Define equivalence of propositions (also known as "if and only if") as follows:
-->
<p>按下列形式定义命题的等价性（又名「当且仅当」）：</p>
<pre class="Agda"><a id="15005" class="Keyword">record</a> <a id="_⇔_"></a><a id="15012" href="../Isomorphism/#15012" class="Record Operator">_⇔_</a> <a id="15016" class="Symbol">(</a><a id="15017" href="../Isomorphism/#15017" class="Bound">A</a> <a id="15019" href="../Isomorphism/#15019" class="Bound">B</a> <a id="15021" class="Symbol">:</a> <a id="15023" class="PrimitiveType">Set</a><a id="15026" class="Symbol">)</a> <a id="15028" class="Symbol">:</a> <a id="15030" class="PrimitiveType">Set</a> <a id="15034" class="Keyword">where</a>
  <a id="15042" class="Keyword">field</a>
    <a id="_⇔_.to"></a><a id="15052" href="../Isomorphism/#15052" class="Field">to</a>   <a id="15057" class="Symbol">:</a> <a id="15059" href="../Isomorphism/#15017" class="Bound">A</a> <a id="15061" class="Symbol">→</a> <a id="15063" href="../Isomorphism/#15019" class="Bound">B</a>
    <a id="_⇔_.from"></a><a id="15069" href="../Isomorphism/#15069" class="Field">from</a> <a id="15074" class="Symbol">:</a> <a id="15076" href="../Isomorphism/#15019" class="Bound">B</a> <a id="15078" class="Symbol">→</a> <a id="15080" href="../Isomorphism/#15017" class="Bound">A</a>
</pre>
<!--
Show that equivalence is reflexive, symmetric, and transitive.
-->
<p>证明等价性是自反、对称和传递的。</p>
<!--
<pre class="Agda"><a id="15187" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="15223" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
#### Exercise `Bin-embedding` (stretch) {name=Bin-embedding}
-->
<h4 name="Bin-embedding" id="练习-bin-embedding-延伸">练习 <code>Bin-embedding</code> （延伸）</h4>
<!--
Recall that Exercises
[Bin](/Naturals/#Bin) and
[Bin-laws](/Induction/#Bin-laws)
define a datatype `Bin` of bitstrings representing natural numbers,
and asks you to define the following functions and predicates:
-->
<p>回忆练习 <a href="../Naturals/#Bin">Bin</a> 和 <a href="../Induction/#Bin-laws">Bin-laws</a>， 我们定义了比特串数据类型 <code>Bin</code> 来表示自然数，并要求你来定义下列函数：</p>
<pre><code>to : ℕ → Bin
from : Bin → ℕ</code></pre>
<!--
which satisfy the following property:
-->
<p>它们满足如下性质：</p>
<pre><code>from (to n) ≡ n</code></pre>
<!--
Using the above, establish that there is an embedding of `ℕ` into `Bin`.
-->
<p>使用上述条件，证明存在一个从 <code>ℕ</code> 到 <code>Bin</code> 的嵌入。</p>
<!--
<pre class="Agda"><a id="15931" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="15967" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
Why do `to` and `from` not form an isomorphism?
-->
<p>为什么 <code>to</code> 和 <code>from</code> 不能构造一个同构？</p>
<!--
## Standard library
-->
<h2 id="标准库">标准库</h2>
<!--
Definitions similar to those in this chapter can be found in the standard library:
-->
<p>标准库中可以找到与本章节中相似的定义：</p>
<pre class="Agda"><a id="16229" class="Keyword">import</a> <a id="16236" href="https://agda.github.io/agda-stdlib/v1.3/Function.html" class="Module">Function</a> <a id="16245" class="Keyword">using</a> <a id="16251" class="Symbol">(</a><a id="16252" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">_∘_</a><a id="16255" class="Symbol">)</a>
<a id="16257" class="Keyword">import</a> <a id="16264" href="https://agda.github.io/agda-stdlib/v1.3/Function.Inverse.html" class="Module">Function.Inverse</a> <a id="16281" class="Keyword">using</a> <a id="16287" class="Symbol">(</a><a id="16288" href="https://agda.github.io/agda-stdlib/v1.3/Function.Inverse.html#2234" class="Function Operator">_↔_</a><a id="16291" class="Symbol">)</a>
<a id="16293" class="Keyword">import</a> <a id="16300" href="https://agda.github.io/agda-stdlib/v1.3/Function.LeftInverse.html" class="Module">Function.LeftInverse</a> <a id="16321" class="Keyword">using</a> <a id="16327" class="Symbol">(</a><a id="16328" href="https://agda.github.io/agda-stdlib/v1.3/Function.LeftInverse.html#2682" class="Function Operator">_↞_</a><a id="16331" class="Symbol">)</a>
</pre>
<!--
The standard library `_↔_` and `_↞_` correspond to our `_≃_` and
`_≲_`, respectively, but those in the standard library are less
convenient, since they depend on a nested record structure and are
parameterised with regard to an arbitrary notion of equivalence.
-->
<p>标准库中的 <code>_↔︎_</code> 和 <code>_↞_</code> 分别对应了我们定义的 <code>_≃_</code> 和 <code>_≲_</code>， 但是标准库中的定义使用起来不如我们的定义方便，因为标准库中的定义依赖于一个嵌套的记录结构， 并可以由任何相等性的记法来参数化。</p>
<h2 id="unicode">Unicode</h2>
<!--
This chapter uses the following unicode:

    ∘  U+2218  RING OPERATOR (\o, \circ, \comp)
    λ  U+03BB  GREEK SMALL LETTER LAMBDA (\lambda, \Gl)
    ≃  U+2243  ASYMPTOTICALLY EQUAL TO (\~-)
    ≲  U+2272  LESS-THAN OR EQUIVALENT TO (\<~)
    ⇔  U+21D4  LEFT RIGHT DOUBLE ARROW (\<=>)
-->
<p>本章节使用了如下 Unicode：</p>
<pre><code>∘  U+2218  环运算符 (\o, \circ, \comp)
λ  U+03BB  小写希腊字母 LAMBDA (\lambda, \Gl)
≃  U+2243  渐进相等 (\~-)
≲  U+2272  小于或等价于 (\&lt;~)
⇔  U+21D4  左右双箭头 (\&lt;=&gt;)</code></pre>
    </div>
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Equality/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Isomorphism.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Connectives/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

</article>

            </div>
        </main>
        <footer class="site-footer h-card">
    <data class="u-url" href="../"></data>
    <div class="wrapper">
        <h2 class="footer-heading">编程语言基础：Agda 语言描述</h2>
        
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Philip Wadler</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wadler" title="wadler"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wadler</a></li>
    
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Wen Kokke</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wenkokke</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;wenkokke</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Jeremy G. Siek</li>
                    <li>
                        
                        <a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/jsiek" title="jsiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;jsiek</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;jeremysiek</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        
        This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
    </div>
</footer>

    </body>
</html>
