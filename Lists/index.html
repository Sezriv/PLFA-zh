<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../public/css/style.css">
  
  <title>编程语言基础：Agda 语言描述 – Lists</title>
  
  
  
</head>

    <body>
        <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="../">编程语言基础：Agda 语言描述</a>
        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="../">主页</a>
                <a class="page-link" href="../Announcements/">公告</a>
                <a class="page-link" href="../GettingStarted/">使用说明</a>
                <a class="page-link" href="../Citing/">引用</a>
                <a class="page-link" href="https://plfa.github.io/">English</a>
            </div>
        </nav>
    </div>
</header>

        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Decidable/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Lists.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Lambda/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

    <header class="post-header">
        <h1 class="post-title" id="lists">Lists: 列表与高阶函数</h1>
    </header>
    <div class="post-content">
        <pre class="Agda"><a id="170" class="Keyword">module</a> <a id="177" href="../Lists/" class="Module">plfa.part1.Lists</a> <a id="194" class="Keyword">where</a>
</pre>
<!--
This chapter discusses the list data type.  It gives further examples
of many of the techniques we have developed so far, and provides
examples of polymorphic types and higher-order functions.
-->
<p>本章节讨论列表（List）数据类型。我们用列表作为例子，来使用我们之前学习的技巧。同时， 列表也给我们带来多态类型（Polymorphic Types）和高阶函数（Higher-order Functions）的例子。</p>
<!--
## Imports
-->
<h2 id="导入">导入</h2>
<pre class="Agda"><a id="551" class="Keyword">import</a> <a id="558" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="596" class="Symbol">as</a> <a id="599" class="Module">Eq</a>
<a id="602" class="Keyword">open</a> <a id="607" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="610" class="Keyword">using</a> <a id="616" class="Symbol">(</a><a id="617" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="620" class="Symbol">;</a> <a id="622" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="626" class="Symbol">;</a> <a id="628" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a><a id="631" class="Symbol">;</a> <a id="633" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1025" class="Function">trans</a><a id="638" class="Symbol">;</a> <a id="640" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a><a id="644" class="Symbol">)</a>
<a id="646" class="Keyword">open</a> <a id="651" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2419" class="Module">Eq.≡-Reasoning</a>
<a id="666" class="Keyword">open</a> <a id="671" class="Keyword">import</a> <a id="678" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.html" class="Module">Data.Bool</a> <a id="688" class="Keyword">using</a> <a id="694" class="Symbol">(</a><a id="695" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="699" class="Symbol">;</a> <a id="701" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="705" class="Symbol">;</a> <a id="707" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="712" class="Symbol">;</a> <a id="714" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html#1451" class="Function">T</a><a id="715" class="Symbol">;</a> <a id="717" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html#986" class="Function Operator">_∧_</a><a id="720" class="Symbol">;</a> <a id="722" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html#1044" class="Function Operator">_∨_</a><a id="725" class="Symbol">;</a> <a id="727" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html#932" class="Function">not</a><a id="730" class="Symbol">)</a>
<a id="732" class="Keyword">open</a> <a id="737" class="Keyword">import</a> <a id="744" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.html" class="Module">Data.Nat</a> <a id="753" class="Keyword">using</a> <a id="759" class="Symbol">(</a><a id="760" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="761" class="Symbol">;</a> <a id="763" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="767" class="Symbol">;</a> <a id="769" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="772" class="Symbol">;</a> <a id="774" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a><a id="777" class="Symbol">;</a> <a id="779" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a><a id="782" class="Symbol">;</a> <a id="784" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#1429" class="Primitive Operator">_∸_</a><a id="787" class="Symbol">;</a> <a id="789" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#937" class="Datatype Operator">_≤_</a><a id="792" class="Symbol">;</a> <a id="794" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a><a id="797" class="Symbol">;</a> <a id="799" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a><a id="802" class="Symbol">)</a>
<a id="804" class="Keyword">open</a> <a id="809" class="Keyword">import</a> <a id="816" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="836" class="Keyword">using</a>
  <a id="844" class="Symbol">(</a><a id="845" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#12490" class="Function">+-assoc</a><a id="852" class="Symbol">;</a> <a id="854" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#12591" class="Function">+-identityˡ</a><a id="865" class="Symbol">;</a> <a id="867" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#12646" class="Function">+-identityʳ</a><a id="878" class="Symbol">;</a> <a id="880" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#20430" class="Function">*-assoc</a><a id="887" class="Symbol">;</a> <a id="889" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#19330" class="Function">*-identityˡ</a><a id="900" class="Symbol">;</a> <a id="902" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#19394" class="Function">*-identityʳ</a><a id="913" class="Symbol">)</a>
<a id="915" class="Keyword">open</a> <a id="920" class="Keyword">import</a> <a id="927" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="944" class="Keyword">using</a> <a id="950" class="Symbol">(</a><a id="951" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬_</a><a id="953" class="Symbol">;</a> <a id="955" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1508" class="Record">Dec</a><a id="958" class="Symbol">;</a> <a id="960" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a><a id="963" class="Symbol">;</a> <a id="965" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a><a id="967" class="Symbol">)</a>
<a id="969" class="Keyword">open</a> <a id="974" class="Keyword">import</a> <a id="981" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html" class="Module">Data.Product</a> <a id="994" class="Keyword">using</a> <a id="1000" class="Symbol">(</a><a id="1001" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">_×_</a><a id="1004" class="Symbol">;</a> <a id="1006" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1369" class="Function">∃</a><a id="1007" class="Symbol">;</a> <a id="1009" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1788" class="Function">∃-syntax</a><a id="1017" class="Symbol">)</a> <a id="1019" class="Keyword">renaming</a> <a id="1028" class="Symbol">(</a><a id="1029" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="1033" class="Symbol">to</a> <a id="_,_"></a><a id="1036" href="../Lists/#1036" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="1041" class="Symbol">)</a>
<a id="1043" class="Keyword">open</a> <a id="1048" class="Keyword">import</a> <a id="1055" href="https://agda.github.io/agda-stdlib/v1.3/Function.html" class="Module">Function</a> <a id="1064" class="Keyword">using</a> <a id="1070" class="Symbol">(</a><a id="1071" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">_∘_</a><a id="1074" class="Symbol">)</a>
<a id="1076" class="Keyword">open</a> <a id="1081" class="Keyword">import</a> <a id="1088" href="https://agda.github.io/agda-stdlib/v1.3/Level.html" class="Module">Level</a> <a id="1094" class="Keyword">using</a> <a id="1100" class="Symbol">(</a><a id="1101" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Primitive.html#423" class="Postulate">Level</a><a id="1106" class="Symbol">)</a>
<a id="1108" class="Keyword">open</a> <a id="1113" class="Keyword">import</a> <a id="1120" href="../Isomorphism/" class="Module">plfa.part1.Isomorphism</a> <a id="1143" class="Keyword">using</a> <a id="1149" class="Symbol">(</a><a id="1150" href="../Isomorphism/#5610" class="Record Operator">_≃_</a><a id="1153" class="Symbol">;</a> <a id="1155" href="../Isomorphism/#14988" class="Record Operator">_⇔_</a><a id="1158" class="Symbol">)</a>
</pre>
<!--
## Lists
-->
<h2 id="列表">列表</h2>
<!--
Lists are defined in Agda as follows:
-->
Agda 中的列表如下定义：
<pre class="Agda"><a id="1259" class="Keyword">data</a> <a id="List"></a><a id="1264" href="../Lists/#1264" class="Datatype">List</a> <a id="1269" class="Symbol">(</a><a id="1270" href="../Lists/#1270" class="Bound">A</a> <a id="1272" class="Symbol">:</a> <a id="1274" class="PrimitiveType">Set</a><a id="1277" class="Symbol">)</a> <a id="1279" class="Symbol">:</a> <a id="1281" class="PrimitiveType">Set</a> <a id="1285" class="Keyword">where</a>
  <a id="List.[]"></a><a id="1293" href="../Lists/#1293" class="InductiveConstructor">[]</a>  <a id="1297" class="Symbol">:</a> <a id="1299" href="../Lists/#1264" class="Datatype">List</a> <a id="1304" href="../Lists/#1270" class="Bound">A</a>
  <a id="List._∷_"></a><a id="1308" href="../Lists/#1308" class="InductiveConstructor Operator">_∷_</a> <a id="1312" class="Symbol">:</a> <a id="1314" href="../Lists/#1270" class="Bound">A</a> <a id="1316" class="Symbol">→</a> <a id="1318" href="../Lists/#1264" class="Datatype">List</a> <a id="1323" href="../Lists/#1270" class="Bound">A</a> <a id="1325" class="Symbol">→</a> <a id="1327" href="../Lists/#1264" class="Datatype">List</a> <a id="1332" href="../Lists/#1270" class="Bound">A</a>

<a id="1335" class="Keyword">infixr</a> <a id="1342" class="Number">5</a> <a id="1344" href="../Lists/#1308" class="InductiveConstructor Operator">_∷_</a>
</pre>
<!--
Let's unpack this definition. If `A` is a set, then `List A` is a set.
The next two lines tell us that `[]` (pronounced _nil_) is a list of
type `A` (often called the _empty_ list), and that `_∷_` (pronounced
_cons_, short for _constructor_) takes a value of type `A` and a value
of type `List A` and returns a value of type `List A`.  Operator `_∷_`
has precedence level 5 and associates to the right.
-->
<p>我们来仔细研究这个定义。如果 <code>A</code> 是个集合，那么 <code>List A</code> 也是一个集合。接下来的两行告诉我们 <code>[]</code> （读作 <em>nil</em>）是一个类型为 <code>A</code> 的列表（通常被叫做<strong>空</strong>列表），<code>_∷_</code>（读作 <em>cons</em>，是 <em>constructor</em> 的简写）取一个类型为 <code>A</code> 的值，和一个类型为 <code>List A</code> 的值，返回一个类型为 <code>List A</code> 的值。<code>_∷_</code> 运算符的优先级是 5，向右结合。</p>
<!--
For example,
-->
<p>例如：</p>
<pre class="Agda"><a id="2009" href="../Lists/#2009" class="Function">_</a> <a id="2011" class="Symbol">:</a> <a id="2013" href="../Lists/#1264" class="Datatype">List</a> <a id="2018" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="2020" class="Symbol">_</a> <a id="2022" class="Symbol">=</a> <a id="2024" class="Number">0</a> <a id="2026" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="2028" class="Number">1</a> <a id="2030" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="2032" class="Number">2</a> <a id="2034" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="2036" href="../Lists/#1293" class="InductiveConstructor">[]</a>
</pre>
<!--
denotes the list of the first three natural numbers.  Since `_∷_`
associates to the right, the term parses as `0 ∷ (1 ∷ (2 ∷ []))`.
Here `0` is the first element of the list, called the _head_,
and `1 ∷ (2 ∷ [])` is a list of the remaining elements, called the
_tail_. A list is a strange beast: it has a head and a tail,
nothing in between, and the tail is itself another list!
-->
<p>表示了一个三个自然数的列表。因为 <code>_∷_</code> 向右结合，这一项被解析成 <code>0 ∷ (1 ∷ (2 ∷ []))</code>。 在这里，<code>0</code> 是列表的第一个元素，称之为<strong>头（Head）</strong>，<code>1 ∷ (2 ∷ [])</code> 是剩下元素的列表， 称之为<strong>尾（Tail）</strong>。列表是一个奇怪的怪兽：它有一头一尾，中间没有东西，然而它的尾巴又是一个列表！</p>
<!--
As we've seen, parameterised types can be translated to
indexed types. The definition above is equivalent to the following:
-->
<p>正如我们所见，参数化的类型可以被转换成索引类型。上面的定义与下列等价：</p>
<pre class="Agda"><a id="2779" class="Keyword">data</a> <a id="List′"></a><a id="2784" href="../Lists/#2784" class="Datatype">List′</a> <a id="2790" class="Symbol">:</a> <a id="2792" class="PrimitiveType">Set</a> <a id="2796" class="Symbol">→</a> <a id="2798" class="PrimitiveType">Set</a> <a id="2802" class="Keyword">where</a>
  <a id="List′.[]′"></a><a id="2810" href="../Lists/#2810" class="InductiveConstructor">[]′</a>  <a id="2815" class="Symbol">:</a> <a id="2817" class="Symbol">∀</a> <a id="2819" class="Symbol">{</a><a id="2820" href="../Lists/#2820" class="Bound">A</a> <a id="2822" class="Symbol">:</a> <a id="2824" class="PrimitiveType">Set</a><a id="2827" class="Symbol">}</a> <a id="2829" class="Symbol">→</a> <a id="2831" href="../Lists/#2784" class="Datatype">List′</a> <a id="2837" href="../Lists/#2820" class="Bound">A</a>
  <a id="List′._∷′_"></a><a id="2841" href="../Lists/#2841" class="InductiveConstructor Operator">_∷′_</a> <a id="2846" class="Symbol">:</a> <a id="2848" class="Symbol">∀</a> <a id="2850" class="Symbol">{</a><a id="2851" href="../Lists/#2851" class="Bound">A</a> <a id="2853" class="Symbol">:</a> <a id="2855" class="PrimitiveType">Set</a><a id="2858" class="Symbol">}</a> <a id="2860" class="Symbol">→</a> <a id="2862" href="../Lists/#2851" class="Bound">A</a> <a id="2864" class="Symbol">→</a> <a id="2866" href="../Lists/#2784" class="Datatype">List′</a> <a id="2872" href="../Lists/#2851" class="Bound">A</a> <a id="2874" class="Symbol">→</a> <a id="2876" href="../Lists/#2784" class="Datatype">List′</a> <a id="2882" href="../Lists/#2851" class="Bound">A</a>
</pre>
<!--
Each constructor takes the parameter as an implicit argument.
Thus, our example list could also be written:
-->
<p>每个构造子将参数作为隐式参数。因此我们列表的例子也可以写作：</p>
<pre class="Agda"><a id="3043" href="../Lists/#3043" class="Function">_</a> <a id="3045" class="Symbol">:</a> <a id="3047" href="../Lists/#1264" class="Datatype">List</a> <a id="3052" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="3054" class="Symbol">_</a> <a id="3056" class="Symbol">=</a> <a id="3058" href="../Lists/#1308" class="InductiveConstructor Operator">_∷_</a> <a id="3062" class="Symbol">{</a><a id="3063" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="3064" class="Symbol">}</a> <a id="3066" class="Number">0</a> <a id="3068" class="Symbol">(</a><a id="3069" href="../Lists/#1308" class="InductiveConstructor Operator">_∷_</a> <a id="3073" class="Symbol">{</a><a id="3074" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="3075" class="Symbol">}</a> <a id="3077" class="Number">1</a> <a id="3079" class="Symbol">(</a><a id="3080" href="../Lists/#1308" class="InductiveConstructor Operator">_∷_</a> <a id="3084" class="Symbol">{</a><a id="3085" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="3086" class="Symbol">}</a> <a id="3088" class="Number">2</a> <a id="3090" class="Symbol">(</a><a id="3091" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="3094" class="Symbol">{</a><a id="3095" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="3096" class="Symbol">})))</a>
</pre>
<!--
where here we have provided the implicit parameters explicitly.
-->
<p>此处我们将隐式参数显式地声明。</p>
<!--
Including the pragma:
-->
<p>包含下面的编译器指令</p>
<pre><code>{-# BUILTIN LIST List #-}</code></pre>
<!--
tells Agda that the type `List` corresponds to the Haskell type
list, and the constructors `[]` and `_∷_` correspond to nil and
cons respectively, allowing a more efficient representation of lists.
-->
<p>告诉 Agda，<code>List</code> 类型对应了 Haskell 的列表类型，构造子 <code>[]</code> 和 <code>_∷_</code> 分别代表了 nil 和 cons，这可以让列表的表示更加的有效率。</p>
<!--
## List syntax
-->
<h2 id="列表语法">列表语法</h2>
<!--
We can write lists more conveniently by introducing the following definitions:
-->
<p>我们可以用下面的定义，更简便地表示列表：</p>
<pre class="Agda"><a id="3716" class="Keyword">pattern</a> <a id="[_]"></a><a id="3724" href="../Lists/#3724" class="InductiveConstructor Operator">[_]</a> <a id="3728" href="../Lists/#3732" class="Bound">z</a> <a id="3730" class="Symbol">=</a> <a id="3732" href="../Lists/#3732" class="Bound">z</a> <a id="3734" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3736" href="../Lists/#1293" class="InductiveConstructor">[]</a>
<a id="3739" class="Keyword">pattern</a> <a id="[_,_]"></a><a id="3747" href="../Lists/#3747" class="InductiveConstructor Operator">[_,_]</a> <a id="3753" href="../Lists/#3759" class="Bound">y</a> <a id="3755" href="../Lists/#3763" class="Bound">z</a> <a id="3757" class="Symbol">=</a> <a id="3759" href="../Lists/#3759" class="Bound">y</a> <a id="3761" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3763" href="../Lists/#3763" class="Bound">z</a> <a id="3765" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3767" href="../Lists/#1293" class="InductiveConstructor">[]</a>
<a id="3770" class="Keyword">pattern</a> <a id="[_,_,_]"></a><a id="3778" href="../Lists/#3778" class="InductiveConstructor Operator">[_,_,_]</a> <a id="3786" href="../Lists/#3794" class="Bound">x</a> <a id="3788" href="../Lists/#3798" class="Bound">y</a> <a id="3790" href="../Lists/#3802" class="Bound">z</a> <a id="3792" class="Symbol">=</a> <a id="3794" href="../Lists/#3794" class="Bound">x</a> <a id="3796" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3798" href="../Lists/#3798" class="Bound">y</a> <a id="3800" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3802" href="../Lists/#3802" class="Bound">z</a> <a id="3804" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3806" href="../Lists/#1293" class="InductiveConstructor">[]</a>
<a id="3809" class="Keyword">pattern</a> <a id="[_,_,_,_]"></a><a id="3817" href="../Lists/#3817" class="InductiveConstructor Operator">[_,_,_,_]</a> <a id="3827" href="../Lists/#3837" class="Bound">w</a> <a id="3829" href="../Lists/#3841" class="Bound">x</a> <a id="3831" href="../Lists/#3845" class="Bound">y</a> <a id="3833" href="../Lists/#3849" class="Bound">z</a> <a id="3835" class="Symbol">=</a> <a id="3837" href="../Lists/#3837" class="Bound">w</a> <a id="3839" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3841" href="../Lists/#3841" class="Bound">x</a> <a id="3843" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3845" href="../Lists/#3845" class="Bound">y</a> <a id="3847" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3849" href="../Lists/#3849" class="Bound">z</a> <a id="3851" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3853" href="../Lists/#1293" class="InductiveConstructor">[]</a>
<a id="3856" class="Keyword">pattern</a> <a id="[_,_,_,_,_]"></a><a id="3864" href="../Lists/#3864" class="InductiveConstructor Operator">[_,_,_,_,_]</a> <a id="3876" href="../Lists/#3888" class="Bound">v</a> <a id="3878" href="../Lists/#3892" class="Bound">w</a> <a id="3880" href="../Lists/#3896" class="Bound">x</a> <a id="3882" href="../Lists/#3900" class="Bound">y</a> <a id="3884" href="../Lists/#3904" class="Bound">z</a> <a id="3886" class="Symbol">=</a> <a id="3888" href="../Lists/#3888" class="Bound">v</a> <a id="3890" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3892" href="../Lists/#3892" class="Bound">w</a> <a id="3894" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3896" href="../Lists/#3896" class="Bound">x</a> <a id="3898" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3900" href="../Lists/#3900" class="Bound">y</a> <a id="3902" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3904" href="../Lists/#3904" class="Bound">z</a> <a id="3906" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3908" href="../Lists/#1293" class="InductiveConstructor">[]</a>
<a id="3911" class="Keyword">pattern</a> <a id="[_,_,_,_,_,_]"></a><a id="3919" href="../Lists/#3919" class="InductiveConstructor Operator">[_,_,_,_,_,_]</a> <a id="3933" href="../Lists/#3947" class="Bound">u</a> <a id="3935" href="../Lists/#3951" class="Bound">v</a> <a id="3937" href="../Lists/#3955" class="Bound">w</a> <a id="3939" href="../Lists/#3959" class="Bound">x</a> <a id="3941" href="../Lists/#3963" class="Bound">y</a> <a id="3943" href="../Lists/#3967" class="Bound">z</a> <a id="3945" class="Symbol">=</a> <a id="3947" href="../Lists/#3947" class="Bound">u</a> <a id="3949" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3951" href="../Lists/#3951" class="Bound">v</a> <a id="3953" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3955" href="../Lists/#3955" class="Bound">w</a> <a id="3957" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3959" href="../Lists/#3959" class="Bound">x</a> <a id="3961" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3963" href="../Lists/#3963" class="Bound">y</a> <a id="3965" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3967" href="../Lists/#3967" class="Bound">z</a> <a id="3969" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="3971" href="../Lists/#1293" class="InductiveConstructor">[]</a>
</pre>
<!--
This is our first use of pattern declarations.  For instance,
the third line tells us that `[ x , y , z ]` is equivalent to
`x ∷ y ∷ z ∷ []`, and permits the former to appear either in
a pattern on the left-hand side of an equation, or a term
on the right-hand side of an equation.
-->
<p>这是我们第一次使用模式声明。举例来说，第三行告诉我们 <code>[ x , y , z ]</code> 等价于 <code>x ∷ y ∷ z ∷ []</code>。前者可以在模式或者等式的左手边，或者是等式右手边的项中出现。</p>
<!--
## Append
-->
<h2 id="附加">附加</h2>
<!--
Our first function on lists is written `_++_` and pronounced
_append_:
-->
<p>我们对于列表的第一个函数写作 <code>_++_</code>，读作<strong>附加（Append）</strong>：</p>
<pre class="Agda"><a id="4520" class="Keyword">infixr</a> <a id="4527" class="Number">5</a> <a id="4529" href="../Lists/#4535" class="Function Operator">_++_</a>

<a id="_++_"></a><a id="4535" href="../Lists/#4535" class="Function Operator">_++_</a> <a id="4540" class="Symbol">:</a> <a id="4542" class="Symbol">∀</a> <a id="4544" class="Symbol">{</a><a id="4545" href="../Lists/#4545" class="Bound">A</a> <a id="4547" class="Symbol">:</a> <a id="4549" class="PrimitiveType">Set</a><a id="4552" class="Symbol">}</a> <a id="4554" class="Symbol">→</a> <a id="4556" href="../Lists/#1264" class="Datatype">List</a> <a id="4561" href="../Lists/#4545" class="Bound">A</a> <a id="4563" class="Symbol">→</a> <a id="4565" href="../Lists/#1264" class="Datatype">List</a> <a id="4570" href="../Lists/#4545" class="Bound">A</a> <a id="4572" class="Symbol">→</a> <a id="4574" href="../Lists/#1264" class="Datatype">List</a> <a id="4579" href="../Lists/#4545" class="Bound">A</a>
<a id="4581" href="../Lists/#1293" class="InductiveConstructor">[]</a>       <a id="4590" href="../Lists/#4535" class="Function Operator">++</a> <a id="4593" href="../Lists/#4593" class="Bound">ys</a>  <a id="4597" class="Symbol">=</a>  <a id="4600" href="../Lists/#4593" class="Bound">ys</a>
<a id="4603" class="Symbol">(</a><a id="4604" href="../Lists/#4604" class="Bound">x</a> <a id="4606" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="4608" href="../Lists/#4608" class="Bound">xs</a><a id="4610" class="Symbol">)</a> <a id="4612" href="../Lists/#4535" class="Function Operator">++</a> <a id="4615" href="../Lists/#4615" class="Bound">ys</a>  <a id="4619" class="Symbol">=</a>  <a id="4622" href="../Lists/#4604" class="Bound">x</a> <a id="4624" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="4626" class="Symbol">(</a><a id="4627" href="../Lists/#4608" class="Bound">xs</a> <a id="4630" href="../Lists/#4535" class="Function Operator">++</a> <a id="4633" href="../Lists/#4615" class="Bound">ys</a><a id="4635" class="Symbol">)</a>
</pre>
<!--
The type `A` is an implicit argument to append, making it a _polymorphic_
function (one that can be used at many types). A list appended to the empty list
yields the list itself. A list appended to a non-empty list yields a list with
the head the same as the head of the non-empty list, and a tail the same as the
other list appended to tail of the non-empty list.
-->
<p><code>A</code> 类型是附加的隐式参数，这让这个函数变为一个<strong>多态（Polymorphic）</strong>函数 （即可以用作多种类型）。一个列表附加到空列表会得到该列表本身； 一个列表附加到非空列表所得到的列表，其头与附加到的非空列表相同，尾与所附加的列表相同。</p>
<!--
Here is an example, showing how to compute the result
of appending two lists:
-->
<p>我们举个例子，来展示将两个列表附加的计算过程：</p>
<pre class="Agda"><a id="5258" href="../Lists/#5258" class="Function">_</a> <a id="5260" class="Symbol">:</a> <a id="5262" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="5264" class="Number">0</a> <a id="5266" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="5268" class="Number">1</a> <a id="5270" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="5272" class="Number">2</a> <a id="5274" href="../Lists/#3778" class="InductiveConstructor Operator">]</a> <a id="5276" href="../Lists/#4535" class="Function Operator">++</a> <a id="5279" href="../Lists/#3747" class="InductiveConstructor Operator">[</a> <a id="5281" class="Number">3</a> <a id="5283" href="../Lists/#3747" class="InductiveConstructor Operator">,</a> <a id="5285" class="Number">4</a> <a id="5287" href="../Lists/#3747" class="InductiveConstructor Operator">]</a> <a id="5289" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="5291" href="../Lists/#3864" class="InductiveConstructor Operator">[</a> <a id="5293" class="Number">0</a> <a id="5295" href="../Lists/#3864" class="InductiveConstructor Operator">,</a> <a id="5297" class="Number">1</a> <a id="5299" href="../Lists/#3864" class="InductiveConstructor Operator">,</a> <a id="5301" class="Number">2</a> <a id="5303" href="../Lists/#3864" class="InductiveConstructor Operator">,</a> <a id="5305" class="Number">3</a> <a id="5307" href="../Lists/#3864" class="InductiveConstructor Operator">,</a> <a id="5309" class="Number">4</a> <a id="5311" href="../Lists/#3864" class="InductiveConstructor Operator">]</a>
<a id="5313" class="Symbol">_</a> <a id="5315" class="Symbol">=</a>
  <a id="5319" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="5329" class="Number">0</a> <a id="5331" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5333" class="Number">1</a> <a id="5335" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5337" class="Number">2</a> <a id="5339" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5341" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="5344" href="../Lists/#4535" class="Function Operator">++</a> <a id="5347" class="Number">3</a> <a id="5349" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5351" class="Number">4</a> <a id="5353" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5355" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="5360" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="5368" class="Number">0</a> <a id="5370" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5372" class="Symbol">(</a><a id="5373" class="Number">1</a> <a id="5375" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5377" class="Number">2</a> <a id="5379" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5381" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="5384" href="../Lists/#4535" class="Function Operator">++</a> <a id="5387" class="Number">3</a> <a id="5389" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5391" class="Number">4</a> <a id="5393" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5395" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="5397" class="Symbol">)</a>
  <a id="5401" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="5409" class="Number">0</a> <a id="5411" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5413" class="Number">1</a> <a id="5415" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5417" class="Symbol">(</a><a id="5418" class="Number">2</a> <a id="5420" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5422" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="5425" href="../Lists/#4535" class="Function Operator">++</a> <a id="5428" class="Number">3</a> <a id="5430" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5432" class="Number">4</a> <a id="5434" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5436" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="5438" class="Symbol">)</a>
  <a id="5442" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="5450" class="Number">0</a> <a id="5452" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5454" class="Number">1</a> <a id="5456" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5458" class="Number">2</a> <a id="5460" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5462" class="Symbol">(</a><a id="5463" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="5466" href="../Lists/#4535" class="Function Operator">++</a> <a id="5469" class="Number">3</a> <a id="5471" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5473" class="Number">4</a> <a id="5475" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5477" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="5479" class="Symbol">)</a>
  <a id="5483" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="5491" class="Number">0</a> <a id="5493" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5495" class="Number">1</a> <a id="5497" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5499" class="Number">2</a> <a id="5501" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5503" class="Number">3</a> <a id="5505" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5507" class="Number">4</a> <a id="5509" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="5511" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="5516" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
Appending two lists requires time linear in the
number of elements in the first list.
-->
<p>附加两个列表需要对于第一个列表元素个数线性的时间。</p>
<!--
## Reasoning about append
-->
<h2 id="论证附加">论证附加</h2>
<!--
We can reason about lists in much the same way that we reason
about numbers.  Here is the proof that append is associative:
-->
我们可以与用论证数几乎相同的方法来论证列表。下面是附加满足结合律的证明：
<pre class="Agda"><a id="++-assoc"></a><a id="5867" href="../Lists/#5867" class="Function">++-assoc</a> <a id="5876" class="Symbol">:</a> <a id="5878" class="Symbol">∀</a> <a id="5880" class="Symbol">{</a><a id="5881" href="../Lists/#5881" class="Bound">A</a> <a id="5883" class="Symbol">:</a> <a id="5885" class="PrimitiveType">Set</a><a id="5888" class="Symbol">}</a> <a id="5890" class="Symbol">(</a><a id="5891" href="../Lists/#5891" class="Bound">xs</a> <a id="5894" href="../Lists/#5894" class="Bound">ys</a> <a id="5897" href="../Lists/#5897" class="Bound">zs</a> <a id="5900" class="Symbol">:</a> <a id="5902" href="../Lists/#1264" class="Datatype">List</a> <a id="5907" href="../Lists/#5881" class="Bound">A</a><a id="5908" class="Symbol">)</a>
  <a id="5912" class="Symbol">→</a> <a id="5914" class="Symbol">(</a><a id="5915" href="../Lists/#5891" class="Bound">xs</a> <a id="5918" href="../Lists/#4535" class="Function Operator">++</a> <a id="5921" href="../Lists/#5894" class="Bound">ys</a><a id="5923" class="Symbol">)</a> <a id="5925" href="../Lists/#4535" class="Function Operator">++</a> <a id="5928" href="../Lists/#5897" class="Bound">zs</a> <a id="5931" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="5933" href="../Lists/#5891" class="Bound">xs</a> <a id="5936" href="../Lists/#4535" class="Function Operator">++</a> <a id="5939" class="Symbol">(</a><a id="5940" href="../Lists/#5894" class="Bound">ys</a> <a id="5943" href="../Lists/#4535" class="Function Operator">++</a> <a id="5946" href="../Lists/#5897" class="Bound">zs</a><a id="5948" class="Symbol">)</a>
<a id="5950" href="../Lists/#5867" class="Function">++-assoc</a> <a id="5959" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="5962" href="../Lists/#5962" class="Bound">ys</a> <a id="5965" href="../Lists/#5965" class="Bound">zs</a> <a id="5968" class="Symbol">=</a>
  <a id="5972" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="5982" class="Symbol">(</a><a id="5983" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="5986" href="../Lists/#4535" class="Function Operator">++</a> <a id="5989" href="../Lists/#5962" class="Bound">ys</a><a id="5991" class="Symbol">)</a> <a id="5993" href="../Lists/#4535" class="Function Operator">++</a> <a id="5996" href="../Lists/#5965" class="Bound">zs</a>
  <a id="6001" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="6009" href="../Lists/#5962" class="Bound">ys</a> <a id="6012" href="../Lists/#4535" class="Function Operator">++</a> <a id="6015" href="../Lists/#5965" class="Bound">zs</a>
  <a id="6020" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="6028" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="6031" href="../Lists/#4535" class="Function Operator">++</a> <a id="6034" class="Symbol">(</a><a id="6035" href="../Lists/#5962" class="Bound">ys</a> <a id="6038" href="../Lists/#4535" class="Function Operator">++</a> <a id="6041" href="../Lists/#5965" class="Bound">zs</a><a id="6043" class="Symbol">)</a>
  <a id="6047" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
<a id="6049" href="../Lists/#5867" class="Function">++-assoc</a> <a id="6058" class="Symbol">(</a><a id="6059" href="../Lists/#6059" class="Bound">x</a> <a id="6061" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="6063" href="../Lists/#6063" class="Bound">xs</a><a id="6065" class="Symbol">)</a> <a id="6067" href="../Lists/#6067" class="Bound">ys</a> <a id="6070" href="../Lists/#6070" class="Bound">zs</a> <a id="6073" class="Symbol">=</a>
  <a id="6077" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="6087" class="Symbol">(</a><a id="6088" href="../Lists/#6059" class="Bound">x</a> <a id="6090" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="6092" href="../Lists/#6063" class="Bound">xs</a> <a id="6095" href="../Lists/#4535" class="Function Operator">++</a> <a id="6098" href="../Lists/#6067" class="Bound">ys</a><a id="6100" class="Symbol">)</a> <a id="6102" href="../Lists/#4535" class="Function Operator">++</a> <a id="6105" href="../Lists/#6070" class="Bound">zs</a>
  <a id="6110" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="6118" href="../Lists/#6059" class="Bound">x</a> <a id="6120" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="6122" class="Symbol">(</a><a id="6123" href="../Lists/#6063" class="Bound">xs</a> <a id="6126" href="../Lists/#4535" class="Function Operator">++</a> <a id="6129" href="../Lists/#6067" class="Bound">ys</a><a id="6131" class="Symbol">)</a> <a id="6133" href="../Lists/#4535" class="Function Operator">++</a> <a id="6136" href="../Lists/#6070" class="Bound">zs</a>
  <a id="6141" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="6149" href="../Lists/#6059" class="Bound">x</a> <a id="6151" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="6153" class="Symbol">((</a><a id="6155" href="../Lists/#6063" class="Bound">xs</a> <a id="6158" href="../Lists/#4535" class="Function Operator">++</a> <a id="6161" href="../Lists/#6067" class="Bound">ys</a><a id="6163" class="Symbol">)</a> <a id="6165" href="../Lists/#4535" class="Function Operator">++</a> <a id="6168" href="../Lists/#6070" class="Bound">zs</a><a id="6170" class="Symbol">)</a>
  <a id="6174" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="6177" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="6182" class="Symbol">(</a><a id="6183" href="../Lists/#6059" class="Bound">x</a> <a id="6185" href="../Lists/#1308" class="InductiveConstructor Operator">∷_</a><a id="6187" class="Symbol">)</a> <a id="6189" class="Symbol">(</a><a id="6190" href="../Lists/#5867" class="Function">++-assoc</a> <a id="6199" href="../Lists/#6063" class="Bound">xs</a> <a id="6202" href="../Lists/#6067" class="Bound">ys</a> <a id="6205" href="../Lists/#6070" class="Bound">zs</a><a id="6207" class="Symbol">)</a> <a id="6209" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="6215" href="../Lists/#6059" class="Bound">x</a> <a id="6217" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="6219" class="Symbol">(</a><a id="6220" href="../Lists/#6063" class="Bound">xs</a> <a id="6223" href="../Lists/#4535" class="Function Operator">++</a> <a id="6226" class="Symbol">(</a><a id="6227" href="../Lists/#6067" class="Bound">ys</a> <a id="6230" href="../Lists/#4535" class="Function Operator">++</a> <a id="6233" href="../Lists/#6070" class="Bound">zs</a><a id="6235" class="Symbol">))</a>
  <a id="6240" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="6248" href="../Lists/#6059" class="Bound">x</a> <a id="6250" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="6252" href="../Lists/#6063" class="Bound">xs</a> <a id="6255" href="../Lists/#4535" class="Function Operator">++</a> <a id="6258" class="Symbol">(</a><a id="6259" href="../Lists/#6067" class="Bound">ys</a> <a id="6262" href="../Lists/#4535" class="Function Operator">++</a> <a id="6265" href="../Lists/#6070" class="Bound">zs</a><a id="6267" class="Symbol">)</a>
  <a id="6271" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
The proof is by induction on the first argument. The base case instantiates
to `[]`, and follows by straightforward computation.
The inductive case instantiates to `x ∷ xs`,
and follows by straightforward computation combined with the
inductive hypothesis.  As usual, the inductive hypothesis is indicated by a recursive
invocation of the proof, in this case `++-assoc xs ys zs`.
-->
<p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由直接的运算配合归纳假设可证。 与往常一样，归纳假设由递归使用证明函数来表明，此处为 <code>++-assoc xs ys zs</code>。</p>
<!--
Recall that Agda supports [sections](/Induction/#sections).
Applying `cong (x ∷_)` promotes the inductive hypothesis:
-->
<p>回忆到 Agda 支持<a href="../Induction/#sections">片段</a>。使用 <code>cong (x ∷_)</code> 可以将归纳假设：</p>
<pre><code>(xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)</code></pre>
<!--
to the equality:
-->
<p>提升至等式：</p>
<pre><code>x ∷ ((xs ++ ys) ++ zs) ≡ x ∷ (xs ++ (ys ++ zs))</code></pre>
<!--
which is needed in the proof.
-->
<p>即证明中所需。</p>
<!--
It is also easy to show that `[]` is a left and right identity for `_++_`.
That it is a left identity is immediate from the definition:
-->
<p>我们也可以简单地证明 <code>[]</code> 是 <code>_++_</code> 的左幺元和右幺元。 左幺元的证明从定义中即可得：</p>
<pre class="Agda"><a id="++-identityˡ"></a><a id="7367" href="../Lists/#7367" class="Function">++-identityˡ</a> <a id="7380" class="Symbol">:</a> <a id="7382" class="Symbol">∀</a> <a id="7384" class="Symbol">{</a><a id="7385" href="../Lists/#7385" class="Bound">A</a> <a id="7387" class="Symbol">:</a> <a id="7389" class="PrimitiveType">Set</a><a id="7392" class="Symbol">}</a> <a id="7394" class="Symbol">(</a><a id="7395" href="../Lists/#7395" class="Bound">xs</a> <a id="7398" class="Symbol">:</a> <a id="7400" href="../Lists/#1264" class="Datatype">List</a> <a id="7405" href="../Lists/#7385" class="Bound">A</a><a id="7406" class="Symbol">)</a> <a id="7408" class="Symbol">→</a> <a id="7410" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="7413" href="../Lists/#4535" class="Function Operator">++</a> <a id="7416" href="../Lists/#7395" class="Bound">xs</a> <a id="7419" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="7421" href="../Lists/#7395" class="Bound">xs</a>
<a id="7424" href="../Lists/#7367" class="Function">++-identityˡ</a> <a id="7437" href="../Lists/#7437" class="Bound">xs</a> <a id="7440" class="Symbol">=</a>
  <a id="7444" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="7454" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="7457" href="../Lists/#4535" class="Function Operator">++</a> <a id="7460" href="../Lists/#7437" class="Bound">xs</a>
  <a id="7465" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="7473" href="../Lists/#7437" class="Bound">xs</a>
  <a id="7478" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
That it is a right identity follows by simple induction:
-->
右幺元的证明可由简单的归纳得到：
<pre class="Agda"><a id="++-identityʳ"></a><a id="7573" href="../Lists/#7573" class="Function">++-identityʳ</a> <a id="7586" class="Symbol">:</a> <a id="7588" class="Symbol">∀</a> <a id="7590" class="Symbol">{</a><a id="7591" href="../Lists/#7591" class="Bound">A</a> <a id="7593" class="Symbol">:</a> <a id="7595" class="PrimitiveType">Set</a><a id="7598" class="Symbol">}</a> <a id="7600" class="Symbol">(</a><a id="7601" href="../Lists/#7601" class="Bound">xs</a> <a id="7604" class="Symbol">:</a> <a id="7606" href="../Lists/#1264" class="Datatype">List</a> <a id="7611" href="../Lists/#7591" class="Bound">A</a><a id="7612" class="Symbol">)</a> <a id="7614" class="Symbol">→</a> <a id="7616" href="../Lists/#7601" class="Bound">xs</a> <a id="7619" href="../Lists/#4535" class="Function Operator">++</a> <a id="7622" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="7625" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="7627" href="../Lists/#7601" class="Bound">xs</a>
<a id="7630" href="../Lists/#7573" class="Function">++-identityʳ</a> <a id="7643" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="7646" class="Symbol">=</a>
  <a id="7650" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="7660" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="7663" href="../Lists/#4535" class="Function Operator">++</a> <a id="7666" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="7671" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="7679" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="7684" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
<a id="7686" href="../Lists/#7573" class="Function">++-identityʳ</a> <a id="7699" class="Symbol">(</a><a id="7700" href="../Lists/#7700" class="Bound">x</a> <a id="7702" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="7704" href="../Lists/#7704" class="Bound">xs</a><a id="7706" class="Symbol">)</a> <a id="7708" class="Symbol">=</a>
  <a id="7712" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="7722" class="Symbol">(</a><a id="7723" href="../Lists/#7700" class="Bound">x</a> <a id="7725" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="7727" href="../Lists/#7704" class="Bound">xs</a><a id="7729" class="Symbol">)</a> <a id="7731" href="../Lists/#4535" class="Function Operator">++</a> <a id="7734" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="7739" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="7747" href="../Lists/#7700" class="Bound">x</a> <a id="7749" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="7751" class="Symbol">(</a><a id="7752" href="../Lists/#7704" class="Bound">xs</a> <a id="7755" href="../Lists/#4535" class="Function Operator">++</a> <a id="7758" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="7760" class="Symbol">)</a>
  <a id="7764" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="7767" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="7772" class="Symbol">(</a><a id="7773" href="../Lists/#7700" class="Bound">x</a> <a id="7775" href="../Lists/#1308" class="InductiveConstructor Operator">∷_</a><a id="7777" class="Symbol">)</a> <a id="7779" class="Symbol">(</a><a id="7780" href="../Lists/#7573" class="Function">++-identityʳ</a> <a id="7793" href="../Lists/#7704" class="Bound">xs</a><a id="7795" class="Symbol">)</a> <a id="7797" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="7803" href="../Lists/#7700" class="Bound">x</a> <a id="7805" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="7807" href="../Lists/#7704" class="Bound">xs</a>
  <a id="7812" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
As we will see later,
these three properties establish that `_++_` and `[]` form
a _monoid_ over lists.
-->
<p>我们之后会了解到，这三条性质表明了 <code>_++_</code> 和 <code>[]</code> 在列表上构成了一个<strong>幺半群（Monoid）</strong>。</p>
<!--
## Length
-->
<h2 id="长度">长度</h2>
<!--
Our next function finds the length of a list:
-->
<p>在下一个函数里，我们来寻找列表的长度：</p>
<pre class="Agda"><a id="length"></a><a id="8100" href="../Lists/#8100" class="Function">length</a> <a id="8107" class="Symbol">:</a> <a id="8109" class="Symbol">∀</a> <a id="8111" class="Symbol">{</a><a id="8112" href="../Lists/#8112" class="Bound">A</a> <a id="8114" class="Symbol">:</a> <a id="8116" class="PrimitiveType">Set</a><a id="8119" class="Symbol">}</a> <a id="8121" class="Symbol">→</a> <a id="8123" href="../Lists/#1264" class="Datatype">List</a> <a id="8128" href="../Lists/#8112" class="Bound">A</a> <a id="8130" class="Symbol">→</a> <a id="8132" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="8134" href="../Lists/#8100" class="Function">length</a> <a id="8141" href="../Lists/#1293" class="InductiveConstructor">[]</a>        <a id="8151" class="Symbol">=</a>  <a id="8154" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
<a id="8159" href="../Lists/#8100" class="Function">length</a> <a id="8166" class="Symbol">(</a><a id="8167" href="../Lists/#8167" class="Bound">x</a> <a id="8169" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="8171" href="../Lists/#8171" class="Bound">xs</a><a id="8173" class="Symbol">)</a>  <a id="8176" class="Symbol">=</a>  <a id="8179" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8183" class="Symbol">(</a><a id="8184" href="../Lists/#8100" class="Function">length</a> <a id="8191" href="../Lists/#8171" class="Bound">xs</a><a id="8193" class="Symbol">)</a>
</pre>
<!--
Again, it takes an implicit parameter `A`.
The length of the empty list is zero.
The length of a non-empty list
is one greater than the length of the tail of the list.
-->
<p>同样，它取一个隐式参数 <code>A</code>。 空列表的长度为零。非空列表的长度比其尾列表长度多一。</p>
<!--
Here is an example showing how to compute the length of a list:
-->
我们用下面的例子来展示如何计算列表的长度：
<pre class="Agda"><a id="8523" href="../Lists/#8523" class="Function">_</a> <a id="8525" class="Symbol">:</a> <a id="8527" href="../Lists/#8100" class="Function">length</a> <a id="8534" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="8536" class="Number">0</a> <a id="8538" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="8540" class="Number">1</a> <a id="8542" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="8544" class="Number">2</a> <a id="8546" href="../Lists/#3778" class="InductiveConstructor Operator">]</a> <a id="8548" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="8550" class="Number">3</a>
<a id="8552" class="Symbol">_</a> <a id="8554" class="Symbol">=</a>
  <a id="8558" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="8568" href="../Lists/#8100" class="Function">length</a> <a id="8575" class="Symbol">(</a><a id="8576" class="Number">0</a> <a id="8578" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="8580" class="Number">1</a> <a id="8582" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="8584" class="Number">2</a> <a id="8586" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="8588" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="8590" class="Symbol">)</a>
  <a id="8594" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="8602" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8606" class="Symbol">(</a><a id="8607" href="../Lists/#8100" class="Function">length</a> <a id="8614" class="Symbol">(</a><a id="8615" class="Number">1</a> <a id="8617" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="8619" class="Number">2</a> <a id="8621" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="8623" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="8625" class="Symbol">))</a>
  <a id="8630" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="8638" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8642" class="Symbol">(</a><a id="8643" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8647" class="Symbol">(</a><a id="8648" href="../Lists/#8100" class="Function">length</a> <a id="8655" class="Symbol">(</a><a id="8656" class="Number">2</a> <a id="8658" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="8660" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="8662" class="Symbol">)))</a>
  <a id="8668" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="8676" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8680" class="Symbol">(</a><a id="8681" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8685" class="Symbol">(</a><a id="8686" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8690" class="Symbol">(</a><a id="8691" href="../Lists/#8100" class="Function">length</a> <a id="8698" class="Symbol">{</a><a id="8699" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="8700" class="Symbol">}</a> <a id="8702" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="8704" class="Symbol">)))</a>
  <a id="8710" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="8718" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8722" class="Symbol">(</a><a id="8723" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8727" class="Symbol">(</a><a id="8728" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8732" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="8736" class="Symbol">))</a>
  <a id="8741" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
Computing the length of a list requires time
linear in the number of elements in the list.
-->
<p>计算列表的长度需要关于列表元素个数线性的时间。</p>
<!--
In the second-to-last line, we cannot write simply `length []` but
must instead write `length {ℕ} []`.  Since `[]` has no elements, Agda
has insufficient information to infer the implicit parameter.
-->
<p>在倒数第二行中，我们不可以直接写 <code>length []</code>，而需要写 <code>length {ℕ} []</code>。 因为 <code>[]</code> 没有元素，Agda 没有足够的信息来推导其隐式参数。</p>
<!--
## Reasoning about length
-->
<h2 id="论证长度">论证长度</h2>
<!--
The length of one list appended to another is the
sum of the lengths of the lists:
-->
<p>两个附加在一起的列表的长度是两列表长度之和：</p>
<pre class="Agda"><a id="length-++"></a><a id="9336" href="../Lists/#9336" class="Function">length-++</a> <a id="9346" class="Symbol">:</a> <a id="9348" class="Symbol">∀</a> <a id="9350" class="Symbol">{</a><a id="9351" href="../Lists/#9351" class="Bound">A</a> <a id="9353" class="Symbol">:</a> <a id="9355" class="PrimitiveType">Set</a><a id="9358" class="Symbol">}</a> <a id="9360" class="Symbol">(</a><a id="9361" href="../Lists/#9361" class="Bound">xs</a> <a id="9364" href="../Lists/#9364" class="Bound">ys</a> <a id="9367" class="Symbol">:</a> <a id="9369" href="../Lists/#1264" class="Datatype">List</a> <a id="9374" href="../Lists/#9351" class="Bound">A</a><a id="9375" class="Symbol">)</a>
  <a id="9379" class="Symbol">→</a> <a id="9381" href="../Lists/#8100" class="Function">length</a> <a id="9388" class="Symbol">(</a><a id="9389" href="../Lists/#9361" class="Bound">xs</a> <a id="9392" href="../Lists/#4535" class="Function Operator">++</a> <a id="9395" href="../Lists/#9364" class="Bound">ys</a><a id="9397" class="Symbol">)</a> <a id="9399" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="9401" href="../Lists/#8100" class="Function">length</a> <a id="9408" href="../Lists/#9361" class="Bound">xs</a> <a id="9411" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="9413" href="../Lists/#8100" class="Function">length</a> <a id="9420" href="../Lists/#9364" class="Bound">ys</a>
<a id="9423" href="../Lists/#9336" class="Function">length-++</a> <a id="9433" class="Symbol">{</a><a id="9434" href="../Lists/#9434" class="Bound">A</a><a id="9435" class="Symbol">}</a> <a id="9437" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="9440" href="../Lists/#9440" class="Bound">ys</a> <a id="9443" class="Symbol">=</a>
  <a id="9447" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="9457" href="../Lists/#8100" class="Function">length</a> <a id="9464" class="Symbol">(</a><a id="9465" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="9468" href="../Lists/#4535" class="Function Operator">++</a> <a id="9471" href="../Lists/#9440" class="Bound">ys</a><a id="9473" class="Symbol">)</a>
  <a id="9477" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="9485" href="../Lists/#8100" class="Function">length</a> <a id="9492" href="../Lists/#9440" class="Bound">ys</a>
  <a id="9497" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="9505" href="../Lists/#8100" class="Function">length</a> <a id="9512" class="Symbol">{</a><a id="9513" href="../Lists/#9434" class="Bound">A</a><a id="9514" class="Symbol">}</a> <a id="9516" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="9519" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="9521" href="../Lists/#8100" class="Function">length</a> <a id="9528" href="../Lists/#9440" class="Bound">ys</a>
  <a id="9533" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
<a id="9535" href="../Lists/#9336" class="Function">length-++</a> <a id="9545" class="Symbol">(</a><a id="9546" href="../Lists/#9546" class="Bound">x</a> <a id="9548" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="9550" href="../Lists/#9550" class="Bound">xs</a><a id="9552" class="Symbol">)</a> <a id="9554" href="../Lists/#9554" class="Bound">ys</a> <a id="9557" class="Symbol">=</a>
  <a id="9561" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="9571" href="../Lists/#8100" class="Function">length</a> <a id="9578" class="Symbol">((</a><a id="9580" href="../Lists/#9546" class="Bound">x</a> <a id="9582" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="9584" href="../Lists/#9550" class="Bound">xs</a><a id="9586" class="Symbol">)</a> <a id="9588" href="../Lists/#4535" class="Function Operator">++</a> <a id="9591" href="../Lists/#9554" class="Bound">ys</a><a id="9593" class="Symbol">)</a>
  <a id="9597" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="9605" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9609" class="Symbol">(</a><a id="9610" href="../Lists/#8100" class="Function">length</a> <a id="9617" class="Symbol">(</a><a id="9618" href="../Lists/#9550" class="Bound">xs</a> <a id="9621" href="../Lists/#4535" class="Function Operator">++</a> <a id="9624" href="../Lists/#9554" class="Bound">ys</a><a id="9626" class="Symbol">))</a>
  <a id="9631" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="9634" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="9639" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9643" class="Symbol">(</a><a id="9644" href="../Lists/#9336" class="Function">length-++</a> <a id="9654" href="../Lists/#9550" class="Bound">xs</a> <a id="9657" href="../Lists/#9554" class="Bound">ys</a><a id="9659" class="Symbol">)</a> <a id="9661" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="9667" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9671" class="Symbol">(</a><a id="9672" href="../Lists/#8100" class="Function">length</a> <a id="9679" href="../Lists/#9550" class="Bound">xs</a> <a id="9682" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="9684" href="../Lists/#8100" class="Function">length</a> <a id="9691" href="../Lists/#9554" class="Bound">ys</a><a id="9693" class="Symbol">)</a>
  <a id="9697" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="9705" href="../Lists/#8100" class="Function">length</a> <a id="9712" class="Symbol">(</a><a id="9713" href="../Lists/#9546" class="Bound">x</a> <a id="9715" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="9717" href="../Lists/#9550" class="Bound">xs</a><a id="9719" class="Symbol">)</a> <a id="9721" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="9723" href="../Lists/#8100" class="Function">length</a> <a id="9730" href="../Lists/#9554" class="Bound">ys</a>
  <a id="9735" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
The proof is by induction on the first argument. The base case
instantiates to `[]`, and follows by straightforward computation.  As
before, Agda cannot infer the implicit type parameter to `length`, and
it must be given explicitly.  The inductive case instantiates to
`x ∷ xs`, and follows by straightforward computation combined with the
inductive hypothesis.  As usual, the inductive hypothesis is indicated
by a recursive invocation of the proof, in this case `length-++ xs ys`,
and it is promoted by the congruence `cong suc`.
-->
<p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 如同之前一样，Agda 无法推导 <code>length</code> 的隐式参数，所以我们必须显式地给出这个参数。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由直接的运算配合归纳假设可证。 与往常一样，归纳假设由递归使用证明函数来表明，此处为 <code>length-++ xs ys</code>， 由 <code>cong suc</code> 来提升。</p>
<!--
## Reverse
-->
<h2 id="反转">反转</h2>
<!--
Using append, it is easy to formulate a function to reverse a list:
-->
我们可以使用附加，来简单地构造一个函数来反转一个列表：
<pre class="Agda"><a id="reverse"></a><a id="10614" href="../Lists/#10614" class="Function">reverse</a> <a id="10622" class="Symbol">:</a> <a id="10624" class="Symbol">∀</a> <a id="10626" class="Symbol">{</a><a id="10627" href="../Lists/#10627" class="Bound">A</a> <a id="10629" class="Symbol">:</a> <a id="10631" class="PrimitiveType">Set</a><a id="10634" class="Symbol">}</a> <a id="10636" class="Symbol">→</a> <a id="10638" href="../Lists/#1264" class="Datatype">List</a> <a id="10643" href="../Lists/#10627" class="Bound">A</a> <a id="10645" class="Symbol">→</a> <a id="10647" href="../Lists/#1264" class="Datatype">List</a> <a id="10652" href="../Lists/#10627" class="Bound">A</a>
<a id="10654" href="../Lists/#10614" class="Function">reverse</a> <a id="10662" href="../Lists/#1293" class="InductiveConstructor">[]</a>        <a id="10672" class="Symbol">=</a>  <a id="10675" href="../Lists/#1293" class="InductiveConstructor">[]</a>
<a id="10678" href="../Lists/#10614" class="Function">reverse</a> <a id="10686" class="Symbol">(</a><a id="10687" href="../Lists/#10687" class="Bound">x</a> <a id="10689" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="10691" href="../Lists/#10691" class="Bound">xs</a><a id="10693" class="Symbol">)</a>  <a id="10696" class="Symbol">=</a>  <a id="10699" href="../Lists/#10614" class="Function">reverse</a> <a id="10707" href="../Lists/#10691" class="Bound">xs</a> <a id="10710" href="../Lists/#4535" class="Function Operator">++</a> <a id="10713" href="../Lists/#3724" class="InductiveConstructor Operator">[</a> <a id="10715" href="../Lists/#10687" class="Bound">x</a> <a id="10717" href="../Lists/#3724" class="InductiveConstructor Operator">]</a>
</pre>
<!--
The reverse of the empty list is the empty list.
The reverse of a non-empty list
is the reverse of its tail appended to a unit list
containing its head.
-->
<p>空列表的反转是空列表。 非空列表的反转是其头元素构成的单元列表附加至其尾列表反转之后的结果。</p>
<!--
Here is an example showing how to reverse a list:
-->
下面的例子展示了如何反转一个列表。
<pre class="Agda"><a id="11017" href="../Lists/#11017" class="Function">_</a> <a id="11019" class="Symbol">:</a> <a id="11021" href="../Lists/#10614" class="Function">reverse</a> <a id="11029" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="11031" class="Number">0</a> <a id="11033" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="11035" class="Number">1</a> <a id="11037" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="11039" class="Number">2</a> <a id="11041" href="../Lists/#3778" class="InductiveConstructor Operator">]</a> <a id="11043" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="11045" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="11047" class="Number">2</a> <a id="11049" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="11051" class="Number">1</a> <a id="11053" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="11055" class="Number">0</a> <a id="11057" href="../Lists/#3778" class="InductiveConstructor Operator">]</a>
<a id="11059" class="Symbol">_</a> <a id="11061" class="Symbol">=</a>
  <a id="11065" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="11075" href="../Lists/#10614" class="Function">reverse</a> <a id="11083" class="Symbol">(</a><a id="11084" class="Number">0</a> <a id="11086" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11088" class="Number">1</a> <a id="11090" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11092" class="Number">2</a> <a id="11094" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11096" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="11098" class="Symbol">)</a>
  <a id="11102" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="11110" href="../Lists/#10614" class="Function">reverse</a> <a id="11118" class="Symbol">(</a><a id="11119" class="Number">1</a> <a id="11121" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11123" class="Number">2</a> <a id="11125" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11127" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="11129" class="Symbol">)</a> <a id="11131" href="../Lists/#4535" class="Function Operator">++</a> <a id="11134" href="../Lists/#3724" class="InductiveConstructor Operator">[</a> <a id="11136" class="Number">0</a> <a id="11138" href="../Lists/#3724" class="InductiveConstructor Operator">]</a>
  <a id="11142" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="11150" class="Symbol">(</a><a id="11151" href="../Lists/#10614" class="Function">reverse</a> <a id="11159" class="Symbol">(</a><a id="11160" class="Number">2</a> <a id="11162" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11164" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="11166" class="Symbol">)</a> <a id="11168" href="../Lists/#4535" class="Function Operator">++</a> <a id="11171" href="../Lists/#3724" class="InductiveConstructor Operator">[</a> <a id="11173" class="Number">1</a> <a id="11175" href="../Lists/#3724" class="InductiveConstructor Operator">]</a><a id="11176" class="Symbol">)</a> <a id="11178" href="../Lists/#4535" class="Function Operator">++</a> <a id="11181" href="../Lists/#3724" class="InductiveConstructor Operator">[</a> <a id="11183" class="Number">0</a> <a id="11185" href="../Lists/#3724" class="InductiveConstructor Operator">]</a>
  <a id="11189" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="11197" class="Symbol">((</a><a id="11199" href="../Lists/#10614" class="Function">reverse</a> <a id="11207" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="11210" href="../Lists/#4535" class="Function Operator">++</a> <a id="11213" href="../Lists/#3724" class="InductiveConstructor Operator">[</a> <a id="11215" class="Number">2</a> <a id="11217" href="../Lists/#3724" class="InductiveConstructor Operator">]</a><a id="11218" class="Symbol">)</a> <a id="11220" href="../Lists/#4535" class="Function Operator">++</a> <a id="11223" href="../Lists/#3724" class="InductiveConstructor Operator">[</a> <a id="11225" class="Number">1</a> <a id="11227" href="../Lists/#3724" class="InductiveConstructor Operator">]</a><a id="11228" class="Symbol">)</a> <a id="11230" href="../Lists/#4535" class="Function Operator">++</a> <a id="11233" href="../Lists/#3724" class="InductiveConstructor Operator">[</a> <a id="11235" class="Number">0</a> <a id="11237" href="../Lists/#3724" class="InductiveConstructor Operator">]</a>
  <a id="11241" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="11249" class="Symbol">((</a><a id="11251" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="11254" href="../Lists/#4535" class="Function Operator">++</a> <a id="11257" href="../Lists/#3724" class="InductiveConstructor Operator">[</a> <a id="11259" class="Number">2</a> <a id="11261" href="../Lists/#3724" class="InductiveConstructor Operator">]</a><a id="11262" class="Symbol">)</a> <a id="11264" href="../Lists/#4535" class="Function Operator">++</a> <a id="11267" href="../Lists/#3724" class="InductiveConstructor Operator">[</a> <a id="11269" class="Number">1</a> <a id="11271" href="../Lists/#3724" class="InductiveConstructor Operator">]</a><a id="11272" class="Symbol">)</a> <a id="11274" href="../Lists/#4535" class="Function Operator">++</a> <a id="11277" href="../Lists/#3724" class="InductiveConstructor Operator">[</a> <a id="11279" class="Number">0</a> <a id="11281" href="../Lists/#3724" class="InductiveConstructor Operator">]</a>
  <a id="11285" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="11293" class="Symbol">((</a><a id="11295" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="11298" href="../Lists/#4535" class="Function Operator">++</a> <a id="11301" class="Number">2</a> <a id="11303" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11305" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="11307" class="Symbol">)</a> <a id="11309" href="../Lists/#4535" class="Function Operator">++</a> <a id="11312" class="Number">1</a> <a id="11314" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11316" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="11318" class="Symbol">)</a> <a id="11320" href="../Lists/#4535" class="Function Operator">++</a> <a id="11323" class="Number">0</a> <a id="11325" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11327" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="11332" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="11340" class="Symbol">(</a><a id="11341" class="Number">2</a> <a id="11343" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11345" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="11348" href="../Lists/#4535" class="Function Operator">++</a> <a id="11351" class="Number">1</a> <a id="11353" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11355" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="11357" class="Symbol">)</a> <a id="11359" href="../Lists/#4535" class="Function Operator">++</a> <a id="11362" class="Number">0</a> <a id="11364" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11366" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="11371" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="11379" class="Number">2</a> <a id="11381" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11383" class="Symbol">(</a><a id="11384" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="11387" href="../Lists/#4535" class="Function Operator">++</a> <a id="11390" class="Number">1</a> <a id="11392" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11394" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="11396" class="Symbol">)</a> <a id="11398" href="../Lists/#4535" class="Function Operator">++</a> <a id="11401" class="Number">0</a> <a id="11403" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11405" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="11410" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="11418" class="Symbol">(</a><a id="11419" class="Number">2</a> <a id="11421" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11423" class="Number">1</a> <a id="11425" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11427" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="11429" class="Symbol">)</a> <a id="11431" href="../Lists/#4535" class="Function Operator">++</a> <a id="11434" class="Number">0</a> <a id="11436" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11438" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="11443" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="11451" class="Number">2</a> <a id="11453" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11455" class="Symbol">(</a><a id="11456" class="Number">1</a> <a id="11458" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11460" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="11463" href="../Lists/#4535" class="Function Operator">++</a> <a id="11466" class="Number">0</a> <a id="11468" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11470" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="11472" class="Symbol">)</a>
  <a id="11476" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="11484" class="Number">2</a> <a id="11486" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11488" class="Number">1</a> <a id="11490" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11492" class="Symbol">(</a><a id="11493" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="11496" href="../Lists/#4535" class="Function Operator">++</a> <a id="11499" class="Number">0</a> <a id="11501" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11503" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="11505" class="Symbol">)</a>
  <a id="11509" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="11517" class="Number">2</a> <a id="11519" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11521" class="Number">1</a> <a id="11523" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11525" class="Number">0</a> <a id="11527" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="11529" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="11534" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="11542" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="11544" class="Number">2</a> <a id="11546" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="11548" class="Number">1</a> <a id="11550" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="11552" class="Number">0</a> <a id="11554" href="../Lists/#3778" class="InductiveConstructor Operator">]</a>
  <a id="11558" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
Reversing a list in this way takes time _quadratic_ in the length of
the list. This is because reverse ends up appending lists of lengths
`1`, `2`, up to `n - 1`, where `n` is the length of the list being
reversed, append takes time linear in the length of the first
list, and the sum of the numbers up to `n - 1` is `n * (n - 1) / 2`.
(We will validate that last fact in an exercise later in this chapter.)
-->
<p>这样子反转一个列表需要列表长度<strong>二次</strong>的时间。这是因为反转一个长度为 <code>n</code> 的列表需要 将长度为 <code>1</code>、<code>2</code> 直到 <code>n - 1</code> 的列表附加起来，而附加两个列表需要第一个列表长度线性的时间， 因此加起来就需要 <code>n * (n - 1) / 2</code> 的时间。（我们将在本章节后部分验证这一结果）</p>
<!--
#### Exercise `reverse-++-distrib` (recommended)
-->
<h4 id="练习-reverse--distrib推荐">练习 <code>reverse-++-distrib</code>（推荐）</h4>
<!--
Show that the reverse of one list appended to another is the
reverse of the second appended to the reverse of the first:
-->
<p>证明一个列表附加到另外一个列表的反转即是反转后的第二个列表附加至反转后的第一个列表：</p>
<pre><code>reverse (xs ++ ys) ≡ reverse ys ++ reverse xs</code></pre>
<!--
#### Exercise `reverse-involutive` (recommended)
-->
<h4 id="练习-reverse-involutive推荐">练习 <code>reverse-involutive</code>（推荐）</h4>
<!--
A function is an _involution_ if when applied twice it acts
as the identity function.  Show that reverse is an involution:
-->
<p>当一个函数应用两次后与恒等函数作用相同，那么这个函数是一个<strong>对合（Involution）</strong>。 证明反转是一个对合：</p>
<pre><code>reverse (reverse xs) ≡ xs</code></pre>
<!--
## Faster reverse
-->
<h2 id="更快地反转">更快地反转</h2>
<!--
The definition above, while easy to reason about, is less efficient than
one might expect since it takes time quadratic in the length of the list.
The idea is that we generalise reverse to take an additional argument:
-->
<p>上面的定义虽然论证起来方便，但是它比期望中的实现更低效，因为它的运行时间是关于列表长度的二次函数。 我们可以将反转进行推广，使用一个额外的参数：</p>
<pre class="Agda"><a id="shunt"></a><a id="13119" href="../Lists/#13119" class="Function">shunt</a> <a id="13125" class="Symbol">:</a> <a id="13127" class="Symbol">∀</a> <a id="13129" class="Symbol">{</a><a id="13130" href="../Lists/#13130" class="Bound">A</a> <a id="13132" class="Symbol">:</a> <a id="13134" class="PrimitiveType">Set</a><a id="13137" class="Symbol">}</a> <a id="13139" class="Symbol">→</a> <a id="13141" href="../Lists/#1264" class="Datatype">List</a> <a id="13146" href="../Lists/#13130" class="Bound">A</a> <a id="13148" class="Symbol">→</a> <a id="13150" href="../Lists/#1264" class="Datatype">List</a> <a id="13155" href="../Lists/#13130" class="Bound">A</a> <a id="13157" class="Symbol">→</a> <a id="13159" href="../Lists/#1264" class="Datatype">List</a> <a id="13164" href="../Lists/#13130" class="Bound">A</a>
<a id="13166" href="../Lists/#13119" class="Function">shunt</a> <a id="13172" href="../Lists/#1293" class="InductiveConstructor">[]</a>       <a id="13181" href="../Lists/#13181" class="Bound">ys</a>  <a id="13185" class="Symbol">=</a>  <a id="13188" href="../Lists/#13181" class="Bound">ys</a>
<a id="13191" href="../Lists/#13119" class="Function">shunt</a> <a id="13197" class="Symbol">(</a><a id="13198" href="../Lists/#13198" class="Bound">x</a> <a id="13200" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="13202" href="../Lists/#13202" class="Bound">xs</a><a id="13204" class="Symbol">)</a> <a id="13206" href="../Lists/#13206" class="Bound">ys</a>  <a id="13210" class="Symbol">=</a>  <a id="13213" href="../Lists/#13119" class="Function">shunt</a> <a id="13219" href="../Lists/#13202" class="Bound">xs</a> <a id="13222" class="Symbol">(</a><a id="13223" href="../Lists/#13198" class="Bound">x</a> <a id="13225" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="13227" href="../Lists/#13206" class="Bound">ys</a><a id="13229" class="Symbol">)</a>
</pre>
<!--
The definition is by recursion on the first argument. The second argument
actually becomes _larger_, but this is not a problem because the argument
on which we recurse becomes _smaller_.
-->
<p>这个定义对于第一个参数进行递归。第二个参数会变_大_，但这样做没有问题，因为我们递归的参数 在变_小_。</p>
<!--
Shunt is related to reverse as follows:
-->
转移（Shunt）与反转的关系如下：
<pre class="Agda"><a id="shunt-reverse"></a><a id="13560" href="../Lists/#13560" class="Function">shunt-reverse</a> <a id="13574" class="Symbol">:</a> <a id="13576" class="Symbol">∀</a> <a id="13578" class="Symbol">{</a><a id="13579" href="../Lists/#13579" class="Bound">A</a> <a id="13581" class="Symbol">:</a> <a id="13583" class="PrimitiveType">Set</a><a id="13586" class="Symbol">}</a> <a id="13588" class="Symbol">(</a><a id="13589" href="../Lists/#13589" class="Bound">xs</a> <a id="13592" href="../Lists/#13592" class="Bound">ys</a> <a id="13595" class="Symbol">:</a> <a id="13597" href="../Lists/#1264" class="Datatype">List</a> <a id="13602" href="../Lists/#13579" class="Bound">A</a><a id="13603" class="Symbol">)</a>
  <a id="13607" class="Symbol">→</a> <a id="13609" href="../Lists/#13119" class="Function">shunt</a> <a id="13615" href="../Lists/#13589" class="Bound">xs</a> <a id="13618" href="../Lists/#13592" class="Bound">ys</a> <a id="13621" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="13623" href="../Lists/#10614" class="Function">reverse</a> <a id="13631" href="../Lists/#13589" class="Bound">xs</a> <a id="13634" href="../Lists/#4535" class="Function Operator">++</a> <a id="13637" href="../Lists/#13592" class="Bound">ys</a>
<a id="13640" href="../Lists/#13560" class="Function">shunt-reverse</a> <a id="13654" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="13657" href="../Lists/#13657" class="Bound">ys</a> <a id="13660" class="Symbol">=</a>
  <a id="13664" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="13674" href="../Lists/#13119" class="Function">shunt</a> <a id="13680" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="13683" href="../Lists/#13657" class="Bound">ys</a>
  <a id="13688" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="13696" href="../Lists/#13657" class="Bound">ys</a>
  <a id="13701" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="13709" href="../Lists/#10614" class="Function">reverse</a> <a id="13717" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="13720" href="../Lists/#4535" class="Function Operator">++</a> <a id="13723" href="../Lists/#13657" class="Bound">ys</a>
  <a id="13728" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
<a id="13730" href="../Lists/#13560" class="Function">shunt-reverse</a> <a id="13744" class="Symbol">(</a><a id="13745" href="../Lists/#13745" class="Bound">x</a> <a id="13747" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="13749" href="../Lists/#13749" class="Bound">xs</a><a id="13751" class="Symbol">)</a> <a id="13753" href="../Lists/#13753" class="Bound">ys</a> <a id="13756" class="Symbol">=</a>
  <a id="13760" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="13770" href="../Lists/#13119" class="Function">shunt</a> <a id="13776" class="Symbol">(</a><a id="13777" href="../Lists/#13745" class="Bound">x</a> <a id="13779" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="13781" href="../Lists/#13749" class="Bound">xs</a><a id="13783" class="Symbol">)</a> <a id="13785" href="../Lists/#13753" class="Bound">ys</a>
  <a id="13790" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="13798" href="../Lists/#13119" class="Function">shunt</a> <a id="13804" href="../Lists/#13749" class="Bound">xs</a> <a id="13807" class="Symbol">(</a><a id="13808" href="../Lists/#13745" class="Bound">x</a> <a id="13810" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="13812" href="../Lists/#13753" class="Bound">ys</a><a id="13814" class="Symbol">)</a>
  <a id="13818" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="13821" href="../Lists/#13560" class="Function">shunt-reverse</a> <a id="13835" href="../Lists/#13749" class="Bound">xs</a> <a id="13838" class="Symbol">(</a><a id="13839" href="../Lists/#13745" class="Bound">x</a> <a id="13841" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="13843" href="../Lists/#13753" class="Bound">ys</a><a id="13845" class="Symbol">)</a> <a id="13847" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="13853" href="../Lists/#10614" class="Function">reverse</a> <a id="13861" href="../Lists/#13749" class="Bound">xs</a> <a id="13864" href="../Lists/#4535" class="Function Operator">++</a> <a id="13867" class="Symbol">(</a><a id="13868" href="../Lists/#13745" class="Bound">x</a> <a id="13870" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="13872" href="../Lists/#13753" class="Bound">ys</a><a id="13874" class="Symbol">)</a>
  <a id="13878" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="13886" href="../Lists/#10614" class="Function">reverse</a> <a id="13894" href="../Lists/#13749" class="Bound">xs</a> <a id="13897" href="../Lists/#4535" class="Function Operator">++</a> <a id="13900" class="Symbol">(</a><a id="13901" href="../Lists/#3724" class="InductiveConstructor Operator">[</a> <a id="13903" href="../Lists/#13745" class="Bound">x</a> <a id="13905" href="../Lists/#3724" class="InductiveConstructor Operator">]</a> <a id="13907" href="../Lists/#4535" class="Function Operator">++</a> <a id="13910" href="../Lists/#13753" class="Bound">ys</a><a id="13912" class="Symbol">)</a>
  <a id="13916" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="13919" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a> <a id="13923" class="Symbol">(</a><a id="13924" href="../Lists/#5867" class="Function">++-assoc</a> <a id="13933" class="Symbol">(</a><a id="13934" href="../Lists/#10614" class="Function">reverse</a> <a id="13942" href="../Lists/#13749" class="Bound">xs</a><a id="13944" class="Symbol">)</a> <a id="13946" href="../Lists/#3724" class="InductiveConstructor Operator">[</a> <a id="13948" href="../Lists/#13745" class="Bound">x</a> <a id="13950" href="../Lists/#3724" class="InductiveConstructor Operator">]</a> <a id="13952" href="../Lists/#13753" class="Bound">ys</a><a id="13954" class="Symbol">)</a> <a id="13956" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="13962" class="Symbol">(</a><a id="13963" href="../Lists/#10614" class="Function">reverse</a> <a id="13971" href="../Lists/#13749" class="Bound">xs</a> <a id="13974" href="../Lists/#4535" class="Function Operator">++</a> <a id="13977" href="../Lists/#3724" class="InductiveConstructor Operator">[</a> <a id="13979" href="../Lists/#13745" class="Bound">x</a> <a id="13981" href="../Lists/#3724" class="InductiveConstructor Operator">]</a><a id="13982" class="Symbol">)</a> <a id="13984" href="../Lists/#4535" class="Function Operator">++</a> <a id="13987" href="../Lists/#13753" class="Bound">ys</a>
  <a id="13992" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="14000" href="../Lists/#10614" class="Function">reverse</a> <a id="14008" class="Symbol">(</a><a id="14009" href="../Lists/#13745" class="Bound">x</a> <a id="14011" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="14013" href="../Lists/#13749" class="Bound">xs</a><a id="14015" class="Symbol">)</a> <a id="14017" href="../Lists/#4535" class="Function Operator">++</a> <a id="14020" href="../Lists/#13753" class="Bound">ys</a>
  <a id="14025" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
The proof is by induction on the first argument.
The base case instantiates to `[]`, and follows by straightforward computation.
The inductive case instantiates to `x ∷ xs` and follows by the inductive
hypothesis and associativity of append.  When we invoke the inductive hypothesis,
the second argument actually becomes *larger*, but this is not a problem because
the argument on which we induct becomes *smaller*.
-->
<p>证明对于第一个参数进行归纳。起始步骤将列表实例化为 <code>[]</code>，由直接的运算可证。 归纳步骤将列表实例化为 <code>x ∷ xs</code>，由归纳假设和附加的结合律可证。 当我们使用归纳假设时，第二个参数实际上变<strong>大</strong>了，但是这样做没有问题，因为我们归纳的参数变<strong>小</strong>了。</p>
<!--
Generalising on an auxiliary argument, which becomes larger as the argument on
which we recurse or induct becomes smaller, is a common trick. It belongs in
your quiver of arrows, ready to slay the right problem.
-->
<p>使用一个会在归纳或递归的参数变小时，变大的辅助参数来进行推广，是一个常用的技巧。 这个技巧在以后的证明中很有用。</p>
<!--
Having defined shunt be generalisation, it is now easy to respecialise to
give a more efficient definition of reverse:
-->
<p>在定义了推广的转移之后，我们可以将其特化，作为一个更高效的反转的定义：</p>
<pre class="Agda"><a id="reverse′"></a><a id="15042" href="../Lists/#15042" class="Function">reverse′</a> <a id="15051" class="Symbol">:</a> <a id="15053" class="Symbol">∀</a> <a id="15055" class="Symbol">{</a><a id="15056" href="../Lists/#15056" class="Bound">A</a> <a id="15058" class="Symbol">:</a> <a id="15060" class="PrimitiveType">Set</a><a id="15063" class="Symbol">}</a> <a id="15065" class="Symbol">→</a> <a id="15067" href="../Lists/#1264" class="Datatype">List</a> <a id="15072" href="../Lists/#15056" class="Bound">A</a> <a id="15074" class="Symbol">→</a> <a id="15076" href="../Lists/#1264" class="Datatype">List</a> <a id="15081" href="../Lists/#15056" class="Bound">A</a>
<a id="15083" href="../Lists/#15042" class="Function">reverse′</a> <a id="15092" href="../Lists/#15092" class="Bound">xs</a> <a id="15095" class="Symbol">=</a> <a id="15097" href="../Lists/#13119" class="Function">shunt</a> <a id="15103" href="../Lists/#15092" class="Bound">xs</a> <a id="15106" href="../Lists/#1293" class="InductiveConstructor">[]</a>
</pre>
<!--
Given our previous lemma, it is straightforward to show
the two definitions equivalent:
-->
<p>因为我们之前证明的引理，我们可以直接地证明两个定义是等价的：</p>
<pre class="Agda"><a id="reverses"></a><a id="15248" href="../Lists/#15248" class="Function">reverses</a> <a id="15257" class="Symbol">:</a> <a id="15259" class="Symbol">∀</a> <a id="15261" class="Symbol">{</a><a id="15262" href="../Lists/#15262" class="Bound">A</a> <a id="15264" class="Symbol">:</a> <a id="15266" class="PrimitiveType">Set</a><a id="15269" class="Symbol">}</a> <a id="15271" class="Symbol">(</a><a id="15272" href="../Lists/#15272" class="Bound">xs</a> <a id="15275" class="Symbol">:</a> <a id="15277" href="../Lists/#1264" class="Datatype">List</a> <a id="15282" href="../Lists/#15262" class="Bound">A</a><a id="15283" class="Symbol">)</a>
  <a id="15287" class="Symbol">→</a> <a id="15289" href="../Lists/#15042" class="Function">reverse′</a> <a id="15298" href="../Lists/#15272" class="Bound">xs</a> <a id="15301" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="15303" href="../Lists/#10614" class="Function">reverse</a> <a id="15311" href="../Lists/#15272" class="Bound">xs</a>
<a id="15314" href="../Lists/#15248" class="Function">reverses</a> <a id="15323" href="../Lists/#15323" class="Bound">xs</a> <a id="15326" class="Symbol">=</a>
  <a id="15330" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="15340" href="../Lists/#15042" class="Function">reverse′</a> <a id="15349" href="../Lists/#15323" class="Bound">xs</a>
  <a id="15354" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="15362" href="../Lists/#13119" class="Function">shunt</a> <a id="15368" href="../Lists/#15323" class="Bound">xs</a> <a id="15371" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="15376" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="15379" href="../Lists/#13560" class="Function">shunt-reverse</a> <a id="15393" href="../Lists/#15323" class="Bound">xs</a> <a id="15396" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="15399" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="15405" href="../Lists/#10614" class="Function">reverse</a> <a id="15413" href="../Lists/#15323" class="Bound">xs</a> <a id="15416" href="../Lists/#4535" class="Function Operator">++</a> <a id="15419" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="15424" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="15427" href="../Lists/#7573" class="Function">++-identityʳ</a> <a id="15440" class="Symbol">(</a><a id="15441" href="../Lists/#10614" class="Function">reverse</a> <a id="15449" href="../Lists/#15323" class="Bound">xs</a><a id="15451" class="Symbol">)</a> <a id="15453" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="15459" href="../Lists/#10614" class="Function">reverse</a> <a id="15467" href="../Lists/#15323" class="Bound">xs</a>
  <a id="15472" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
Here is an example showing fast reverse of the list `[ 0 , 1 , 2 ]`:
-->
<p>下面的例子展示了如何快速反转列表 <code>[ 0 , 1 , 2 ]</code>：</p>
<pre class="Agda"><a id="15597" href="../Lists/#15597" class="Function">_</a> <a id="15599" class="Symbol">:</a> <a id="15601" href="../Lists/#15042" class="Function">reverse′</a> <a id="15610" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="15612" class="Number">0</a> <a id="15614" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="15616" class="Number">1</a> <a id="15618" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="15620" class="Number">2</a> <a id="15622" href="../Lists/#3778" class="InductiveConstructor Operator">]</a> <a id="15624" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="15626" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="15628" class="Number">2</a> <a id="15630" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="15632" class="Number">1</a> <a id="15634" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="15636" class="Number">0</a> <a id="15638" href="../Lists/#3778" class="InductiveConstructor Operator">]</a>
<a id="15640" class="Symbol">_</a> <a id="15642" class="Symbol">=</a>
  <a id="15646" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="15656" href="../Lists/#15042" class="Function">reverse′</a> <a id="15665" class="Symbol">(</a><a id="15666" class="Number">0</a> <a id="15668" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15670" class="Number">1</a> <a id="15672" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15674" class="Number">2</a> <a id="15676" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15678" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="15680" class="Symbol">)</a>
  <a id="15684" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="15692" href="../Lists/#13119" class="Function">shunt</a> <a id="15698" class="Symbol">(</a><a id="15699" class="Number">0</a> <a id="15701" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15703" class="Number">1</a> <a id="15705" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15707" class="Number">2</a> <a id="15709" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15711" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="15713" class="Symbol">)</a> <a id="15715" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="15720" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="15728" href="../Lists/#13119" class="Function">shunt</a> <a id="15734" class="Symbol">(</a><a id="15735" class="Number">1</a> <a id="15737" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15739" class="Number">2</a> <a id="15741" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15743" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="15745" class="Symbol">)</a> <a id="15747" class="Symbol">(</a><a id="15748" class="Number">0</a> <a id="15750" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15752" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="15754" class="Symbol">)</a>
  <a id="15758" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="15766" href="../Lists/#13119" class="Function">shunt</a> <a id="15772" class="Symbol">(</a><a id="15773" class="Number">2</a> <a id="15775" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15777" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="15779" class="Symbol">)</a> <a id="15781" class="Symbol">(</a><a id="15782" class="Number">1</a> <a id="15784" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15786" class="Number">0</a> <a id="15788" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15790" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="15792" class="Symbol">)</a>
  <a id="15796" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="15804" href="../Lists/#13119" class="Function">shunt</a> <a id="15810" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="15813" class="Symbol">(</a><a id="15814" class="Number">2</a> <a id="15816" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15818" class="Number">1</a> <a id="15820" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15822" class="Number">0</a> <a id="15824" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15826" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="15828" class="Symbol">)</a>
  <a id="15832" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="15840" class="Number">2</a> <a id="15842" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15844" class="Number">1</a> <a id="15846" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15848" class="Number">0</a> <a id="15850" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="15852" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="15857" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
Now the time to reverse a list is linear in the length of the list.
-->
<p>现在反转一个列表需要的时间与列表的长度线性相关。</p>
<!--
## Map {name=Map}
-->
<h2 name="Map" id="映射">映射</h2>
<!--
Map applies a function to every element of a list to generate a corresponding list.
Map is an example of a _higher-order function_, one which takes a function as an
argument or returns a function as a result:
-->
<p>映射将一个函数应用于列表中的所有元素，生成一个对应的列表。 映射是一个<strong>高阶函数（Higher-Order Function）</strong>的例子，它取一个函数作为参数，返回一个函数作为结果：</p>
<pre class="Agda"><a id="map"></a><a id="16331" href="../Lists/#16331" class="Function">map</a> <a id="16335" class="Symbol">:</a> <a id="16337" class="Symbol">∀</a> <a id="16339" class="Symbol">{</a><a id="16340" href="../Lists/#16340" class="Bound">A</a> <a id="16342" href="../Lists/#16342" class="Bound">B</a> <a id="16344" class="Symbol">:</a> <a id="16346" class="PrimitiveType">Set</a><a id="16349" class="Symbol">}</a> <a id="16351" class="Symbol">→</a> <a id="16353" class="Symbol">(</a><a id="16354" href="../Lists/#16340" class="Bound">A</a> <a id="16356" class="Symbol">→</a> <a id="16358" href="../Lists/#16342" class="Bound">B</a><a id="16359" class="Symbol">)</a> <a id="16361" class="Symbol">→</a> <a id="16363" href="../Lists/#1264" class="Datatype">List</a> <a id="16368" href="../Lists/#16340" class="Bound">A</a> <a id="16370" class="Symbol">→</a> <a id="16372" href="../Lists/#1264" class="Datatype">List</a> <a id="16377" href="../Lists/#16342" class="Bound">B</a>
<a id="16379" href="../Lists/#16331" class="Function">map</a> <a id="16383" href="../Lists/#16383" class="Bound">f</a> <a id="16385" href="../Lists/#1293" class="InductiveConstructor">[]</a>        <a id="16395" class="Symbol">=</a>  <a id="16398" href="../Lists/#1293" class="InductiveConstructor">[]</a>
<a id="16401" href="../Lists/#16331" class="Function">map</a> <a id="16405" href="../Lists/#16405" class="Bound">f</a> <a id="16407" class="Symbol">(</a><a id="16408" href="../Lists/#16408" class="Bound">x</a> <a id="16410" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="16412" href="../Lists/#16412" class="Bound">xs</a><a id="16414" class="Symbol">)</a>  <a id="16417" class="Symbol">=</a>  <a id="16420" href="../Lists/#16405" class="Bound">f</a> <a id="16422" href="../Lists/#16408" class="Bound">x</a> <a id="16424" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="16426" href="../Lists/#16331" class="Function">map</a> <a id="16430" href="../Lists/#16405" class="Bound">f</a> <a id="16432" href="../Lists/#16412" class="Bound">xs</a>
</pre>
<!--
Map of the empty list is the empty list.
Map of a non-empty list yields a list
with head the same as the function applied to the head of the given list,
and tail the same as map of the function applied to the tail of the given list.
-->
<p>空列表的映射是空列表。 非空列表的映射生成一个列表，其头元素是原列表的头元素在应用函数之后的结果， 其尾列表是原列表的尾列表映射后的结果。</p>
<!--
Here is an example showing how to use map to increment every element of a list:
-->
<p>下面的例子展示了如何使用映射来增加列表中的每一个元素：</p>
<pre class="Agda"><a id="16877" href="../Lists/#16877" class="Function">_</a> <a id="16879" class="Symbol">:</a> <a id="16881" href="../Lists/#16331" class="Function">map</a> <a id="16885" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="16889" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="16891" class="Number">0</a> <a id="16893" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="16895" class="Number">1</a> <a id="16897" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="16899" class="Number">2</a> <a id="16901" href="../Lists/#3778" class="InductiveConstructor Operator">]</a> <a id="16903" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="16905" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="16907" class="Number">1</a> <a id="16909" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="16911" class="Number">2</a> <a id="16913" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="16915" class="Number">3</a> <a id="16917" href="../Lists/#3778" class="InductiveConstructor Operator">]</a>
<a id="16919" class="Symbol">_</a> <a id="16921" class="Symbol">=</a>
  <a id="16925" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="16935" href="../Lists/#16331" class="Function">map</a> <a id="16939" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="16943" class="Symbol">(</a><a id="16944" class="Number">0</a> <a id="16946" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="16948" class="Number">1</a> <a id="16950" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="16952" class="Number">2</a> <a id="16954" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="16956" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="16958" class="Symbol">)</a>
  <a id="16962" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="16970" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="16974" class="Number">0</a> <a id="16976" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="16978" href="../Lists/#16331" class="Function">map</a> <a id="16982" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="16986" class="Symbol">(</a><a id="16987" class="Number">1</a> <a id="16989" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="16991" class="Number">2</a> <a id="16993" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="16995" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="16997" class="Symbol">)</a>
  <a id="17001" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="17009" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="17013" class="Number">0</a> <a id="17015" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="17017" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="17021" class="Number">1</a> <a id="17023" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="17025" href="../Lists/#16331" class="Function">map</a> <a id="17029" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="17033" class="Symbol">(</a><a id="17034" class="Number">2</a> <a id="17036" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="17038" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="17040" class="Symbol">)</a>
  <a id="17044" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="17052" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="17056" class="Number">0</a> <a id="17058" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="17060" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="17064" class="Number">1</a> <a id="17066" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="17068" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="17072" class="Number">2</a> <a id="17074" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="17076" href="../Lists/#16331" class="Function">map</a> <a id="17080" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="17084" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="17089" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="17097" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="17101" class="Number">0</a> <a id="17103" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="17105" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="17109" class="Number">1</a> <a id="17111" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="17113" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="17117" class="Number">2</a> <a id="17119" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="17121" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="17126" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="17134" class="Number">1</a> <a id="17136" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="17138" class="Number">2</a> <a id="17140" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="17142" class="Number">3</a> <a id="17144" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="17146" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="17151" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
Map requires time linear in the length of the list.
-->
<p>映射需要关于列表长度线性的时间。</p>
<!--
It is often convenient to exploit currying by applying
map to a function to yield a new function, and at a later
point applying the resulting function:
-->
<p>我们常常可以利用柯里化，将映射作用于一个函数，获得另一个函数，然后在之后的时候应用获得的函数：</p>
<pre class="Agda"><a id="sucs"></a><a id="17453" href="../Lists/#17453" class="Function">sucs</a> <a id="17458" class="Symbol">:</a> <a id="17460" href="../Lists/#1264" class="Datatype">List</a> <a id="17465" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="17467" class="Symbol">→</a> <a id="17469" href="../Lists/#1264" class="Datatype">List</a> <a id="17474" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="17476" href="../Lists/#17453" class="Function">sucs</a> <a id="17481" class="Symbol">=</a> <a id="17483" href="../Lists/#16331" class="Function">map</a> <a id="17487" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a>

<a id="17492" href="../Lists/#17492" class="Function">_</a> <a id="17494" class="Symbol">:</a> <a id="17496" href="../Lists/#17453" class="Function">sucs</a> <a id="17501" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="17503" class="Number">0</a> <a id="17505" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="17507" class="Number">1</a> <a id="17509" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="17511" class="Number">2</a> <a id="17513" href="../Lists/#3778" class="InductiveConstructor Operator">]</a> <a id="17515" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="17517" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="17519" class="Number">1</a> <a id="17521" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="17523" class="Number">2</a> <a id="17525" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="17527" class="Number">3</a> <a id="17529" href="../Lists/#3778" class="InductiveConstructor Operator">]</a>
<a id="17531" class="Symbol">_</a> <a id="17533" class="Symbol">=</a>
  <a id="17537" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="17547" href="../Lists/#17453" class="Function">sucs</a> <a id="17552" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="17554" class="Number">0</a> <a id="17556" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="17558" class="Number">1</a> <a id="17560" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="17562" class="Number">2</a> <a id="17564" href="../Lists/#3778" class="InductiveConstructor Operator">]</a>
  <a id="17568" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="17576" href="../Lists/#16331" class="Function">map</a> <a id="17580" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="17584" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="17586" class="Number">0</a> <a id="17588" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="17590" class="Number">1</a> <a id="17592" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="17594" class="Number">2</a> <a id="17596" href="../Lists/#3778" class="InductiveConstructor Operator">]</a>
  <a id="17600" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="17608" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="17610" class="Number">1</a> <a id="17612" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="17614" class="Number">2</a> <a id="17616" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="17618" class="Number">3</a> <a id="17620" href="../Lists/#3778" class="InductiveConstructor Operator">]</a>
  <a id="17624" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
A type that is parameterised on another type, such as list, often has a
corresponding map, which accepts a function and returns a function
from the type parameterised on the domain of the function to the type
parameterised on the range of the function. Further, a type that is
parameterised on _n_ types often has a map that is parameterised on
_n_ functions.
-->
<p>对于由另外一个类型参数化的类型，例如列表，常常有对应的映射，其接受一个函数，并返回另一个 从由给定函数定义域参数化的类型，到由给定函数值域参数化的函数。除此之外，一个对于 <em>n</em> 个类型 参数化的类型常常会有一个对于 <em>n</em> 个函数参数化的映射。</p>
<!--
#### Exercise `map-compose` (practice)
-->
<h4 id="练习-map-compose实践">练习 <code>map-compose</code>（实践）</h4>
<!--
Prove that the map of a composition is equal to the composition of two maps:
-->
<p>证明函数组合的映射是两个映射的组合：</p>
<pre><code>map (g ∘ f) ≡ map g ∘ map f</code></pre>
<!--
The last step of the proof requires extensionality.
-->
<p>证明的最后一步需要外延性。</p>
<pre class="Agda"><a id="18423" class="Comment">-- Your code goes here</a>
</pre>
<!--
#### Exercise `map-++-distribute` (practice)
-->
<h4 id="练习-map--distribute实践">练习 <code>map-++-distribute</code>（实践）</h4>
<!--
Prove the following relationship between map and append:
-->
<p>证明下列关于映射与附加的关系：</p>
<pre><code>map f (xs ++ ys) ≡ map f xs ++ map f ys</code></pre>
<pre class="Agda"><a id="18672" class="Comment">-- Your code goes here</a>
</pre>
<!--
#### Exercise `map-Tree` (practice)
-->
<h4 id="练习-map-tree实践">练习 <code>map-Tree</code>（实践）</h4>
<!--
Define a type of trees with leaves of type `A` and internal
nodes of type `B`:
-->
<p>定义一个树数据类型，其叶节点类型为 <code>A</code>，内部节点类型为 <code>B</code>：</p>
<pre class="Agda"><a id="18899" class="Keyword">data</a> <a id="Tree"></a><a id="18904" href="../Lists/#18904" class="Datatype">Tree</a> <a id="18909" class="Symbol">(</a><a id="18910" href="../Lists/#18910" class="Bound">A</a> <a id="18912" href="../Lists/#18912" class="Bound">B</a> <a id="18914" class="Symbol">:</a> <a id="18916" class="PrimitiveType">Set</a><a id="18919" class="Symbol">)</a> <a id="18921" class="Symbol">:</a> <a id="18923" class="PrimitiveType">Set</a> <a id="18927" class="Keyword">where</a>
  <a id="Tree.leaf"></a><a id="18935" href="../Lists/#18935" class="InductiveConstructor">leaf</a> <a id="18940" class="Symbol">:</a> <a id="18942" href="../Lists/#18910" class="Bound">A</a> <a id="18944" class="Symbol">→</a> <a id="18946" href="../Lists/#18904" class="Datatype">Tree</a> <a id="18951" href="../Lists/#18910" class="Bound">A</a> <a id="18953" href="../Lists/#18912" class="Bound">B</a>
  <a id="Tree.node"></a><a id="18957" href="../Lists/#18957" class="InductiveConstructor">node</a> <a id="18962" class="Symbol">:</a> <a id="18964" href="../Lists/#18904" class="Datatype">Tree</a> <a id="18969" href="../Lists/#18910" class="Bound">A</a> <a id="18971" href="../Lists/#18912" class="Bound">B</a> <a id="18973" class="Symbol">→</a> <a id="18975" href="../Lists/#18912" class="Bound">B</a> <a id="18977" class="Symbol">→</a> <a id="18979" href="../Lists/#18904" class="Datatype">Tree</a> <a id="18984" href="../Lists/#18910" class="Bound">A</a> <a id="18986" href="../Lists/#18912" class="Bound">B</a> <a id="18988" class="Symbol">→</a> <a id="18990" href="../Lists/#18904" class="Datatype">Tree</a> <a id="18995" href="../Lists/#18910" class="Bound">A</a> <a id="18997" href="../Lists/#18912" class="Bound">B</a>
</pre>
<!--
Define a suitable map operator over trees:
-->
<p>定义一个对于树的映射运算符：</p>
<pre><code>map-Tree : ∀ {A B C D : Set} → (A → C) → (B → D) → Tree A B → Tree C D</code></pre>
<pre class="Agda"><a id="19153" class="Comment">-- Your code goes here</a>
</pre>
<!--
## Fold {name=Fold}
-->
<h2 name="Fold" id="折叠">折叠</h2>
<!--
Fold takes an operator and a value, and uses the operator to combine
each of the elements of the list, taking the given value as the result
for the empty list:
-->
<p>折叠取一个运算符和一个值，并使用运算符将列表中的元素合并至一个值，如果给定的列表为空， 则使用给定的值：</p>
<pre class="Agda"><a id="foldr"></a><a id="19458" href="../Lists/#19458" class="Function">foldr</a> <a id="19464" class="Symbol">:</a> <a id="19466" class="Symbol">∀</a> <a id="19468" class="Symbol">{</a><a id="19469" href="../Lists/#19469" class="Bound">A</a> <a id="19471" href="../Lists/#19471" class="Bound">B</a> <a id="19473" class="Symbol">:</a> <a id="19475" class="PrimitiveType">Set</a><a id="19478" class="Symbol">}</a> <a id="19480" class="Symbol">→</a> <a id="19482" class="Symbol">(</a><a id="19483" href="../Lists/#19469" class="Bound">A</a> <a id="19485" class="Symbol">→</a> <a id="19487" href="../Lists/#19471" class="Bound">B</a> <a id="19489" class="Symbol">→</a> <a id="19491" href="../Lists/#19471" class="Bound">B</a><a id="19492" class="Symbol">)</a> <a id="19494" class="Symbol">→</a> <a id="19496" href="../Lists/#19471" class="Bound">B</a> <a id="19498" class="Symbol">→</a> <a id="19500" href="../Lists/#1264" class="Datatype">List</a> <a id="19505" href="../Lists/#19469" class="Bound">A</a> <a id="19507" class="Symbol">→</a> <a id="19509" href="../Lists/#19471" class="Bound">B</a>
<a id="19511" href="../Lists/#19458" class="Function">foldr</a> <a id="19517" href="../Lists/#19517" class="Bound Operator">_⊗_</a> <a id="19521" href="../Lists/#19521" class="Bound">e</a> <a id="19523" href="../Lists/#1293" class="InductiveConstructor">[]</a>        <a id="19533" class="Symbol">=</a>  <a id="19536" href="../Lists/#19521" class="Bound">e</a>
<a id="19538" href="../Lists/#19458" class="Function">foldr</a> <a id="19544" href="../Lists/#19544" class="Bound Operator">_⊗_</a> <a id="19548" href="../Lists/#19548" class="Bound">e</a> <a id="19550" class="Symbol">(</a><a id="19551" href="../Lists/#19551" class="Bound">x</a> <a id="19553" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="19555" href="../Lists/#19555" class="Bound">xs</a><a id="19557" class="Symbol">)</a>  <a id="19560" class="Symbol">=</a>  <a id="19563" href="../Lists/#19551" class="Bound">x</a> <a id="19565" href="../Lists/#19544" class="Bound Operator">⊗</a> <a id="19567" href="../Lists/#19458" class="Function">foldr</a> <a id="19573" href="../Lists/#19544" class="Bound Operator">_⊗_</a> <a id="19577" href="../Lists/#19548" class="Bound">e</a> <a id="19579" href="../Lists/#19555" class="Bound">xs</a>
</pre>
<!--
Fold of the empty list is the given value.
Fold of a non-empty list uses the operator to combine
the head of the list and the fold of the tail of the list.
-->
<p>空列表的折叠是给定的值。 非空列表的折叠使用给定的运算符，将头元素和尾列表的折叠合并起来。</p>
<!--
Here is an example showing how to use fold to find the sum of a list:
-->
<p>下面的例子展示了如何使用折叠来对一个列表求和：</p>
<pre class="Agda"><a id="19909" href="../Lists/#19909" class="Function">_</a> <a id="19911" class="Symbol">:</a> <a id="19913" href="../Lists/#19458" class="Function">foldr</a> <a id="19919" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="19923" class="Number">0</a> <a id="19925" href="../Lists/#3817" class="InductiveConstructor Operator">[</a> <a id="19927" class="Number">1</a> <a id="19929" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="19931" class="Number">2</a> <a id="19933" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="19935" class="Number">3</a> <a id="19937" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="19939" class="Number">4</a> <a id="19941" href="../Lists/#3817" class="InductiveConstructor Operator">]</a> <a id="19943" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="19945" class="Number">10</a>
<a id="19948" class="Symbol">_</a> <a id="19950" class="Symbol">=</a>
  <a id="19954" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="19964" href="../Lists/#19458" class="Function">foldr</a> <a id="19970" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="19974" class="Number">0</a> <a id="19976" class="Symbol">(</a><a id="19977" class="Number">1</a> <a id="19979" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="19981" class="Number">2</a> <a id="19983" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="19985" class="Number">3</a> <a id="19987" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="19989" class="Number">4</a> <a id="19991" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="19993" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="19995" class="Symbol">)</a>
  <a id="19999" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="20007" class="Number">1</a> <a id="20009" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="20011" href="../Lists/#19458" class="Function">foldr</a> <a id="20017" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="20021" class="Number">0</a> <a id="20023" class="Symbol">(</a><a id="20024" class="Number">2</a> <a id="20026" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="20028" class="Number">3</a> <a id="20030" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="20032" class="Number">4</a> <a id="20034" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="20036" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="20038" class="Symbol">)</a>
  <a id="20042" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="20050" class="Number">1</a> <a id="20052" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="20054" class="Symbol">(</a><a id="20055" class="Number">2</a> <a id="20057" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="20059" href="../Lists/#19458" class="Function">foldr</a> <a id="20065" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="20069" class="Number">0</a> <a id="20071" class="Symbol">(</a><a id="20072" class="Number">3</a> <a id="20074" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="20076" class="Number">4</a> <a id="20078" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="20080" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="20082" class="Symbol">))</a>
  <a id="20087" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="20095" class="Number">1</a> <a id="20097" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="20099" class="Symbol">(</a><a id="20100" class="Number">2</a> <a id="20102" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="20104" class="Symbol">(</a><a id="20105" class="Number">3</a> <a id="20107" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="20109" href="../Lists/#19458" class="Function">foldr</a> <a id="20115" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="20119" class="Number">0</a> <a id="20121" class="Symbol">(</a><a id="20122" class="Number">4</a> <a id="20124" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="20126" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="20128" class="Symbol">)))</a>
  <a id="20134" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="20142" class="Number">1</a> <a id="20144" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="20146" class="Symbol">(</a><a id="20147" class="Number">2</a> <a id="20149" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="20151" class="Symbol">(</a><a id="20152" class="Number">3</a> <a id="20154" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="20156" class="Symbol">(</a><a id="20157" class="Number">4</a> <a id="20159" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="20161" href="../Lists/#19458" class="Function">foldr</a> <a id="20167" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="20171" class="Number">0</a> <a id="20173" href="../Lists/#1293" class="InductiveConstructor">[]</a><a id="20175" class="Symbol">)))</a>
  <a id="20181" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="20189" class="Number">1</a> <a id="20191" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="20193" class="Symbol">(</a><a id="20194" class="Number">2</a> <a id="20196" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="20198" class="Symbol">(</a><a id="20199" class="Number">3</a> <a id="20201" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="20203" class="Symbol">(</a><a id="20204" class="Number">4</a> <a id="20206" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="20208" class="Number">0</a><a id="20209" class="Symbol">)))</a>
  <a id="20215" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
Here we have an instance of `foldr` where `A` and `B` are both `ℕ`.
Fold requires time linear in the length of the list.
-->
<p>折叠需要关于列表长度线性的时间。</p>
<!--
It is often convenient to exploit currying by applying
fold to an operator and a value to yield a new function,
and at a later point applying the resulting function:
-->
<p>我们常常可以利用柯里化，将折叠作用于一个运算符和一个值，获得另一个函数， 然后在之后的时候应用获得的函数：</p>
<pre class="Agda"><a id="sum"></a><a id="20606" href="../Lists/#20606" class="Function">sum</a> <a id="20610" class="Symbol">:</a> <a id="20612" href="../Lists/#1264" class="Datatype">List</a> <a id="20617" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="20619" class="Symbol">→</a> <a id="20621" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="20623" href="../Lists/#20606" class="Function">sum</a> <a id="20627" class="Symbol">=</a> <a id="20629" href="../Lists/#19458" class="Function">foldr</a> <a id="20635" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="20639" class="Number">0</a>

<a id="20642" href="../Lists/#20642" class="Function">_</a> <a id="20644" class="Symbol">:</a> <a id="20646" href="../Lists/#20606" class="Function">sum</a> <a id="20650" href="../Lists/#3817" class="InductiveConstructor Operator">[</a> <a id="20652" class="Number">1</a> <a id="20654" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="20656" class="Number">2</a> <a id="20658" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="20660" class="Number">3</a> <a id="20662" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="20664" class="Number">4</a> <a id="20666" href="../Lists/#3817" class="InductiveConstructor Operator">]</a> <a id="20668" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="20670" class="Number">10</a>
<a id="20673" class="Symbol">_</a> <a id="20675" class="Symbol">=</a>
  <a id="20679" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="20689" href="../Lists/#20606" class="Function">sum</a> <a id="20693" href="../Lists/#3817" class="InductiveConstructor Operator">[</a> <a id="20695" class="Number">1</a> <a id="20697" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="20699" class="Number">2</a> <a id="20701" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="20703" class="Number">3</a> <a id="20705" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="20707" class="Number">4</a> <a id="20709" href="../Lists/#3817" class="InductiveConstructor Operator">]</a>
  <a id="20713" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="20721" href="../Lists/#19458" class="Function">foldr</a> <a id="20727" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="20731" class="Number">0</a> <a id="20733" href="../Lists/#3817" class="InductiveConstructor Operator">[</a> <a id="20735" class="Number">1</a> <a id="20737" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="20739" class="Number">2</a> <a id="20741" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="20743" class="Number">3</a> <a id="20745" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="20747" class="Number">4</a> <a id="20749" href="../Lists/#3817" class="InductiveConstructor Operator">]</a>
  <a id="20753" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="20761" class="Number">10</a>
  <a id="20766" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
Just as the list type has two constructors, `[]` and `_∷_`,
so the fold function takes two arguments, `e` and `_⊗_`
(in addition to the list argument).
In general, a data type with _n_ constructors will have
a corresponding fold function that takes _n_ arguments.
-->
<p>正如列表由两个构造子 <code>[]</code> 和 <code>_∷_</code>，折叠函数取两个参数 <code>e</code> 和 <code>_⊗_</code> （除去列表参数）。推广来说，一个有 <em>n</em> 个构造子的数据类型，会有对应的 取 <em>n</em> 个参数的折叠函数。</p>
<!--
As another example, observe that
-->
<p>举另外一个例子，观察</p>
<pre><code>foldr _∷_ [] xs ≡ xs</code></pre>
<!--
Here, if `xs` is of type `List A`, then we see we have an instance of
`foldr` where `A` is `A` and `B` is `List A`.  It follows that
-->
<p>若 <code>xs</code> 的类型为 <code>List A</code>，那么我们就会有一个 <code>foldr</code> 的实例，其中的 <code>A</code> 为 <code>A</code>，而 <code>B</code> 为 <code>List A</code>。它遵循</p>
<pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre>
<!--
Demonstrating both these equations is left as an exercise.
-->
<p>二者相等的证明留作练习。</p>
<!--
#### Exercise `product` (recommended)
-->
<h4 id="练习-product-推荐">练习 <code>product</code> （推荐）</h4>
<!--
Use fold to define a function to find the product of a list of numbers.
For example:
-->
<p>使用折叠来定义一个计算列表数字之积的函数。例如：</p>
<pre><code>product [ 1 , 2 , 3 , 4 ] ≡ 24</code></pre>
<!--
<pre class="Agda"><a id="21805" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="21841" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
#### Exercise `foldr-++` (recommended)
-->
<h4 id="练习-foldr--推荐">练习 <code>foldr-++</code> （推荐）</h4>
<!--
Show that fold and append are related as follows:
-->
<p>证明折叠和附加有如下的关系：</p>
<pre><code>foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ (foldr _⊗_ e ys) xs</code></pre>
<pre class="Agda"><a id="22073" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-foldr--practice">Exercise <code>foldr-∷</code> (practice)</h4>
<p>Show</p>
<pre><code>foldr _∷_ [] xs ≡ xs</code></pre>
<p>Show as a consequence of <code>foldr-++</code> above that</p>
<pre><code>xs ++ ys ≡ foldr _∷_ ys xs</code></pre>
<!--
#### Exercise `map-is-foldr`
-->
<h4 id="练习-map-is-foldr">练习 <code>map-is-foldr</code></h4>
<!--
Show that map can be defined using fold:
-->
<p>证明映射可以用折叠定义：</p>
<pre class="Agda"><a id="22381" class="Comment">-- Your code goes here</a>
</pre>
<!--
This requires extensionality.
-->
<p>此证明需要外延性。</p>
<!--
#### Exercise `map-is-foldr` (practice)
-->
<h4 id="练习-map-is-foldr实践">练习 <code>map-is-foldr</code>（实践）</h4>
<!--
Show that map can be defined using fold:
-->
<p>请证明 map 可使用 fold 来定义：</p>
<pre><code>map f ≡ foldr (λ x xs → f x ∷ xs) []</code></pre>
<!--
The proof requires extensionality.
-->
<p>此证明需要外延性。</p>
<pre class="Agda"><a id="22714" class="Comment">-- Your code goes here</a>
</pre>
<!--
#### Exercise `fold-Tree` (practice)
-->
<h4 id="练习-fold-tree实践">练习 <code>fold-Tree</code>（实践）</h4>
<!--
Define a suitable fold function for the type of trees given earlier:
-->
<p>请为预先给定的三个类型定义一个合适的折叠函数：</p>
<pre><code>fold-Tree : ∀ {A B C : Set} → (A → C) → (C → B → C → C) → Tree A B → C</code></pre>
<!--
<pre class="Agda"><a id="23004" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="23040" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
#### Exercise `map-is-fold-Tree` (practice)
-->
<h4 id="练习-map-is-fold-tree实践">练习 <code>map-is-fold-Tree</code>（实践）</h4>
<!--
Demonstrate an analogue of `map-is-foldr` for the type of trees.
-->
<p>对于树数据类型，证明与 <code>map-is-foldr</code> 相似的性质。</p>
<!--
<pre class="Agda"><a id="23263" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="23299" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
#### Exercise `sum-downFrom` (stretch)
-->
<h4 id="证明-sum-downfrom-延伸">证明 <code>sum-downFrom</code> （延伸）</h4>
<!--
Define a function that counts down as follows:
-->
<p>定义一个向下数数的函数：</p>
<pre class="Agda"><a id="downFrom"></a><a id="23470" href="../Lists/#23470" class="Function">downFrom</a> <a id="23479" class="Symbol">:</a> <a id="23481" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="23483" class="Symbol">→</a> <a id="23485" href="../Lists/#1264" class="Datatype">List</a> <a id="23490" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="23492" href="../Lists/#23470" class="Function">downFrom</a> <a id="23501" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>     <a id="23510" class="Symbol">=</a>  <a id="23513" href="../Lists/#1293" class="InductiveConstructor">[]</a>
<a id="23516" href="../Lists/#23470" class="Function">downFrom</a> <a id="23525" class="Symbol">(</a><a id="23526" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="23530" href="../Lists/#23530" class="Bound">n</a><a id="23531" class="Symbol">)</a>  <a id="23534" class="Symbol">=</a>  <a id="23537" href="../Lists/#23530" class="Bound">n</a> <a id="23539" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="23541" href="../Lists/#23470" class="Function">downFrom</a> <a id="23550" href="../Lists/#23530" class="Bound">n</a>
</pre>
<!--
For example:
-->
<p>例如：</p>
<pre class="Agda"><a id="23589" href="../Lists/#23589" class="Function">_</a> <a id="23591" class="Symbol">:</a> <a id="23593" href="../Lists/#23470" class="Function">downFrom</a> <a id="23602" class="Number">3</a> <a id="23604" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="23606" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="23608" class="Number">2</a> <a id="23610" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="23612" class="Number">1</a> <a id="23614" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="23616" class="Number">0</a> <a id="23618" href="../Lists/#3778" class="InductiveConstructor Operator">]</a>
<a id="23620" class="Symbol">_</a> <a id="23622" class="Symbol">=</a> <a id="23624" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<!--
Prove that the sum of the numbers `(n - 1) + ⋯ + 0` is
equal to `n * (n ∸ 1) / 2`:
-->
<p>证明数列之和 <code>(n - 1) + ⋯ + 0</code> 等于 <code>n * (n ∸ 1) / 2</code>：</p>
<pre><code>sum (downFrom n) * 2 ≡ n * (n ∸ 1)</code></pre>
<!--
## Monoids
-->
<h2 id="幺半群">幺半群</h2>
<!--
Typically when we use a fold the operator is associative and the
value is a left and right identity for the operator, meaning that the
operator and the value form a _monoid_.
-->
<p>一般来说，我们会对于折叠函数使用一个满足结合律的运算符，和这个运算符的左右幺元。 这意味着这个运算符和这个值形成了一个<strong>幺半群</strong>。</p>
<!--
We can define a monoid as a suitable record type:
-->
<p>我们可以用一个合适的记录类型来定义幺半群：</p>
<pre class="Agda"><a id="24186" class="Keyword">record</a> <a id="IsMonoid"></a><a id="24193" href="../Lists/#24193" class="Record">IsMonoid</a> <a id="24202" class="Symbol">{</a><a id="24203" href="../Lists/#24203" class="Bound">A</a> <a id="24205" class="Symbol">:</a> <a id="24207" class="PrimitiveType">Set</a><a id="24210" class="Symbol">}</a> <a id="24212" class="Symbol">(</a><a id="24213" href="../Lists/#24213" class="Bound Operator">_⊗_</a> <a id="24217" class="Symbol">:</a> <a id="24219" href="../Lists/#24203" class="Bound">A</a> <a id="24221" class="Symbol">→</a> <a id="24223" href="../Lists/#24203" class="Bound">A</a> <a id="24225" class="Symbol">→</a> <a id="24227" href="../Lists/#24203" class="Bound">A</a><a id="24228" class="Symbol">)</a> <a id="24230" class="Symbol">(</a><a id="24231" href="../Lists/#24231" class="Bound">e</a> <a id="24233" class="Symbol">:</a> <a id="24235" href="../Lists/#24203" class="Bound">A</a><a id="24236" class="Symbol">)</a> <a id="24238" class="Symbol">:</a> <a id="24240" class="PrimitiveType">Set</a> <a id="24244" class="Keyword">where</a>
  <a id="24252" class="Keyword">field</a>
    <a id="IsMonoid.assoc"></a><a id="24262" href="../Lists/#24262" class="Field">assoc</a> <a id="24268" class="Symbol">:</a> <a id="24270" class="Symbol">∀</a> <a id="24272" class="Symbol">(</a><a id="24273" href="../Lists/#24273" class="Bound">x</a> <a id="24275" href="../Lists/#24275" class="Bound">y</a> <a id="24277" href="../Lists/#24277" class="Bound">z</a> <a id="24279" class="Symbol">:</a> <a id="24281" href="../Lists/#24203" class="Bound">A</a><a id="24282" class="Symbol">)</a> <a id="24284" class="Symbol">→</a> <a id="24286" class="Symbol">(</a><a id="24287" href="../Lists/#24273" class="Bound">x</a> <a id="24289" href="../Lists/#24213" class="Bound Operator">⊗</a> <a id="24291" href="../Lists/#24275" class="Bound">y</a><a id="24292" class="Symbol">)</a> <a id="24294" href="../Lists/#24213" class="Bound Operator">⊗</a> <a id="24296" href="../Lists/#24277" class="Bound">z</a> <a id="24298" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="24300" href="../Lists/#24273" class="Bound">x</a> <a id="24302" href="../Lists/#24213" class="Bound Operator">⊗</a> <a id="24304" class="Symbol">(</a><a id="24305" href="../Lists/#24275" class="Bound">y</a> <a id="24307" href="../Lists/#24213" class="Bound Operator">⊗</a> <a id="24309" href="../Lists/#24277" class="Bound">z</a><a id="24310" class="Symbol">)</a>
    <a id="IsMonoid.identityˡ"></a><a id="24316" href="../Lists/#24316" class="Field">identityˡ</a> <a id="24326" class="Symbol">:</a> <a id="24328" class="Symbol">∀</a> <a id="24330" class="Symbol">(</a><a id="24331" href="../Lists/#24331" class="Bound">x</a> <a id="24333" class="Symbol">:</a> <a id="24335" href="../Lists/#24203" class="Bound">A</a><a id="24336" class="Symbol">)</a> <a id="24338" class="Symbol">→</a> <a id="24340" href="../Lists/#24231" class="Bound">e</a> <a id="24342" href="../Lists/#24213" class="Bound Operator">⊗</a> <a id="24344" href="../Lists/#24331" class="Bound">x</a> <a id="24346" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="24348" href="../Lists/#24331" class="Bound">x</a>
    <a id="IsMonoid.identityʳ"></a><a id="24354" href="../Lists/#24354" class="Field">identityʳ</a> <a id="24364" class="Symbol">:</a> <a id="24366" class="Symbol">∀</a> <a id="24368" class="Symbol">(</a><a id="24369" href="../Lists/#24369" class="Bound">x</a> <a id="24371" class="Symbol">:</a> <a id="24373" href="../Lists/#24203" class="Bound">A</a><a id="24374" class="Symbol">)</a> <a id="24376" class="Symbol">→</a> <a id="24378" href="../Lists/#24369" class="Bound">x</a> <a id="24380" href="../Lists/#24213" class="Bound Operator">⊗</a> <a id="24382" href="../Lists/#24231" class="Bound">e</a> <a id="24384" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="24386" href="../Lists/#24369" class="Bound">x</a>

<a id="24389" class="Keyword">open</a> <a id="24394" href="../Lists/#24193" class="Module">IsMonoid</a>
</pre>
<!--
As examples, sum and zero, multiplication and one, and append and the empty
list, are all examples of monoids:
-->
<p>举例来说，加法和零，乘法和一，附加和空列表，都是幺半群：</p>
<pre class="Agda"><a id="+-monoid"></a><a id="24563" href="../Lists/#24563" class="Function">+-monoid</a> <a id="24572" class="Symbol">:</a> <a id="24574" href="../Lists/#24193" class="Record">IsMonoid</a> <a id="24583" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#325" class="Primitive Operator">_+_</a> <a id="24587" class="Number">0</a>
<a id="24589" href="../Lists/#24563" class="Function">+-monoid</a> <a id="24598" class="Symbol">=</a>
  <a id="24602" class="Keyword">record</a>
    <a id="24613" class="Symbol">{</a> <a id="24615" href="../Lists/#24262" class="Field">assoc</a> <a id="24621" class="Symbol">=</a> <a id="24623" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#12490" class="Function">+-assoc</a>
    <a id="24635" class="Symbol">;</a> <a id="24637" href="../Lists/#24316" class="Field">identityˡ</a> <a id="24647" class="Symbol">=</a> <a id="24649" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#12591" class="Function">+-identityˡ</a>
    <a id="24665" class="Symbol">;</a> <a id="24667" href="../Lists/#24354" class="Field">identityʳ</a> <a id="24677" class="Symbol">=</a> <a id="24679" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#12646" class="Function">+-identityʳ</a>
    <a id="24695" class="Symbol">}</a>

<a id="*-monoid"></a><a id="24698" href="../Lists/#24698" class="Function">*-monoid</a> <a id="24707" class="Symbol">:</a> <a id="24709" href="../Lists/#24193" class="Record">IsMonoid</a> <a id="24718" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#528" class="Primitive Operator">_*_</a> <a id="24722" class="Number">1</a>
<a id="24724" href="../Lists/#24698" class="Function">*-monoid</a> <a id="24733" class="Symbol">=</a>
  <a id="24737" class="Keyword">record</a>
    <a id="24748" class="Symbol">{</a> <a id="24750" href="../Lists/#24262" class="Field">assoc</a> <a id="24756" class="Symbol">=</a> <a id="24758" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#20430" class="Function">*-assoc</a>
    <a id="24770" class="Symbol">;</a> <a id="24772" href="../Lists/#24316" class="Field">identityˡ</a> <a id="24782" class="Symbol">=</a> <a id="24784" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#19330" class="Function">*-identityˡ</a>
    <a id="24800" class="Symbol">;</a> <a id="24802" href="../Lists/#24354" class="Field">identityʳ</a> <a id="24812" class="Symbol">=</a> <a id="24814" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Properties.html#19394" class="Function">*-identityʳ</a>
    <a id="24830" class="Symbol">}</a>

<a id="++-monoid"></a><a id="24833" href="../Lists/#24833" class="Function">++-monoid</a> <a id="24843" class="Symbol">:</a> <a id="24845" class="Symbol">∀</a> <a id="24847" class="Symbol">{</a><a id="24848" href="../Lists/#24848" class="Bound">A</a> <a id="24850" class="Symbol">:</a> <a id="24852" class="PrimitiveType">Set</a><a id="24855" class="Symbol">}</a> <a id="24857" class="Symbol">→</a> <a id="24859" href="../Lists/#24193" class="Record">IsMonoid</a> <a id="24868" class="Symbol">{</a><a id="24869" href="../Lists/#1264" class="Datatype">List</a> <a id="24874" href="../Lists/#24848" class="Bound">A</a><a id="24875" class="Symbol">}</a> <a id="24877" href="../Lists/#4535" class="Function Operator">_++_</a> <a id="24882" href="../Lists/#1293" class="InductiveConstructor">[]</a>
<a id="24885" href="../Lists/#24833" class="Function">++-monoid</a> <a id="24895" class="Symbol">=</a>
  <a id="24899" class="Keyword">record</a>
    <a id="24910" class="Symbol">{</a> <a id="24912" href="../Lists/#24262" class="Field">assoc</a> <a id="24918" class="Symbol">=</a> <a id="24920" href="../Lists/#5867" class="Function">++-assoc</a>
    <a id="24933" class="Symbol">;</a> <a id="24935" href="../Lists/#24316" class="Field">identityˡ</a> <a id="24945" class="Symbol">=</a> <a id="24947" href="../Lists/#7367" class="Function">++-identityˡ</a>
    <a id="24964" class="Symbol">;</a> <a id="24966" href="../Lists/#24354" class="Field">identityʳ</a> <a id="24976" class="Symbol">=</a> <a id="24978" href="../Lists/#7573" class="Function">++-identityʳ</a>
    <a id="24995" class="Symbol">}</a>
</pre>
<!--
If `_⊗_` and `e` form a monoid, then we can re-express fold on the
same operator and an arbitrary value:
-->
<p>如果 <code>_⊗_</code> 和 <code>e</code> 构成一个幺半群，那么我们可以用相同的运算符和一个任意的值来表示折叠：</p>
<pre class="Agda"><a id="foldr-monoid"></a><a id="25172" href="../Lists/#25172" class="Function">foldr-monoid</a> <a id="25185" class="Symbol">:</a> <a id="25187" class="Symbol">∀</a> <a id="25189" class="Symbol">{</a><a id="25190" href="../Lists/#25190" class="Bound">A</a> <a id="25192" class="Symbol">:</a> <a id="25194" class="PrimitiveType">Set</a><a id="25197" class="Symbol">}</a> <a id="25199" class="Symbol">(</a><a id="25200" href="../Lists/#25200" class="Bound Operator">_⊗_</a> <a id="25204" class="Symbol">:</a> <a id="25206" href="../Lists/#25190" class="Bound">A</a> <a id="25208" class="Symbol">→</a> <a id="25210" href="../Lists/#25190" class="Bound">A</a> <a id="25212" class="Symbol">→</a> <a id="25214" href="../Lists/#25190" class="Bound">A</a><a id="25215" class="Symbol">)</a> <a id="25217" class="Symbol">(</a><a id="25218" href="../Lists/#25218" class="Bound">e</a> <a id="25220" class="Symbol">:</a> <a id="25222" href="../Lists/#25190" class="Bound">A</a><a id="25223" class="Symbol">)</a> <a id="25225" class="Symbol">→</a> <a id="25227" href="../Lists/#24193" class="Record">IsMonoid</a> <a id="25236" href="../Lists/#25200" class="Bound Operator">_⊗_</a> <a id="25240" href="../Lists/#25218" class="Bound">e</a> <a id="25242" class="Symbol">→</a>
  <a id="25246" class="Symbol">∀</a> <a id="25248" class="Symbol">(</a><a id="25249" href="../Lists/#25249" class="Bound">xs</a> <a id="25252" class="Symbol">:</a> <a id="25254" href="../Lists/#1264" class="Datatype">List</a> <a id="25259" href="../Lists/#25190" class="Bound">A</a><a id="25260" class="Symbol">)</a> <a id="25262" class="Symbol">(</a><a id="25263" href="../Lists/#25263" class="Bound">y</a> <a id="25265" class="Symbol">:</a> <a id="25267" href="../Lists/#25190" class="Bound">A</a><a id="25268" class="Symbol">)</a> <a id="25270" class="Symbol">→</a> <a id="25272" href="../Lists/#19458" class="Function">foldr</a> <a id="25278" href="../Lists/#25200" class="Bound Operator">_⊗_</a> <a id="25282" href="../Lists/#25263" class="Bound">y</a> <a id="25284" href="../Lists/#25249" class="Bound">xs</a> <a id="25287" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="25289" href="../Lists/#19458" class="Function">foldr</a> <a id="25295" href="../Lists/#25200" class="Bound Operator">_⊗_</a> <a id="25299" href="../Lists/#25218" class="Bound">e</a> <a id="25301" href="../Lists/#25249" class="Bound">xs</a> <a id="25304" href="../Lists/#25200" class="Bound Operator">⊗</a> <a id="25306" href="../Lists/#25263" class="Bound">y</a>
<a id="25308" href="../Lists/#25172" class="Function">foldr-monoid</a> <a id="25321" href="../Lists/#25321" class="Bound Operator">_⊗_</a> <a id="25325" href="../Lists/#25325" class="Bound">e</a> <a id="25327" href="../Lists/#25327" class="Bound">⊗-monoid</a> <a id="25336" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="25339" href="../Lists/#25339" class="Bound">y</a> <a id="25341" class="Symbol">=</a>
  <a id="25345" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="25355" href="../Lists/#19458" class="Function">foldr</a> <a id="25361" href="../Lists/#25321" class="Bound Operator">_⊗_</a> <a id="25365" href="../Lists/#25339" class="Bound">y</a> <a id="25367" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="25372" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="25380" href="../Lists/#25339" class="Bound">y</a>
  <a id="25384" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="25387" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a> <a id="25391" class="Symbol">(</a><a id="25392" href="../Lists/#24316" class="Field">identityˡ</a> <a id="25402" href="../Lists/#25327" class="Bound">⊗-monoid</a> <a id="25411" href="../Lists/#25339" class="Bound">y</a><a id="25412" class="Symbol">)</a> <a id="25414" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="25420" class="Symbol">(</a><a id="25421" href="../Lists/#25325" class="Bound">e</a> <a id="25423" href="../Lists/#25321" class="Bound Operator">⊗</a> <a id="25425" href="../Lists/#25339" class="Bound">y</a><a id="25426" class="Symbol">)</a>
  <a id="25430" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="25438" href="../Lists/#19458" class="Function">foldr</a> <a id="25444" href="../Lists/#25321" class="Bound Operator">_⊗_</a> <a id="25448" href="../Lists/#25325" class="Bound">e</a> <a id="25450" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="25453" href="../Lists/#25321" class="Bound Operator">⊗</a> <a id="25455" href="../Lists/#25339" class="Bound">y</a>
  <a id="25459" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
<a id="25461" href="../Lists/#25172" class="Function">foldr-monoid</a> <a id="25474" href="../Lists/#25474" class="Bound Operator">_⊗_</a> <a id="25478" href="../Lists/#25478" class="Bound">e</a> <a id="25480" href="../Lists/#25480" class="Bound">⊗-monoid</a> <a id="25489" class="Symbol">(</a><a id="25490" href="../Lists/#25490" class="Bound">x</a> <a id="25492" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="25494" href="../Lists/#25494" class="Bound">xs</a><a id="25496" class="Symbol">)</a> <a id="25498" href="../Lists/#25498" class="Bound">y</a> <a id="25500" class="Symbol">=</a>
  <a id="25504" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="25514" href="../Lists/#19458" class="Function">foldr</a> <a id="25520" href="../Lists/#25474" class="Bound Operator">_⊗_</a> <a id="25524" href="../Lists/#25498" class="Bound">y</a> <a id="25526" class="Symbol">(</a><a id="25527" href="../Lists/#25490" class="Bound">x</a> <a id="25529" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="25531" href="../Lists/#25494" class="Bound">xs</a><a id="25533" class="Symbol">)</a>
  <a id="25537" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="25545" href="../Lists/#25490" class="Bound">x</a> <a id="25547" href="../Lists/#25474" class="Bound Operator">⊗</a> <a id="25549" class="Symbol">(</a><a id="25550" href="../Lists/#19458" class="Function">foldr</a> <a id="25556" href="../Lists/#25474" class="Bound Operator">_⊗_</a> <a id="25560" href="../Lists/#25498" class="Bound">y</a> <a id="25562" href="../Lists/#25494" class="Bound">xs</a><a id="25564" class="Symbol">)</a>
  <a id="25568" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="25571" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="25576" class="Symbol">(</a><a id="25577" href="../Lists/#25490" class="Bound">x</a> <a id="25579" href="../Lists/#25474" class="Bound Operator">⊗_</a><a id="25581" class="Symbol">)</a> <a id="25583" class="Symbol">(</a><a id="25584" href="../Lists/#25172" class="Function">foldr-monoid</a> <a id="25597" href="../Lists/#25474" class="Bound Operator">_⊗_</a> <a id="25601" href="../Lists/#25478" class="Bound">e</a> <a id="25603" href="../Lists/#25480" class="Bound">⊗-monoid</a> <a id="25612" href="../Lists/#25494" class="Bound">xs</a> <a id="25615" href="../Lists/#25498" class="Bound">y</a><a id="25616" class="Symbol">)</a> <a id="25618" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="25624" href="../Lists/#25490" class="Bound">x</a> <a id="25626" href="../Lists/#25474" class="Bound Operator">⊗</a> <a id="25628" class="Symbol">(</a><a id="25629" href="../Lists/#19458" class="Function">foldr</a> <a id="25635" href="../Lists/#25474" class="Bound Operator">_⊗_</a> <a id="25639" href="../Lists/#25478" class="Bound">e</a> <a id="25641" href="../Lists/#25494" class="Bound">xs</a> <a id="25644" href="../Lists/#25474" class="Bound Operator">⊗</a> <a id="25646" href="../Lists/#25498" class="Bound">y</a><a id="25647" class="Symbol">)</a>
  <a id="25651" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="25654" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a> <a id="25658" class="Symbol">(</a><a id="25659" href="../Lists/#24262" class="Field">assoc</a> <a id="25665" href="../Lists/#25480" class="Bound">⊗-monoid</a> <a id="25674" href="../Lists/#25490" class="Bound">x</a> <a id="25676" class="Symbol">(</a><a id="25677" href="../Lists/#19458" class="Function">foldr</a> <a id="25683" href="../Lists/#25474" class="Bound Operator">_⊗_</a> <a id="25687" href="../Lists/#25478" class="Bound">e</a> <a id="25689" href="../Lists/#25494" class="Bound">xs</a><a id="25691" class="Symbol">)</a> <a id="25693" href="../Lists/#25498" class="Bound">y</a><a id="25694" class="Symbol">)</a> <a id="25696" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="25702" class="Symbol">(</a><a id="25703" href="../Lists/#25490" class="Bound">x</a> <a id="25705" href="../Lists/#25474" class="Bound Operator">⊗</a> <a id="25707" href="../Lists/#19458" class="Function">foldr</a> <a id="25713" href="../Lists/#25474" class="Bound Operator">_⊗_</a> <a id="25717" href="../Lists/#25478" class="Bound">e</a> <a id="25719" href="../Lists/#25494" class="Bound">xs</a><a id="25721" class="Symbol">)</a> <a id="25723" href="../Lists/#25474" class="Bound Operator">⊗</a> <a id="25725" href="../Lists/#25498" class="Bound">y</a>
  <a id="25729" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="25737" href="../Lists/#19458" class="Function">foldr</a> <a id="25743" href="../Lists/#25474" class="Bound Operator">_⊗_</a> <a id="25747" href="../Lists/#25478" class="Bound">e</a> <a id="25749" class="Symbol">(</a><a id="25750" href="../Lists/#25490" class="Bound">x</a> <a id="25752" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="25754" href="../Lists/#25494" class="Bound">xs</a><a id="25756" class="Symbol">)</a> <a id="25758" href="../Lists/#25474" class="Bound Operator">⊗</a> <a id="25760" href="../Lists/#25498" class="Bound">y</a>
  <a id="25764" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
In a previous exercise we showed the following.
-->
<p>在之前的练习中，我们证明了以下定理：</p>
<pre class="Agda"><a id="25853" class="Keyword">postulate</a>
  <a id="foldr-++"></a><a id="25865" href="../Lists/#25865" class="Postulate">foldr-++</a> <a id="25874" class="Symbol">:</a> <a id="25876" class="Symbol">∀</a> <a id="25878" class="Symbol">{</a><a id="25879" href="../Lists/#25879" class="Bound">A</a> <a id="25881" class="Symbol">:</a> <a id="25883" class="PrimitiveType">Set</a><a id="25886" class="Symbol">}</a> <a id="25888" class="Symbol">(</a><a id="25889" href="../Lists/#25889" class="Bound Operator">_⊗_</a> <a id="25893" class="Symbol">:</a> <a id="25895" href="../Lists/#25879" class="Bound">A</a> <a id="25897" class="Symbol">→</a> <a id="25899" href="../Lists/#25879" class="Bound">A</a> <a id="25901" class="Symbol">→</a> <a id="25903" href="../Lists/#25879" class="Bound">A</a><a id="25904" class="Symbol">)</a> <a id="25906" class="Symbol">(</a><a id="25907" href="../Lists/#25907" class="Bound">e</a> <a id="25909" class="Symbol">:</a> <a id="25911" href="../Lists/#25879" class="Bound">A</a><a id="25912" class="Symbol">)</a> <a id="25914" class="Symbol">(</a><a id="25915" href="../Lists/#25915" class="Bound">xs</a> <a id="25918" href="../Lists/#25918" class="Bound">ys</a> <a id="25921" class="Symbol">:</a> <a id="25923" href="../Lists/#1264" class="Datatype">List</a> <a id="25928" href="../Lists/#25879" class="Bound">A</a><a id="25929" class="Symbol">)</a> <a id="25931" class="Symbol">→</a>
    <a id="25937" href="../Lists/#19458" class="Function">foldr</a> <a id="25943" href="../Lists/#25889" class="Bound Operator">_⊗_</a> <a id="25947" href="../Lists/#25907" class="Bound">e</a> <a id="25949" class="Symbol">(</a><a id="25950" href="../Lists/#25915" class="Bound">xs</a> <a id="25953" href="../Lists/#4535" class="Function Operator">++</a> <a id="25956" href="../Lists/#25918" class="Bound">ys</a><a id="25958" class="Symbol">)</a> <a id="25960" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="25962" href="../Lists/#19458" class="Function">foldr</a> <a id="25968" href="../Lists/#25889" class="Bound Operator">_⊗_</a> <a id="25972" class="Symbol">(</a><a id="25973" href="../Lists/#19458" class="Function">foldr</a> <a id="25979" href="../Lists/#25889" class="Bound Operator">_⊗_</a> <a id="25983" href="../Lists/#25907" class="Bound">e</a> <a id="25985" href="../Lists/#25918" class="Bound">ys</a><a id="25987" class="Symbol">)</a> <a id="25989" href="../Lists/#25915" class="Bound">xs</a>
</pre>
<!--
As a consequence, using a previous exercise, we have the following:
-->
<p>使用之前练习中的一个结论，我们可以得到如下推论：</p>
<pre class="Agda"><a id="foldr-monoid-++"></a><a id="26105" href="../Lists/#26105" class="Function">foldr-monoid-++</a> <a id="26121" class="Symbol">:</a> <a id="26123" class="Symbol">∀</a> <a id="26125" class="Symbol">{</a><a id="26126" href="../Lists/#26126" class="Bound">A</a> <a id="26128" class="Symbol">:</a> <a id="26130" class="PrimitiveType">Set</a><a id="26133" class="Symbol">}</a> <a id="26135" class="Symbol">(</a><a id="26136" href="../Lists/#26136" class="Bound Operator">_⊗_</a> <a id="26140" class="Symbol">:</a> <a id="26142" href="../Lists/#26126" class="Bound">A</a> <a id="26144" class="Symbol">→</a> <a id="26146" href="../Lists/#26126" class="Bound">A</a> <a id="26148" class="Symbol">→</a> <a id="26150" href="../Lists/#26126" class="Bound">A</a><a id="26151" class="Symbol">)</a> <a id="26153" class="Symbol">(</a><a id="26154" href="../Lists/#26154" class="Bound">e</a> <a id="26156" class="Symbol">:</a> <a id="26158" href="../Lists/#26126" class="Bound">A</a><a id="26159" class="Symbol">)</a> <a id="26161" class="Symbol">→</a> <a id="26163" href="../Lists/#24193" class="Record">IsMonoid</a> <a id="26172" href="../Lists/#26136" class="Bound Operator">_⊗_</a> <a id="26176" href="../Lists/#26154" class="Bound">e</a> <a id="26178" class="Symbol">→</a>
  <a id="26182" class="Symbol">∀</a> <a id="26184" class="Symbol">(</a><a id="26185" href="../Lists/#26185" class="Bound">xs</a> <a id="26188" href="../Lists/#26188" class="Bound">ys</a> <a id="26191" class="Symbol">:</a> <a id="26193" href="../Lists/#1264" class="Datatype">List</a> <a id="26198" href="../Lists/#26126" class="Bound">A</a><a id="26199" class="Symbol">)</a> <a id="26201" class="Symbol">→</a> <a id="26203" href="../Lists/#19458" class="Function">foldr</a> <a id="26209" href="../Lists/#26136" class="Bound Operator">_⊗_</a> <a id="26213" href="../Lists/#26154" class="Bound">e</a> <a id="26215" class="Symbol">(</a><a id="26216" href="../Lists/#26185" class="Bound">xs</a> <a id="26219" href="../Lists/#4535" class="Function Operator">++</a> <a id="26222" href="../Lists/#26188" class="Bound">ys</a><a id="26224" class="Symbol">)</a> <a id="26226" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="26228" href="../Lists/#19458" class="Function">foldr</a> <a id="26234" href="../Lists/#26136" class="Bound Operator">_⊗_</a> <a id="26238" href="../Lists/#26154" class="Bound">e</a> <a id="26240" href="../Lists/#26185" class="Bound">xs</a> <a id="26243" href="../Lists/#26136" class="Bound Operator">⊗</a> <a id="26245" href="../Lists/#19458" class="Function">foldr</a> <a id="26251" href="../Lists/#26136" class="Bound Operator">_⊗_</a> <a id="26255" href="../Lists/#26154" class="Bound">e</a> <a id="26257" href="../Lists/#26188" class="Bound">ys</a>
<a id="26260" href="../Lists/#26105" class="Function">foldr-monoid-++</a> <a id="26276" href="../Lists/#26276" class="Bound Operator">_⊗_</a> <a id="26280" href="../Lists/#26280" class="Bound">e</a> <a id="26282" href="../Lists/#26282" class="Bound">monoid-⊗</a> <a id="26291" href="../Lists/#26291" class="Bound">xs</a> <a id="26294" href="../Lists/#26294" class="Bound">ys</a> <a id="26297" class="Symbol">=</a>
  <a id="26301" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="26311" href="../Lists/#19458" class="Function">foldr</a> <a id="26317" href="../Lists/#26276" class="Bound Operator">_⊗_</a> <a id="26321" href="../Lists/#26280" class="Bound">e</a> <a id="26323" class="Symbol">(</a><a id="26324" href="../Lists/#26291" class="Bound">xs</a> <a id="26327" href="../Lists/#4535" class="Function Operator">++</a> <a id="26330" href="../Lists/#26294" class="Bound">ys</a><a id="26332" class="Symbol">)</a>
  <a id="26336" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="26339" href="../Lists/#25865" class="Postulate">foldr-++</a> <a id="26348" href="../Lists/#26276" class="Bound Operator">_⊗_</a> <a id="26352" href="../Lists/#26280" class="Bound">e</a> <a id="26354" href="../Lists/#26291" class="Bound">xs</a> <a id="26357" href="../Lists/#26294" class="Bound">ys</a> <a id="26360" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="26366" href="../Lists/#19458" class="Function">foldr</a> <a id="26372" href="../Lists/#26276" class="Bound Operator">_⊗_</a> <a id="26376" class="Symbol">(</a><a id="26377" href="../Lists/#19458" class="Function">foldr</a> <a id="26383" href="../Lists/#26276" class="Bound Operator">_⊗_</a> <a id="26387" href="../Lists/#26280" class="Bound">e</a> <a id="26389" href="../Lists/#26294" class="Bound">ys</a><a id="26391" class="Symbol">)</a> <a id="26393" href="../Lists/#26291" class="Bound">xs</a>
  <a id="26398" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">≡⟨</a> <a id="26401" href="../Lists/#25172" class="Function">foldr-monoid</a> <a id="26414" href="../Lists/#26276" class="Bound Operator">_⊗_</a> <a id="26418" href="../Lists/#26280" class="Bound">e</a> <a id="26420" href="../Lists/#26282" class="Bound">monoid-⊗</a> <a id="26429" href="../Lists/#26291" class="Bound">xs</a> <a id="26432" class="Symbol">(</a><a id="26433" href="../Lists/#19458" class="Function">foldr</a> <a id="26439" href="../Lists/#26276" class="Bound Operator">_⊗_</a> <a id="26443" href="../Lists/#26280" class="Bound">e</a> <a id="26445" href="../Lists/#26294" class="Bound">ys</a><a id="26447" class="Symbol">)</a> <a id="26449" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2634" class="Function">⟩</a>
    <a id="26455" href="../Lists/#19458" class="Function">foldr</a> <a id="26461" href="../Lists/#26276" class="Bound Operator">_⊗_</a> <a id="26465" href="../Lists/#26280" class="Bound">e</a> <a id="26467" href="../Lists/#26291" class="Bound">xs</a> <a id="26470" href="../Lists/#26276" class="Bound Operator">⊗</a> <a id="26472" href="../Lists/#19458" class="Function">foldr</a> <a id="26478" href="../Lists/#26276" class="Bound Operator">_⊗_</a> <a id="26482" href="../Lists/#26280" class="Bound">e</a> <a id="26484" href="../Lists/#26294" class="Bound">ys</a>
  <a id="26489" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
#### Exercise `foldl` (practice)
-->
<h4 id="练习-foldl实践">练习 <code>foldl</code>（实践）</h4>
<!--
Define a function `foldl` which is analogous to `foldr`, but where
operations associate to the left rather than the right.  For example:
-->
<p>定义一个函数 <code>foldl</code>，与 <code>foldr</code> 相似，但是运算符向左结合，而不是向右。例如：</p>
<pre><code>foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z</code></pre>
<!--
<pre class="Agda"><a id="26870" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="26906" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
#### Exercise `foldr-monoid-foldl`
-->
<h4 id="练习-foldr-monoid-foldl实践">练习 <code>foldr-monoid-foldl</code>（实践）</h4>
<!--
Show that if `_⊗_` and `e` form a monoid, then `foldr _⊗_ e` and
`foldl _⊗_ e` always compute the same result.
-->
<p>证明如果 <code>_⊗_</code> 和 <code>e</code> 构成幺半群，那么 <code>foldr _⊗_ e</code> 和 <code>foldl _⊗_ e</code> 的结果 永远是相同的。</p>
<!--
<pre class="Agda"><a id="27203" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="27239" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
## All {name=All}
-->
<h2 name="All" id="所有">所有</h2>
<!--
We can also define predicates over lists. Two of the most important
are `All` and `Any`.
-->
<p>我们也可以定义关于列表的谓词。最重要的两个谓词是 <code>All</code> 和 <code>Any</code>。</p>
<!--
Predicate `All P` holds if predicate `P` is satisfied by every element of a list:
-->
<p>谓词 <code>All P</code> 当列表里的所有元素满足 <code>P</code> 时成立：</p>
<pre class="Agda"><a id="27573" class="Keyword">data</a> <a id="All"></a><a id="27578" href="../Lists/#27578" class="Datatype">All</a> <a id="27582" class="Symbol">{</a><a id="27583" href="../Lists/#27583" class="Bound">A</a> <a id="27585" class="Symbol">:</a> <a id="27587" class="PrimitiveType">Set</a><a id="27590" class="Symbol">}</a> <a id="27592" class="Symbol">(</a><a id="27593" href="../Lists/#27593" class="Bound">P</a> <a id="27595" class="Symbol">:</a> <a id="27597" href="../Lists/#27583" class="Bound">A</a> <a id="27599" class="Symbol">→</a> <a id="27601" class="PrimitiveType">Set</a><a id="27604" class="Symbol">)</a> <a id="27606" class="Symbol">:</a> <a id="27608" href="../Lists/#1264" class="Datatype">List</a> <a id="27613" href="../Lists/#27583" class="Bound">A</a> <a id="27615" class="Symbol">→</a> <a id="27617" class="PrimitiveType">Set</a> <a id="27621" class="Keyword">where</a>
  <a id="All.[]"></a><a id="27629" href="../Lists/#27629" class="InductiveConstructor">[]</a>  <a id="27633" class="Symbol">:</a> <a id="27635" href="../Lists/#27578" class="Datatype">All</a> <a id="27639" href="../Lists/#27593" class="Bound">P</a> <a id="27641" href="../Lists/#1293" class="InductiveConstructor">[]</a>
  <a id="All._∷_"></a><a id="27646" href="../Lists/#27646" class="InductiveConstructor Operator">_∷_</a> <a id="27650" class="Symbol">:</a> <a id="27652" class="Symbol">∀</a> <a id="27654" class="Symbol">{</a><a id="27655" href="../Lists/#27655" class="Bound">x</a> <a id="27657" class="Symbol">:</a> <a id="27659" href="../Lists/#27583" class="Bound">A</a><a id="27660" class="Symbol">}</a> <a id="27662" class="Symbol">{</a><a id="27663" href="../Lists/#27663" class="Bound">xs</a> <a id="27666" class="Symbol">:</a> <a id="27668" href="../Lists/#1264" class="Datatype">List</a> <a id="27673" href="../Lists/#27583" class="Bound">A</a><a id="27674" class="Symbol">}</a> <a id="27676" class="Symbol">→</a> <a id="27678" href="../Lists/#27593" class="Bound">P</a> <a id="27680" href="../Lists/#27655" class="Bound">x</a> <a id="27682" class="Symbol">→</a> <a id="27684" href="../Lists/#27578" class="Datatype">All</a> <a id="27688" href="../Lists/#27593" class="Bound">P</a> <a id="27690" href="../Lists/#27663" class="Bound">xs</a> <a id="27693" class="Symbol">→</a> <a id="27695" href="../Lists/#27578" class="Datatype">All</a> <a id="27699" href="../Lists/#27593" class="Bound">P</a> <a id="27701" class="Symbol">(</a><a id="27702" href="../Lists/#27655" class="Bound">x</a> <a id="27704" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="27706" href="../Lists/#27663" class="Bound">xs</a><a id="27708" class="Symbol">)</a>
</pre>
<!--
The type has two constructors, reusing the names of the same constructors for lists.
The first asserts that `P` holds for every element of the empty list.
The second asserts that if `P` holds of the head of a list and for every
element of the tail of a list, then `P` holds for every element of the list.
Agda uses types to disambiguate whether the constructor is building
a list or evidence that `All P` holds.
-->
<p>这个类型有两个构造子，使用了与列表构造子相同的名称。第一个断言了 <code>P</code> 对于空列表的任何元素成立。 第二个断言了如果 <code>P</code> 对于列表的头元素和尾列表的所有元素成立，那么 <code>P</code> 对于这个列表的任何元素成立。 Agda 使用类型来区分构造子是用于构造一个列表，还是构造 <code>All P</code> 成立的证明。</p>
<!--
For example, `All (_≤ 2)` holds of a list where every element is less
than or equal to two.  Recall that `z≤n` proves `zero ≤ n` for any
`n`, and that if `m≤n` proves `m ≤ n` then `s≤s m≤n` proves `suc m ≤
suc n`, for any `m` and `n`:
-->
<p>比如说，<code>All (_≤ 2)</code> 对于一个每一个元素都小于等于二的列表成立。 回忆 <code>z≤n</code> 证明了对于任意 <code>n</code>， <code>zero ≤ n</code> 成立； 对于任意 <code>m</code> 和 <code>n</code>，如果 <code>m≤n</code> 证明了 <code>m ≤ n</code>，那么 <code>s≤s m≤n</code> 证明了 <code>suc m ≤ suc n</code>:</p>
<pre class="Agda"><a id="28685" href="../Lists/#28685" class="Function">_</a> <a id="28687" class="Symbol">:</a> <a id="28689" href="../Lists/#27578" class="Datatype">All</a> <a id="28693" class="Symbol">(</a><a id="28694" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#937" class="Datatype Operator">_≤</a> <a id="28697" class="Number">2</a><a id="28698" class="Symbol">)</a> <a id="28700" href="../Lists/#3778" class="InductiveConstructor Operator">[</a> <a id="28702" class="Number">0</a> <a id="28704" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="28706" class="Number">1</a> <a id="28708" href="../Lists/#3778" class="InductiveConstructor Operator">,</a> <a id="28710" class="Number">2</a> <a id="28712" href="../Lists/#3778" class="InductiveConstructor Operator">]</a>
<a id="28714" class="Symbol">_</a> <a id="28716" class="Symbol">=</a> <a id="28718" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a> <a id="28722" href="../Lists/#27646" class="InductiveConstructor Operator">∷</a> <a id="28724" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="28728" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a> <a id="28732" href="../Lists/#27646" class="InductiveConstructor Operator">∷</a> <a id="28734" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="28738" class="Symbol">(</a><a id="28739" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="28743" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a><a id="28746" class="Symbol">)</a> <a id="28748" href="../Lists/#27646" class="InductiveConstructor Operator">∷</a> <a id="28750" href="../Lists/#27629" class="InductiveConstructor">[]</a>
</pre>
<!--
Here `_∷_` and `[]` are the constructors of `All P` rather than of `List A`.
The three items are proofs of `0 ≤ 2`, `1 ≤ 2`, and `2 ≤ 2`, respectively.
-->
<p>这里 <code>_∷_</code> 和 <code>[]</code> 是 <code>All P</code> 的构造子，而不是 <code>List A</code> 的。 这三项分别是 <code>0 ≤ 2</code>、 <code>1 ≤ 2</code> 和 <code>2 ≤ 2</code> 的证明。</p>
<!--
(One might wonder whether a pattern such as `[_,_,_]` can be used to
construct values of type `All` as well as type `List`, since both use
the same constructors. Indeed it can, so long as both types are in
scope when the pattern is declared.  That's not the case here, since
`List` is defined before `[_,_,_]`, but `All` is defined later.)
-->
<p>（读者可能会思考诸如 <code>[_,_,_]</code> 的模式是否可以用于构造 <code>All</code> 类型的值， 像构造 <code>List</code> 类型的一样，因为两者使用了相同的构造子。事实上这样做是可以的，只要两个类型 在模式声明时在作用域内。然而现在不是这样的情况，因为 <code>List</code> 先于 <code>[_,_,_]</code> 定义，而 <code>All</code> 在 之后定义。）</p>
<!--
## Any
-->
<h2 id="任意">任意</h2>
<!--
Predicate `Any P` holds if predicate `P` is satisfied by some element of a list:
-->
<p>谓词 <code>Any P</code> 当列表里的一些元素满足 <code>P</code> 时成立：</p>
<pre class="Agda"><a id="29671" class="Keyword">data</a> <a id="Any"></a><a id="29676" href="../Lists/#29676" class="Datatype">Any</a> <a id="29680" class="Symbol">{</a><a id="29681" href="../Lists/#29681" class="Bound">A</a> <a id="29683" class="Symbol">:</a> <a id="29685" class="PrimitiveType">Set</a><a id="29688" class="Symbol">}</a> <a id="29690" class="Symbol">(</a><a id="29691" href="../Lists/#29691" class="Bound">P</a> <a id="29693" class="Symbol">:</a> <a id="29695" href="../Lists/#29681" class="Bound">A</a> <a id="29697" class="Symbol">→</a> <a id="29699" class="PrimitiveType">Set</a><a id="29702" class="Symbol">)</a> <a id="29704" class="Symbol">:</a> <a id="29706" href="../Lists/#1264" class="Datatype">List</a> <a id="29711" href="../Lists/#29681" class="Bound">A</a> <a id="29713" class="Symbol">→</a> <a id="29715" class="PrimitiveType">Set</a> <a id="29719" class="Keyword">where</a>
  <a id="Any.here"></a><a id="29727" href="../Lists/#29727" class="InductiveConstructor">here</a>  <a id="29733" class="Symbol">:</a> <a id="29735" class="Symbol">∀</a> <a id="29737" class="Symbol">{</a><a id="29738" href="../Lists/#29738" class="Bound">x</a> <a id="29740" class="Symbol">:</a> <a id="29742" href="../Lists/#29681" class="Bound">A</a><a id="29743" class="Symbol">}</a> <a id="29745" class="Symbol">{</a><a id="29746" href="../Lists/#29746" class="Bound">xs</a> <a id="29749" class="Symbol">:</a> <a id="29751" href="../Lists/#1264" class="Datatype">List</a> <a id="29756" href="../Lists/#29681" class="Bound">A</a><a id="29757" class="Symbol">}</a> <a id="29759" class="Symbol">→</a> <a id="29761" href="../Lists/#29691" class="Bound">P</a> <a id="29763" href="../Lists/#29738" class="Bound">x</a> <a id="29765" class="Symbol">→</a> <a id="29767" href="../Lists/#29676" class="Datatype">Any</a> <a id="29771" href="../Lists/#29691" class="Bound">P</a> <a id="29773" class="Symbol">(</a><a id="29774" href="../Lists/#29738" class="Bound">x</a> <a id="29776" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="29778" href="../Lists/#29746" class="Bound">xs</a><a id="29780" class="Symbol">)</a>
  <a id="Any.there"></a><a id="29784" href="../Lists/#29784" class="InductiveConstructor">there</a> <a id="29790" class="Symbol">:</a> <a id="29792" class="Symbol">∀</a> <a id="29794" class="Symbol">{</a><a id="29795" href="../Lists/#29795" class="Bound">x</a> <a id="29797" class="Symbol">:</a> <a id="29799" href="../Lists/#29681" class="Bound">A</a><a id="29800" class="Symbol">}</a> <a id="29802" class="Symbol">{</a><a id="29803" href="../Lists/#29803" class="Bound">xs</a> <a id="29806" class="Symbol">:</a> <a id="29808" href="../Lists/#1264" class="Datatype">List</a> <a id="29813" href="../Lists/#29681" class="Bound">A</a><a id="29814" class="Symbol">}</a> <a id="29816" class="Symbol">→</a> <a id="29818" href="../Lists/#29676" class="Datatype">Any</a> <a id="29822" href="../Lists/#29691" class="Bound">P</a> <a id="29824" href="../Lists/#29803" class="Bound">xs</a> <a id="29827" class="Symbol">→</a> <a id="29829" href="../Lists/#29676" class="Datatype">Any</a> <a id="29833" href="../Lists/#29691" class="Bound">P</a> <a id="29835" class="Symbol">(</a><a id="29836" href="../Lists/#29795" class="Bound">x</a> <a id="29838" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="29840" href="../Lists/#29803" class="Bound">xs</a><a id="29842" class="Symbol">)</a>
</pre>
<!--
The first constructor provides evidence that the head of the list
satisfies `P`, while the second provides evidence that some element of
the tail of the list satisfies `P`.  For example, we can define list
membership as follows:
-->
<p>第一个构造子证明了列表的头元素满足 <code>P</code>，第二个构造子证明的列表的尾列表中的一些元素满足 <code>P</code>。 举例来说，我们可以如下定义列表的成员关系：</p>
<pre class="Agda"><a id="30166" class="Keyword">infix</a> <a id="30172" class="Number">4</a> <a id="30174" href="../Lists/#30183" class="Function Operator">_∈_</a> <a id="30178" href="../Lists/#30253" class="Function Operator">_∉_</a>

<a id="_∈_"></a><a id="30183" href="../Lists/#30183" class="Function Operator">_∈_</a> <a id="30187" class="Symbol">:</a> <a id="30189" class="Symbol">∀</a> <a id="30191" class="Symbol">{</a><a id="30192" href="../Lists/#30192" class="Bound">A</a> <a id="30194" class="Symbol">:</a> <a id="30196" class="PrimitiveType">Set</a><a id="30199" class="Symbol">}</a> <a id="30201" class="Symbol">(</a><a id="30202" href="../Lists/#30202" class="Bound">x</a> <a id="30204" class="Symbol">:</a> <a id="30206" href="../Lists/#30192" class="Bound">A</a><a id="30207" class="Symbol">)</a> <a id="30209" class="Symbol">(</a><a id="30210" href="../Lists/#30210" class="Bound">xs</a> <a id="30213" class="Symbol">:</a> <a id="30215" href="../Lists/#1264" class="Datatype">List</a> <a id="30220" href="../Lists/#30192" class="Bound">A</a><a id="30221" class="Symbol">)</a> <a id="30223" class="Symbol">→</a> <a id="30225" class="PrimitiveType">Set</a>
<a id="30229" href="../Lists/#30229" class="Bound">x</a> <a id="30231" href="../Lists/#30183" class="Function Operator">∈</a> <a id="30233" href="../Lists/#30233" class="Bound">xs</a> <a id="30236" class="Symbol">=</a> <a id="30238" href="../Lists/#29676" class="Datatype">Any</a> <a id="30242" class="Symbol">(</a><a id="30243" href="../Lists/#30229" class="Bound">x</a> <a id="30245" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡_</a><a id="30247" class="Symbol">)</a> <a id="30249" href="../Lists/#30233" class="Bound">xs</a>

<a id="_∉_"></a><a id="30253" href="../Lists/#30253" class="Function Operator">_∉_</a> <a id="30257" class="Symbol">:</a> <a id="30259" class="Symbol">∀</a> <a id="30261" class="Symbol">{</a><a id="30262" href="../Lists/#30262" class="Bound">A</a> <a id="30264" class="Symbol">:</a> <a id="30266" class="PrimitiveType">Set</a><a id="30269" class="Symbol">}</a> <a id="30271" class="Symbol">(</a><a id="30272" href="../Lists/#30272" class="Bound">x</a> <a id="30274" class="Symbol">:</a> <a id="30276" href="../Lists/#30262" class="Bound">A</a><a id="30277" class="Symbol">)</a> <a id="30279" class="Symbol">(</a><a id="30280" href="../Lists/#30280" class="Bound">xs</a> <a id="30283" class="Symbol">:</a> <a id="30285" href="../Lists/#1264" class="Datatype">List</a> <a id="30290" href="../Lists/#30262" class="Bound">A</a><a id="30291" class="Symbol">)</a> <a id="30293" class="Symbol">→</a> <a id="30295" class="PrimitiveType">Set</a>
<a id="30299" href="../Lists/#30299" class="Bound">x</a> <a id="30301" href="../Lists/#30253" class="Function Operator">∉</a> <a id="30303" href="../Lists/#30303" class="Bound">xs</a> <a id="30306" class="Symbol">=</a> <a id="30308" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="30310" class="Symbol">(</a><a id="30311" href="../Lists/#30299" class="Bound">x</a> <a id="30313" href="../Lists/#30183" class="Function Operator">∈</a> <a id="30315" href="../Lists/#30303" class="Bound">xs</a><a id="30317" class="Symbol">)</a>
</pre>
<!--
For example, zero is an element of the list `[ 0 , 1 , 0 , 2 ]`.  Indeed, we can demonstrate
this fact in two different ways, corresponding to the two different
occurrences of zero in the list, as the first element and as the third element:
-->
<p>比如说，零是列表 <code>[ 0 , 1 , 0 , 2 ]</code> 中的一个元素。 我们可以用两种方法来展示这个事实，对应零在列表中出现了两次：第一个元素和第三个元素：</p>
<pre class="Agda"><a id="30660" href="../Lists/#30660" class="Function">_</a> <a id="30662" class="Symbol">:</a> <a id="30664" class="Number">0</a> <a id="30666" href="../Lists/#30183" class="Function Operator">∈</a> <a id="30668" href="../Lists/#3817" class="InductiveConstructor Operator">[</a> <a id="30670" class="Number">0</a> <a id="30672" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="30674" class="Number">1</a> <a id="30676" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="30678" class="Number">0</a> <a id="30680" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="30682" class="Number">2</a> <a id="30684" href="../Lists/#3817" class="InductiveConstructor Operator">]</a>
<a id="30686" class="Symbol">_</a> <a id="30688" class="Symbol">=</a> <a id="30690" href="../Lists/#29727" class="InductiveConstructor">here</a> <a id="30695" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="30701" href="../Lists/#30701" class="Function">_</a> <a id="30703" class="Symbol">:</a> <a id="30705" class="Number">0</a> <a id="30707" href="../Lists/#30183" class="Function Operator">∈</a> <a id="30709" href="../Lists/#3817" class="InductiveConstructor Operator">[</a> <a id="30711" class="Number">0</a> <a id="30713" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="30715" class="Number">1</a> <a id="30717" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="30719" class="Number">0</a> <a id="30721" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="30723" class="Number">2</a> <a id="30725" href="../Lists/#3817" class="InductiveConstructor Operator">]</a>
<a id="30727" class="Symbol">_</a> <a id="30729" class="Symbol">=</a> <a id="30731" href="../Lists/#29784" class="InductiveConstructor">there</a> <a id="30737" class="Symbol">(</a><a id="30738" href="../Lists/#29784" class="InductiveConstructor">there</a> <a id="30744" class="Symbol">(</a><a id="30745" href="../Lists/#29727" class="InductiveConstructor">here</a> <a id="30750" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="30754" class="Symbol">))</a>
</pre>
<!--
Further, we can demonstrate that three is not in the list, because
any possible proof that it is in the list leads to contradiction:
-->
<p>除此之外，我们可以展示三不在列表之中，因为任何它在列表中的证明会推导出矛盾：</p>
<pre class="Agda"><a id="not-in"></a><a id="30949" href="../Lists/#30949" class="Function">not-in</a> <a id="30956" class="Symbol">:</a> <a id="30958" class="Number">3</a> <a id="30960" href="../Lists/#30253" class="Function Operator">∉</a> <a id="30962" href="../Lists/#3817" class="InductiveConstructor Operator">[</a> <a id="30964" class="Number">0</a> <a id="30966" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="30968" class="Number">1</a> <a id="30970" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="30972" class="Number">0</a> <a id="30974" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="30976" class="Number">2</a> <a id="30978" href="../Lists/#3817" class="InductiveConstructor Operator">]</a>
<a id="30980" href="../Lists/#30949" class="Function">not-in</a> <a id="30987" class="Symbol">(</a><a id="30988" href="../Lists/#29727" class="InductiveConstructor">here</a> <a id="30993" class="Symbol">())</a>
<a id="30997" href="../Lists/#30949" class="Function">not-in</a> <a id="31004" class="Symbol">(</a><a id="31005" href="../Lists/#29784" class="InductiveConstructor">there</a> <a id="31011" class="Symbol">(</a><a id="31012" href="../Lists/#29727" class="InductiveConstructor">here</a> <a id="31017" class="Symbol">()))</a>
<a id="31022" href="../Lists/#30949" class="Function">not-in</a> <a id="31029" class="Symbol">(</a><a id="31030" href="../Lists/#29784" class="InductiveConstructor">there</a> <a id="31036" class="Symbol">(</a><a id="31037" href="../Lists/#29784" class="InductiveConstructor">there</a> <a id="31043" class="Symbol">(</a><a id="31044" href="../Lists/#29727" class="InductiveConstructor">here</a> <a id="31049" class="Symbol">())))</a>
<a id="31055" href="../Lists/#30949" class="Function">not-in</a> <a id="31062" class="Symbol">(</a><a id="31063" href="../Lists/#29784" class="InductiveConstructor">there</a> <a id="31069" class="Symbol">(</a><a id="31070" href="../Lists/#29784" class="InductiveConstructor">there</a> <a id="31076" class="Symbol">(</a><a id="31077" href="../Lists/#29784" class="InductiveConstructor">there</a> <a id="31083" class="Symbol">(</a><a id="31084" href="../Lists/#29727" class="InductiveConstructor">here</a> <a id="31089" class="Symbol">()))))</a>
<a id="31096" href="../Lists/#30949" class="Function">not-in</a> <a id="31103" class="Symbol">(</a><a id="31104" href="../Lists/#29784" class="InductiveConstructor">there</a> <a id="31110" class="Symbol">(</a><a id="31111" href="../Lists/#29784" class="InductiveConstructor">there</a> <a id="31117" class="Symbol">(</a><a id="31118" href="../Lists/#29784" class="InductiveConstructor">there</a> <a id="31124" class="Symbol">(</a><a id="31125" href="../Lists/#29784" class="InductiveConstructor">there</a> <a id="31131" class="Symbol">()))))</a>
</pre>
<!--
The five occurrences of `()` attest to the fact that there is no
possible evidence for `3 ≡ 0`, `3 ≡ 1`, `3 ≡ 0`, `3 ≡ 2`, and
`3 ∈ []`, respectively.
-->
<p><code>()</code> 出现了五次，分别表示没有 <code>3 ≡ 0</code>、 <code>3 ≡ 1</code>、 <code>3 ≡ 0</code>、 <code>3 ≡ 2</code> 和 <code>3 ∈ []</code> 的证明。</p>
<!--
## All and append
-->
<h2 id="所有和附加">所有和附加</h2>
<!--
A predicate holds for every element of one list appended to another if and
only if it holds for every element of both lists:
-->
<p>一个谓词对两个附加在一起的列表的每个元素都成立，当且仅当这个谓词对两个列表的每个元素都成立：</p>
<pre class="Agda"><a id="All-++-⇔"></a><a id="31599" href="../Lists/#31599" class="Function">All-++-⇔</a> <a id="31608" class="Symbol">:</a> <a id="31610" class="Symbol">∀</a> <a id="31612" class="Symbol">{</a><a id="31613" href="../Lists/#31613" class="Bound">A</a> <a id="31615" class="Symbol">:</a> <a id="31617" class="PrimitiveType">Set</a><a id="31620" class="Symbol">}</a> <a id="31622" class="Symbol">{</a><a id="31623" href="../Lists/#31623" class="Bound">P</a> <a id="31625" class="Symbol">:</a> <a id="31627" href="../Lists/#31613" class="Bound">A</a> <a id="31629" class="Symbol">→</a> <a id="31631" class="PrimitiveType">Set</a><a id="31634" class="Symbol">}</a> <a id="31636" class="Symbol">(</a><a id="31637" href="../Lists/#31637" class="Bound">xs</a> <a id="31640" href="../Lists/#31640" class="Bound">ys</a> <a id="31643" class="Symbol">:</a> <a id="31645" href="../Lists/#1264" class="Datatype">List</a> <a id="31650" href="../Lists/#31613" class="Bound">A</a><a id="31651" class="Symbol">)</a> <a id="31653" class="Symbol">→</a>
  <a id="31657" href="../Lists/#27578" class="Datatype">All</a> <a id="31661" href="../Lists/#31623" class="Bound">P</a> <a id="31663" class="Symbol">(</a><a id="31664" href="../Lists/#31637" class="Bound">xs</a> <a id="31667" href="../Lists/#4535" class="Function Operator">++</a> <a id="31670" href="../Lists/#31640" class="Bound">ys</a><a id="31672" class="Symbol">)</a> <a id="31674" href="../Isomorphism/#14988" class="Record Operator">⇔</a> <a id="31676" class="Symbol">(</a><a id="31677" href="../Lists/#27578" class="Datatype">All</a> <a id="31681" href="../Lists/#31623" class="Bound">P</a> <a id="31683" href="../Lists/#31637" class="Bound">xs</a> <a id="31686" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="31688" href="../Lists/#27578" class="Datatype">All</a> <a id="31692" href="../Lists/#31623" class="Bound">P</a> <a id="31694" href="../Lists/#31640" class="Bound">ys</a><a id="31696" class="Symbol">)</a>
<a id="31698" href="../Lists/#31599" class="Function">All-++-⇔</a> <a id="31707" href="../Lists/#31707" class="Bound">xs</a> <a id="31710" href="../Lists/#31710" class="Bound">ys</a> <a id="31713" class="Symbol">=</a>
  <a id="31717" class="Keyword">record</a>
    <a id="31728" class="Symbol">{</a> <a id="31730" href="../Isomorphism/#15028" class="Field">to</a>       <a id="31739" class="Symbol">=</a>  <a id="31742" href="../Lists/#31797" class="Function">to</a> <a id="31745" href="../Lists/#31707" class="Bound">xs</a> <a id="31748" href="../Lists/#31710" class="Bound">ys</a>
    <a id="31755" class="Symbol">;</a> <a id="31757" href="../Isomorphism/#15045" class="Field">from</a>     <a id="31766" class="Symbol">=</a>  <a id="31769" href="../Lists/#32022" class="Function">from</a> <a id="31774" href="../Lists/#31707" class="Bound">xs</a> <a id="31777" href="../Lists/#31710" class="Bound">ys</a>
    <a id="31784" class="Symbol">}</a>
  <a id="31788" class="Keyword">where</a>

  <a id="31797" href="../Lists/#31797" class="Function">to</a> <a id="31800" class="Symbol">:</a> <a id="31802" class="Symbol">∀</a> <a id="31804" class="Symbol">{</a><a id="31805" href="../Lists/#31805" class="Bound">A</a> <a id="31807" class="Symbol">:</a> <a id="31809" class="PrimitiveType">Set</a><a id="31812" class="Symbol">}</a> <a id="31814" class="Symbol">{</a><a id="31815" href="../Lists/#31815" class="Bound">P</a> <a id="31817" class="Symbol">:</a> <a id="31819" href="../Lists/#31805" class="Bound">A</a> <a id="31821" class="Symbol">→</a> <a id="31823" class="PrimitiveType">Set</a><a id="31826" class="Symbol">}</a> <a id="31828" class="Symbol">(</a><a id="31829" href="../Lists/#31829" class="Bound">xs</a> <a id="31832" href="../Lists/#31832" class="Bound">ys</a> <a id="31835" class="Symbol">:</a> <a id="31837" href="../Lists/#1264" class="Datatype">List</a> <a id="31842" href="../Lists/#31805" class="Bound">A</a><a id="31843" class="Symbol">)</a> <a id="31845" class="Symbol">→</a>
    <a id="31851" href="../Lists/#27578" class="Datatype">All</a> <a id="31855" href="../Lists/#31815" class="Bound">P</a> <a id="31857" class="Symbol">(</a><a id="31858" href="../Lists/#31829" class="Bound">xs</a> <a id="31861" href="../Lists/#4535" class="Function Operator">++</a> <a id="31864" href="../Lists/#31832" class="Bound">ys</a><a id="31866" class="Symbol">)</a> <a id="31868" class="Symbol">→</a> <a id="31870" class="Symbol">(</a><a id="31871" href="../Lists/#27578" class="Datatype">All</a> <a id="31875" href="../Lists/#31815" class="Bound">P</a> <a id="31877" href="../Lists/#31829" class="Bound">xs</a> <a id="31880" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="31882" href="../Lists/#27578" class="Datatype">All</a> <a id="31886" href="../Lists/#31815" class="Bound">P</a> <a id="31888" href="../Lists/#31832" class="Bound">ys</a><a id="31890" class="Symbol">)</a>
  <a id="31894" href="../Lists/#31797" class="Function">to</a> <a id="31897" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="31900" href="../Lists/#31900" class="Bound">ys</a> <a id="31903" href="../Lists/#31903" class="Bound">Pys</a> <a id="31907" class="Symbol">=</a> <a id="31909" href="../Lists/#1036" class="InductiveConstructor Operator">⟨</a> <a id="31911" href="../Lists/#27629" class="InductiveConstructor">[]</a> <a id="31914" href="../Lists/#1036" class="InductiveConstructor Operator">,</a> <a id="31916" href="../Lists/#31903" class="Bound">Pys</a> <a id="31920" href="../Lists/#1036" class="InductiveConstructor Operator">⟩</a>
  <a id="31924" href="../Lists/#31797" class="Function">to</a> <a id="31927" class="Symbol">(</a><a id="31928" href="../Lists/#31928" class="Bound">x</a> <a id="31930" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="31932" href="../Lists/#31932" class="Bound">xs</a><a id="31934" class="Symbol">)</a> <a id="31936" href="../Lists/#31936" class="Bound">ys</a> <a id="31939" class="Symbol">(</a><a id="31940" href="../Lists/#31940" class="Bound">Px</a> <a id="31943" href="../Lists/#27646" class="InductiveConstructor Operator">∷</a> <a id="31945" href="../Lists/#31945" class="Bound">Pxs++ys</a><a id="31952" class="Symbol">)</a> <a id="31954" class="Keyword">with</a> <a id="31959" href="../Lists/#31797" class="Function">to</a> <a id="31962" href="../Lists/#31932" class="Bound">xs</a> <a id="31965" href="../Lists/#31936" class="Bound">ys</a> <a id="31968" href="../Lists/#31945" class="Bound">Pxs++ys</a>
  <a id="31978" class="Symbol">...</a> <a id="31982" class="Symbol">|</a> <a id="31984" href="../Lists/#1036" class="InductiveConstructor Operator">⟨</a> <a id="31986" href="../Lists/#31986" class="Bound">Pxs</a> <a id="31990" href="../Lists/#1036" class="InductiveConstructor Operator">,</a> <a id="31992" href="../Lists/#31992" class="Bound">Pys</a> <a id="31996" href="../Lists/#1036" class="InductiveConstructor Operator">⟩</a> <a id="31998" class="Symbol">=</a> <a id="32000" href="../Lists/#1036" class="InductiveConstructor Operator">⟨</a> <a id="32002" class="Bound">Px</a> <a id="32005" href="../Lists/#27646" class="InductiveConstructor Operator">∷</a> <a id="32007" href="../Lists/#31986" class="Bound">Pxs</a> <a id="32011" href="../Lists/#1036" class="InductiveConstructor Operator">,</a> <a id="32013" href="../Lists/#31992" class="Bound">Pys</a> <a id="32017" href="../Lists/#1036" class="InductiveConstructor Operator">⟩</a>

  <a id="32022" href="../Lists/#32022" class="Function">from</a> <a id="32027" class="Symbol">:</a> <a id="32029" class="Symbol">∀</a> <a id="32031" class="Symbol">{</a> <a id="32033" href="../Lists/#32033" class="Bound">A</a> <a id="32035" class="Symbol">:</a> <a id="32037" class="PrimitiveType">Set</a><a id="32040" class="Symbol">}</a> <a id="32042" class="Symbol">{</a><a id="32043" href="../Lists/#32043" class="Bound">P</a> <a id="32045" class="Symbol">:</a> <a id="32047" href="../Lists/#32033" class="Bound">A</a> <a id="32049" class="Symbol">→</a> <a id="32051" class="PrimitiveType">Set</a><a id="32054" class="Symbol">}</a> <a id="32056" class="Symbol">(</a><a id="32057" href="../Lists/#32057" class="Bound">xs</a> <a id="32060" href="../Lists/#32060" class="Bound">ys</a> <a id="32063" class="Symbol">:</a> <a id="32065" href="../Lists/#1264" class="Datatype">List</a> <a id="32070" href="../Lists/#32033" class="Bound">A</a><a id="32071" class="Symbol">)</a> <a id="32073" class="Symbol">→</a>
    <a id="32079" href="../Lists/#27578" class="Datatype">All</a> <a id="32083" href="../Lists/#32043" class="Bound">P</a> <a id="32085" href="../Lists/#32057" class="Bound">xs</a> <a id="32088" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="32090" href="../Lists/#27578" class="Datatype">All</a> <a id="32094" href="../Lists/#32043" class="Bound">P</a> <a id="32096" href="../Lists/#32060" class="Bound">ys</a> <a id="32099" class="Symbol">→</a> <a id="32101" href="../Lists/#27578" class="Datatype">All</a> <a id="32105" href="../Lists/#32043" class="Bound">P</a> <a id="32107" class="Symbol">(</a><a id="32108" href="../Lists/#32057" class="Bound">xs</a> <a id="32111" href="../Lists/#4535" class="Function Operator">++</a> <a id="32114" href="../Lists/#32060" class="Bound">ys</a><a id="32116" class="Symbol">)</a>
  <a id="32120" href="../Lists/#32022" class="Function">from</a> <a id="32125" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="32128" href="../Lists/#32128" class="Bound">ys</a> <a id="32131" href="../Lists/#1036" class="InductiveConstructor Operator">⟨</a> <a id="32133" href="../Lists/#27629" class="InductiveConstructor">[]</a> <a id="32136" href="../Lists/#1036" class="InductiveConstructor Operator">,</a> <a id="32138" href="../Lists/#32138" class="Bound">Pys</a> <a id="32142" href="../Lists/#1036" class="InductiveConstructor Operator">⟩</a> <a id="32144" class="Symbol">=</a> <a id="32146" href="../Lists/#32138" class="Bound">Pys</a>
  <a id="32152" href="../Lists/#32022" class="Function">from</a> <a id="32157" class="Symbol">(</a><a id="32158" href="../Lists/#32158" class="Bound">x</a> <a id="32160" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="32162" href="../Lists/#32162" class="Bound">xs</a><a id="32164" class="Symbol">)</a> <a id="32166" href="../Lists/#32166" class="Bound">ys</a> <a id="32169" href="../Lists/#1036" class="InductiveConstructor Operator">⟨</a> <a id="32171" href="../Lists/#32171" class="Bound">Px</a> <a id="32174" href="../Lists/#27646" class="InductiveConstructor Operator">∷</a> <a id="32176" href="../Lists/#32176" class="Bound">Pxs</a> <a id="32180" href="../Lists/#1036" class="InductiveConstructor Operator">,</a> <a id="32182" href="../Lists/#32182" class="Bound">Pys</a> <a id="32186" href="../Lists/#1036" class="InductiveConstructor Operator">⟩</a> <a id="32188" class="Symbol">=</a>  <a id="32191" href="../Lists/#32171" class="Bound">Px</a> <a id="32194" href="../Lists/#27646" class="InductiveConstructor Operator">∷</a> <a id="32196" href="../Lists/#32022" class="Function">from</a> <a id="32201" href="../Lists/#32162" class="Bound">xs</a> <a id="32204" href="../Lists/#32166" class="Bound">ys</a> <a id="32207" href="../Lists/#1036" class="InductiveConstructor Operator">⟨</a> <a id="32209" href="../Lists/#32176" class="Bound">Pxs</a> <a id="32213" href="../Lists/#1036" class="InductiveConstructor Operator">,</a> <a id="32215" href="../Lists/#32182" class="Bound">Pys</a> <a id="32219" href="../Lists/#1036" class="InductiveConstructor Operator">⟩</a>
</pre>
<!--
#### Exercise `Any-++-⇔` (recommended)
-->
<h4 id="练习-any---推荐">练习 <code>Any-++-⇔</code> （推荐）</h4>
<!--
Prove a result similar to `All-++-⇔`, but with `Any` in place of `All`, and a suitable
replacement for `_×_`.  As a consequence, demonstrate an equivalence relating
`_∈_` and `_++_`.
-->
<p>使用 <code>Any</code> 代替 <code>All</code> 与一个合适的 <code>_×_</code> 的替代，证明一个类似于 <code>All-++-⇔</code> 的结果。 作为结论，展示关联 <code>_∈_</code> 和 <code>_++_</code> 的一个等价关系。</p>
<!--
<pre class="Agda"><a id="32595" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="32631" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
#### Exercise `All-++-≃` (stretch)
-->
<h4 id="练习-all---延伸">练习 <code>All-++-≃</code> （延伸）</h4>
<!--
Show that the equivalence `All-++-⇔` can be extended to an isomorphism.
-->
<p>证明 <code>All-++-⇔</code> 的等价关系可以被扩展至一个同构关系。</p>
<!--
<pre class="Agda"><a id="32844" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="32880" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
#### Exercise `¬Any⇔All¬` (recommended)
-->
<h4 id="练习-anyall推荐">练习 <code>¬Any⇔All¬</code>（推荐）</h4>
<!--
Show that `Any` and `All` satisfy a version of De Morgan's Law:
-->
<p>请证明 <code>Any</code> 和 <code>All</code> 满足一个版本的德摩根定律：</p>
<pre><code>(¬_ ∘ Any P) xs ⇔ All (¬_ ∘ P) xs</code></pre>
<!--
(Can you see why it is important that here `_∘_` is generalised
to arbitrary levels, as described in the section on
[universe polymorphism](/Equality/#unipoly)?)
-->
<p>（你能明白为什么这里的 <code>_∘_</code> 被泛化到任意层级很重要吗？ 如<a href="../Equality/#unipoly">全体多态</a>一节所述。）</p>
<!--
Do we also have the following?
-->
<p>以下定律是否也成立？</p>
<pre><code>(¬_ ∘ All P) xs ⇔ Any (¬_ ∘ P) xs</code></pre>
<!--
If so, prove; if not, explain why.
-->
<p>若成立，请证明；否则请解释原因。</p>
<pre class="Agda"><a id="33518" class="Comment">-- Your code goes here</a>
</pre>
<!--
#### Exercise `¬Any≃All¬` (stretch)
-->
<h4 id="练习-anyall拓展">练习 <code>¬Any≃All¬</code>（拓展）</h4>
<!--
Show that the equivalence `¬Any⇔All¬` can be extended to an isomorphism.
You will need to use extensionality.
-->
<p>请证明等价的 <code>¬Any⇔All¬</code> 可以被扩展成一个同构。 你需要使用外延性。</p>
<!--
<pre class="Agda"><a id="33788" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="33824" class="Comment">-- 请将代码写在此处</a>
</pre>
<!--
#### Exercise `All-∀` (practice)
-->
<h4 id="练习-all-实践">练习 <code>All-∀</code>（实践）</h4>
<!--
Show that `All P xs` is isomorphic to `∀ x → x ∈ xs → P x`.
-->
<p>请证明 <code>All P xs</code> 同构于 <code>∀ x → x ∈ xs → P x</code>.</p>
<!--
<pre class="Agda"><a id="34026" class="Comment">-- You code goes here</a>
</pre>-->
<pre class="Agda"><a id="34061" class="Comment">-- 请将代码写在此处</a>
</pre>
<!--
#### Exercise `Any-∃` (practice)
-->
<h4 id="练习-any-实践">练习 <code>Any-∃</code>（实践）</h4>
<!--
Show that `Any P xs` is isomorphic to `∃[ x ] (x ∈ xs × P x)`.
-->
<p>请证明 <code>Any P xs</code> 同构于 <code>∃[ x ] (x ∈ xs × P x)</code>.</p>
<!--
<pre class="Agda"><a id="34270" class="Comment">-- You code goes here</a>
</pre>-->
<pre class="Agda"><a id="34305" class="Comment">-- 请将代码写在此处</a>
</pre>
<!--
If so, prove; if not, explain why.
-->
<p>如果成立，请证明；如果不成立，请解释原因。</p>
<!--
## Decidability of All
-->
<h2 id="所有的可判定性">所有的可判定性</h2>
<!--
If we consider a predicate as a function that yields a boolean,
it is easy to define an analogue of `All`, which returns true if
a given predicate returns true for every element of a list:
-->
<p>如果我们将一个谓词看作一个返回布尔值的函数，那么我们可以简单的定义一个类似于 <code>All</code> 的函数，其当给定谓词对于列表每个元素返回真时返回真：</p>
<pre class="Agda"><a id="all"></a><a id="34712" href="../Lists/#34712" class="Function">all</a> <a id="34716" class="Symbol">:</a> <a id="34718" class="Symbol">∀</a> <a id="34720" class="Symbol">{</a><a id="34721" href="../Lists/#34721" class="Bound">A</a> <a id="34723" class="Symbol">:</a> <a id="34725" class="PrimitiveType">Set</a><a id="34728" class="Symbol">}</a> <a id="34730" class="Symbol">→</a> <a id="34732" class="Symbol">(</a><a id="34733" href="../Lists/#34721" class="Bound">A</a> <a id="34735" class="Symbol">→</a> <a id="34737" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="34741" class="Symbol">)</a> <a id="34743" class="Symbol">→</a> <a id="34745" href="../Lists/#1264" class="Datatype">List</a> <a id="34750" href="../Lists/#34721" class="Bound">A</a> <a id="34752" class="Symbol">→</a> <a id="34754" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
<a id="34759" href="../Lists/#34712" class="Function">all</a> <a id="34763" href="../Lists/#34763" class="Bound">p</a>  <a id="34766" class="Symbol">=</a>  <a id="34769" href="../Lists/#19458" class="Function">foldr</a> <a id="34775" href="https://agda.github.io/agda-stdlib/v1.3/Data.Bool.Base.html#986" class="Function Operator">_∧_</a> <a id="34779" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="34784" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">∘</a> <a id="34786" href="../Lists/#16331" class="Function">map</a> <a id="34790" href="../Lists/#34763" class="Bound">p</a>
</pre>
<!--
The function can be written in a particularly compact style by
using the higher-order functions `map` and `foldr`.
-->
<p>我们可以使用高阶函数 <code>map</code> 和 <code>foldr</code> 来简洁地写出这个函数。</p>
<!--
As one would hope, if we replace booleans by decidables there is again
an analogue of `All`.  First, return to the notion of a predicate `P` as
a function of type `A → Set`, taking a value `x` of type `A` into evidence
`P x` that a property holds for `x`.  Say that a predicate `P` is _decidable_
if we have a function that for a given `x` can decide `P x`:
-->
<p>正如所希望的那样，如果我们将布尔值替换成可判定值，这与 <code>All</code> 是相似的。首先，回到将 <code>P</code> 当作一个类型为 <code>A → Set</code> 的函数的概念，将一个类型为 <code>A</code> 的值 <code>x</code> 转换成 <code>P x</code> 对 <code>x</code> 成立 的证明。我们成 <code>P</code> 为<strong>可判定的（Decidable）</strong>，如果我们有一个函数，其在给定 <code>x</code> 时能够判定 <code>P x</code>：</p>
<pre class="Agda"><a id="Decidable"></a><a id="35512" href="../Lists/#35512" class="Function">Decidable</a> <a id="35522" class="Symbol">:</a> <a id="35524" class="Symbol">∀</a> <a id="35526" class="Symbol">{</a><a id="35527" href="../Lists/#35527" class="Bound">A</a> <a id="35529" class="Symbol">:</a> <a id="35531" class="PrimitiveType">Set</a><a id="35534" class="Symbol">}</a> <a id="35536" class="Symbol">→</a> <a id="35538" class="Symbol">(</a><a id="35539" href="../Lists/#35527" class="Bound">A</a> <a id="35541" class="Symbol">→</a> <a id="35543" class="PrimitiveType">Set</a><a id="35546" class="Symbol">)</a> <a id="35548" class="Symbol">→</a> <a id="35550" class="PrimitiveType">Set</a>
<a id="35554" href="../Lists/#35512" class="Function">Decidable</a> <a id="35564" class="Symbol">{</a><a id="35565" href="../Lists/#35565" class="Bound">A</a><a id="35566" class="Symbol">}</a> <a id="35568" href="../Lists/#35568" class="Bound">P</a>  <a id="35571" class="Symbol">=</a>  <a id="35574" class="Symbol">∀</a> <a id="35576" class="Symbol">(</a><a id="35577" href="../Lists/#35577" class="Bound">x</a> <a id="35579" class="Symbol">:</a> <a id="35581" href="../Lists/#35565" class="Bound">A</a><a id="35582" class="Symbol">)</a> <a id="35584" class="Symbol">→</a> <a id="35586" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1508" class="Record">Dec</a> <a id="35590" class="Symbol">(</a><a id="35591" href="../Lists/#35568" class="Bound">P</a> <a id="35593" href="../Lists/#35577" class="Bound">x</a><a id="35594" class="Symbol">)</a>
</pre>
<!--
Then if predicate `P` is decidable, it is also decidable whether every
element of a list satisfies the predicate:
-->
那么当谓词 <code>P</code> 可判定时，我们亦可判定列表中的每一个元素是否满足这个谓词：
<pre class="Agda"><a id="All?"></a><a id="35769" href="../Lists/#35769" class="Function">All?</a> <a id="35774" class="Symbol">:</a> <a id="35776" class="Symbol">∀</a> <a id="35778" class="Symbol">{</a><a id="35779" href="../Lists/#35779" class="Bound">A</a> <a id="35781" class="Symbol">:</a> <a id="35783" class="PrimitiveType">Set</a><a id="35786" class="Symbol">}</a> <a id="35788" class="Symbol">{</a><a id="35789" href="../Lists/#35789" class="Bound">P</a> <a id="35791" class="Symbol">:</a> <a id="35793" href="../Lists/#35779" class="Bound">A</a> <a id="35795" class="Symbol">→</a> <a id="35797" class="PrimitiveType">Set</a><a id="35800" class="Symbol">}</a> <a id="35802" class="Symbol">→</a> <a id="35804" href="../Lists/#35512" class="Function">Decidable</a> <a id="35814" href="../Lists/#35789" class="Bound">P</a> <a id="35816" class="Symbol">→</a> <a id="35818" href="../Lists/#35512" class="Function">Decidable</a> <a id="35828" class="Symbol">(</a><a id="35829" href="../Lists/#27578" class="Datatype">All</a> <a id="35833" href="../Lists/#35789" class="Bound">P</a><a id="35834" class="Symbol">)</a>
<a id="35836" href="../Lists/#35769" class="Function">All?</a> <a id="35841" href="../Lists/#35841" class="Bound">P?</a> <a id="35844" href="../Lists/#1293" class="InductiveConstructor">[]</a>                                 <a id="35879" class="Symbol">=</a>  <a id="35882" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="35886" href="../Lists/#27629" class="InductiveConstructor">[]</a>
<a id="35889" href="../Lists/#35769" class="Function">All?</a> <a id="35894" href="../Lists/#35894" class="Bound">P?</a> <a id="35897" class="Symbol">(</a><a id="35898" href="../Lists/#35898" class="Bound">x</a> <a id="35900" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="35902" href="../Lists/#35902" class="Bound">xs</a><a id="35904" class="Symbol">)</a> <a id="35906" class="Keyword">with</a> <a id="35911" href="../Lists/#35894" class="Bound">P?</a> <a id="35914" href="../Lists/#35898" class="Bound">x</a>   <a id="35918" class="Symbol">|</a> <a id="35920" href="../Lists/#35769" class="Function">All?</a> <a id="35925" href="../Lists/#35894" class="Bound">P?</a> <a id="35928" href="../Lists/#35902" class="Bound">xs</a>
<a id="35931" class="Symbol">...</a>                 <a id="35951" class="Symbol">|</a> <a id="35953" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="35957" href="../Lists/#35957" class="Bound">Px</a> <a id="35960" class="Symbol">|</a> <a id="35962" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="35966" href="../Lists/#35966" class="Bound">Pxs</a>     <a id="35974" class="Symbol">=</a>  <a id="35977" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="35981" class="Symbol">(</a><a id="35982" href="../Lists/#35957" class="Bound">Px</a> <a id="35985" href="../Lists/#27646" class="InductiveConstructor Operator">∷</a> <a id="35987" href="../Lists/#35966" class="Bound">Pxs</a><a id="35990" class="Symbol">)</a>
<a id="35992" class="Symbol">...</a>                 <a id="36012" class="Symbol">|</a> <a id="36014" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="36017" href="../Lists/#36017" class="Bound">¬Px</a> <a id="36021" class="Symbol">|</a> <a id="36023" class="Symbol">_</a>           <a id="36035" class="Symbol">=</a>  <a id="36038" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="36041" class="Symbol">λ{</a> <a id="36044" class="Symbol">(</a><a id="36045" href="../Lists/#36045" class="Bound">Px</a> <a id="36048" href="../Lists/#27646" class="InductiveConstructor Operator">∷</a> <a id="36050" href="../Lists/#36050" class="Bound">Pxs</a><a id="36053" class="Symbol">)</a> <a id="36055" class="Symbol">→</a> <a id="36057" href="../Lists/#36017" class="Bound">¬Px</a> <a id="36061" href="../Lists/#36045" class="Bound">Px</a>   <a id="36066" class="Symbol">}</a>
<a id="36068" class="CatchallClause Symbol">...</a><a id="36071" class="CatchallClause">                 </a><a id="36088" class="CatchallClause Symbol">|</a><a id="36089" class="CatchallClause"> </a><a id="36090" class="CatchallClause Symbol">_</a><a id="36091" class="CatchallClause">      </a><a id="36097" class="CatchallClause Symbol">|</a><a id="36098" class="CatchallClause"> </a><a id="36099" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="CatchallClause InductiveConstructor">no</a><a id="36101" class="CatchallClause"> </a><a id="36102" href="../Lists/#36102" class="CatchallClause Bound">¬Pxs</a>     <a id="36111" class="Symbol">=</a>  <a id="36114" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="36117" class="Symbol">λ{</a> <a id="36120" class="Symbol">(</a><a id="36121" href="../Lists/#36121" class="Bound">Px</a> <a id="36124" href="../Lists/#27646" class="InductiveConstructor Operator">∷</a> <a id="36126" href="../Lists/#36126" class="Bound">Pxs</a><a id="36129" class="Symbol">)</a> <a id="36131" class="Symbol">→</a> <a id="36133" href="../Lists/#36102" class="Bound">¬Pxs</a> <a id="36138" href="../Lists/#36126" class="Bound">Pxs</a> <a id="36142" class="Symbol">}</a>
</pre>
<!--
If the list is empty, then trivially `P` holds for every element of
the list.  Otherwise, the structure of the proof is similar to that
showing that the conjunction of two decidable propositions is itself
decidable, using `_∷_` rather than `⟨_,_⟩` to combine the evidence for
the head and tail of the list.
-->
<p>如果列表为空，那么 <code>P</code> 显然对列表的每个元素成立。 否则，证明的结构与两个可判定的命题是可判定的证明相似，不过我们使用 <code>_∷_</code> 而不是 <code>⟨_,_⟩</code> 来整合头元素和尾列表的证明。</p>
<!--
#### Exercise `Any?` (stretch)
-->
<h4 id="练习-any扩展">练习 <code>Any?</code>（扩展）</h4>
<!--
Just as `All` has analogues `all` and `All?` which determine whether a
predicate holds for every element of a list, so does `Any` have
analogues `any` and `Any?` which determine whether a predicate holds
for some element of a list.  Give their definitions.
-->
<p>正如 <code>All</code> 有类似的 <code>all</code> 和 <code>All?</code> 形式，来判断列表的每个元素是否满足给定的谓词， 那么 <code>Any</code> 也有类似的 <code>any</code> 和 <code>Any?</code> 形式，来判断列表的一些元素是否满足给定的谓词。 给出它们的定义。</p>
<!--
<pre class="Agda"><a id="37016" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="37052" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
#### Exercise `split` (stretch)
-->
<h4 id="练习-split扩展">练习 <code>split</code>（扩展）</h4>
<!--
The relation `merge` holds when two lists merge to give a third list.
-->
<p>关系 <code>merge</code> 在两个列表合并的结果为给定的第三个列表时成立。</p>
<pre class="Agda"><a id="37253" class="Keyword">data</a> <a id="merge"></a><a id="37258" href="../Lists/#37258" class="Datatype">merge</a> <a id="37264" class="Symbol">{</a><a id="37265" href="../Lists/#37265" class="Bound">A</a> <a id="37267" class="Symbol">:</a> <a id="37269" class="PrimitiveType">Set</a><a id="37272" class="Symbol">}</a> <a id="37274" class="Symbol">:</a> <a id="37276" class="Symbol">(</a><a id="37277" href="../Lists/#37277" class="Bound">xs</a> <a id="37280" href="../Lists/#37280" class="Bound">ys</a> <a id="37283" href="../Lists/#37283" class="Bound">zs</a> <a id="37286" class="Symbol">:</a> <a id="37288" href="../Lists/#1264" class="Datatype">List</a> <a id="37293" href="../Lists/#37265" class="Bound">A</a><a id="37294" class="Symbol">)</a> <a id="37296" class="Symbol">→</a> <a id="37298" class="PrimitiveType">Set</a> <a id="37302" class="Keyword">where</a>

  <a id="merge.[]"></a><a id="37311" href="../Lists/#37311" class="InductiveConstructor">[]</a> <a id="37314" class="Symbol">:</a>
      <a id="37322" class="Comment">--------------</a>
      <a id="37343" href="../Lists/#37258" class="Datatype">merge</a> <a id="37349" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="37352" href="../Lists/#1293" class="InductiveConstructor">[]</a> <a id="37355" href="../Lists/#1293" class="InductiveConstructor">[]</a>

  <a id="merge.left-∷"></a><a id="37361" href="../Lists/#37361" class="InductiveConstructor">left-∷</a> <a id="37368" class="Symbol">:</a> <a id="37370" class="Symbol">∀</a> <a id="37372" class="Symbol">{</a><a id="37373" href="../Lists/#37373" class="Bound">x</a> <a id="37375" href="../Lists/#37375" class="Bound">xs</a> <a id="37378" href="../Lists/#37378" class="Bound">ys</a> <a id="37381" href="../Lists/#37381" class="Bound">zs</a><a id="37383" class="Symbol">}</a>
    <a id="37389" class="Symbol">→</a> <a id="37391" href="../Lists/#37258" class="Datatype">merge</a> <a id="37397" href="../Lists/#37375" class="Bound">xs</a> <a id="37400" href="../Lists/#37378" class="Bound">ys</a> <a id="37403" href="../Lists/#37381" class="Bound">zs</a>
      <a id="37412" class="Comment">--------------------------</a>
    <a id="37443" class="Symbol">→</a> <a id="37445" href="../Lists/#37258" class="Datatype">merge</a> <a id="37451" class="Symbol">(</a><a id="37452" href="../Lists/#37373" class="Bound">x</a> <a id="37454" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="37456" href="../Lists/#37375" class="Bound">xs</a><a id="37458" class="Symbol">)</a> <a id="37460" href="../Lists/#37378" class="Bound">ys</a> <a id="37463" class="Symbol">(</a><a id="37464" href="../Lists/#37373" class="Bound">x</a> <a id="37466" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="37468" href="../Lists/#37381" class="Bound">zs</a><a id="37470" class="Symbol">)</a>

  <a id="merge.right-∷"></a><a id="37475" href="../Lists/#37475" class="InductiveConstructor">right-∷</a> <a id="37483" class="Symbol">:</a> <a id="37485" class="Symbol">∀</a> <a id="37487" class="Symbol">{</a><a id="37488" href="../Lists/#37488" class="Bound">y</a> <a id="37490" href="../Lists/#37490" class="Bound">xs</a> <a id="37493" href="../Lists/#37493" class="Bound">ys</a> <a id="37496" href="../Lists/#37496" class="Bound">zs</a><a id="37498" class="Symbol">}</a>
    <a id="37504" class="Symbol">→</a> <a id="37506" href="../Lists/#37258" class="Datatype">merge</a> <a id="37512" href="../Lists/#37490" class="Bound">xs</a> <a id="37515" href="../Lists/#37493" class="Bound">ys</a> <a id="37518" href="../Lists/#37496" class="Bound">zs</a>
      <a id="37527" class="Comment">--------------------------</a>
    <a id="37558" class="Symbol">→</a> <a id="37560" href="../Lists/#37258" class="Datatype">merge</a> <a id="37566" href="../Lists/#37490" class="Bound">xs</a> <a id="37569" class="Symbol">(</a><a id="37570" href="../Lists/#37488" class="Bound">y</a> <a id="37572" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="37574" href="../Lists/#37493" class="Bound">ys</a><a id="37576" class="Symbol">)</a> <a id="37578" class="Symbol">(</a><a id="37579" href="../Lists/#37488" class="Bound">y</a> <a id="37581" href="../Lists/#1308" class="InductiveConstructor Operator">∷</a> <a id="37583" href="../Lists/#37496" class="Bound">zs</a><a id="37585" class="Symbol">)</a>
</pre>
<!--
For example,
-->
<p>例如</p>
<pre class="Agda"><a id="37623" href="../Lists/#37623" class="Function">_</a> <a id="37625" class="Symbol">:</a> <a id="37627" href="../Lists/#37258" class="Datatype">merge</a> <a id="37633" href="../Lists/#3747" class="InductiveConstructor Operator">[</a> <a id="37635" class="Number">1</a> <a id="37637" href="../Lists/#3747" class="InductiveConstructor Operator">,</a> <a id="37639" class="Number">4</a> <a id="37641" href="../Lists/#3747" class="InductiveConstructor Operator">]</a> <a id="37643" href="../Lists/#3747" class="InductiveConstructor Operator">[</a> <a id="37645" class="Number">2</a> <a id="37647" href="../Lists/#3747" class="InductiveConstructor Operator">,</a> <a id="37649" class="Number">3</a> <a id="37651" href="../Lists/#3747" class="InductiveConstructor Operator">]</a> <a id="37653" href="../Lists/#3817" class="InductiveConstructor Operator">[</a> <a id="37655" class="Number">1</a> <a id="37657" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="37659" class="Number">2</a> <a id="37661" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="37663" class="Number">3</a> <a id="37665" href="../Lists/#3817" class="InductiveConstructor Operator">,</a> <a id="37667" class="Number">4</a> <a id="37669" href="../Lists/#3817" class="InductiveConstructor Operator">]</a>
<a id="37671" class="Symbol">_</a> <a id="37673" class="Symbol">=</a> <a id="37675" href="../Lists/#37361" class="InductiveConstructor">left-∷</a> <a id="37682" class="Symbol">(</a><a id="37683" href="../Lists/#37475" class="InductiveConstructor">right-∷</a> <a id="37691" class="Symbol">(</a><a id="37692" href="../Lists/#37475" class="InductiveConstructor">right-∷</a> <a id="37700" class="Symbol">(</a><a id="37701" href="../Lists/#37361" class="InductiveConstructor">left-∷</a> <a id="37708" href="../Lists/#37311" class="InductiveConstructor">[]</a><a id="37710" class="Symbol">)))</a>
</pre>
<!--
Given a decidable predicate and a list, we can split the list
into two lists that merge to give the original list, where all
elements of one list satisfy the predicate, and all elements of
the other do not satisfy the predicate.
-->
<p>给定一个可判定谓词和一个列表，我们可以将该列表拆分成两个列表， 二者可以合并成原列表，其中一个列表的所有元素都满足该谓词， 而另一个列表中的所有元素都不满足该谓词。</p>
<!--
Define the following variant of the traditional `filter` function on
lists, which given a decidable predicate and a list returns a list of
elements that satisfy the predicate and a list of elements that don't,
with their corresponding proofs.
-->
<p>在列表上定义一个传统 <code>filter</code> 函数的变体，如下所示，它接受一个可判定谓词 和一个列表，返回一个所有元素都满足该谓词的列表，和一个所有元素都不满足的列表， 以及与它们相应的证明。</p>
<pre><code>split : ∀ {A : Set} {P : A → Set} (P? : Decidable P) (zs : List A)
  → ∃[ xs ] ∃[ ys ] ( merge xs ys zs × All P xs × All (¬_ ∘ P) ys )</code></pre>
<!--
<pre class="Agda"><a id="38543" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="38579" class="Comment">-- 请将代码写在此处</a>
</pre>
<!--
## Standard Library
-->
<h2 id="标准库">标准库</h2>
<!--
Definitions similar to those in this chapter can be found in the standard library:
-->
<p>标准库中可以找到与本章节中相似的定义：</p>
<pre class="Agda"><a id="38753" class="Keyword">import</a> <a id="38760" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.html" class="Module">Data.List</a> <a id="38770" class="Keyword">using</a> <a id="38776" class="Symbol">(</a><a id="38777" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.List.html#148" class="Datatype">List</a><a id="38781" class="Symbol">;</a> <a id="38783" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Base.html#1763" class="Function Operator">_++_</a><a id="38787" class="Symbol">;</a> <a id="38789" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Base.html#4297" class="Function">length</a><a id="38795" class="Symbol">;</a> <a id="38797" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Base.html#9161" class="Function">reverse</a><a id="38804" class="Symbol">;</a> <a id="38806" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Base.html#1497" class="Function">map</a><a id="38809" class="Symbol">;</a> <a id="38811" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Base.html#3625" class="Function">foldr</a><a id="38816" class="Symbol">;</a> <a id="38818" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Base.html#5703" class="Function">downFrom</a><a id="38826" class="Symbol">)</a>
<a id="38828" class="Keyword">import</a> <a id="38835" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="38864" class="Keyword">using</a> <a id="38870" class="Symbol">(</a><a id="38871" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.All.html#1274" class="Datatype">All</a><a id="38874" class="Symbol">;</a> <a id="38876" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.All.html#1337" class="InductiveConstructor">[]</a><a id="38878" class="Symbol">;</a> <a id="38880" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.All.html#1354" class="InductiveConstructor Operator">_∷_</a><a id="38883" class="Symbol">)</a>
<a id="38885" class="Keyword">import</a> <a id="38892" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="38921" class="Keyword">using</a> <a id="38927" class="Symbol">(</a><a id="38928" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.Any.html#1111" class="Datatype">Any</a><a id="38931" class="Symbol">;</a> <a id="38933" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.Any.html#1174" class="InductiveConstructor">here</a><a id="38937" class="Symbol">;</a> <a id="38939" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Relation.Unary.Any.html#1227" class="InductiveConstructor">there</a><a id="38944" class="Symbol">)</a>
<a id="38946" class="Keyword">import</a> <a id="38953" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="38988" class="Keyword">using</a> <a id="38994" class="Symbol">(</a><a id="38995" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Membership.Setoid.html#882" class="Function Operator">_∈_</a><a id="38998" class="Symbol">)</a>
<a id="39000" class="Keyword">import</a> <a id="39007" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Properties.html" class="Module">Data.List.Properties</a>
  <a id="39030" class="Keyword">using</a> <a id="39036" class="Symbol">(</a><a id="39037" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Properties.html#33246" class="Function">reverse-++-commute</a><a id="39055" class="Symbol">;</a> <a id="39057" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Properties.html#3709" class="Function">map-compose</a><a id="39068" class="Symbol">;</a> <a id="39070" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Properties.html#3026" class="Function">map-++-commute</a><a id="39084" class="Symbol">;</a> <a id="39086" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Properties.html#15963" class="Function">foldr-++</a><a id="39094" class="Symbol">)</a>
  <a id="39098" class="Keyword">renaming</a> <a id="39107" class="Symbol">(</a><a id="39108" href="https://agda.github.io/agda-stdlib/v1.3/Data.List.Properties.html#38952" class="Function">mapIsFold</a> <a id="39118" class="Symbol">to</a> <a id="mapIsFold"></a><a id="39121" href="../Lists/#39121" class="Function">map-is-foldr</a><a id="39133" class="Symbol">)</a>
<a id="39135" class="Keyword">import</a> <a id="39142" href="https://agda.github.io/agda-stdlib/v1.3/Algebra.Structures.html" class="Module">Algebra.Structures</a> <a id="39161" class="Keyword">using</a> <a id="39167" class="Symbol">(</a><a id="39168" href="https://agda.github.io/agda-stdlib/v1.3/Algebra.Structures.html#2523" class="Record">IsMonoid</a><a id="39176" class="Symbol">)</a>
<a id="39178" class="Keyword">import</a> <a id="39185" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Unary.html" class="Module">Relation.Unary</a> <a id="39200" class="Keyword">using</a> <a id="39206" class="Symbol">(</a><a id="39207" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Unary.html#3536" class="Function">Decidable</a><a id="39216" class="Symbol">)</a>
<a id="39218" class="Keyword">import</a> <a id="39225" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.html" class="Module">Relation.Binary</a> <a id="39241" class="Keyword">using</a> <a id="39247" class="Symbol">(</a><a id="39248" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.Definitions.html#4575" class="Function">Decidable</a><a id="39257" class="Symbol">)</a>
</pre>
<!--
The standard library version of `IsMonoid` differs from the
one given here, in that it is also parameterised on an equivalence relation.
-->
<p>标准库中的 <code>IsMonoid</code> 与给出的定义不同，因为它可以针对特定的等价关系参数化。</p>
<!--
Both `Relation.Unary` and `Relation.Binary` define a version of `Decidable`,
one for unary relations (as used in this chapter where `P` ranges over
unary predicates) and one for binary relations (as used earlier, where `_≤_`
ranges over a binary relation).
-->
<p><code>Relation.Unary</code> 和 <code>Relation.Binary</code> 都定义了 <code>Decidable</code> 的某个版本，一个 用于单元关系（正如本章中的单元谓词 <code>P</code>），一个用于二元关系（正如之前使用的 <code>_≤_</code>）。</p>
<h2 id="unicode">Unicode</h2>
<!--
This chapter uses the following unicode:
-->
<p>本章使用了下列 Unicode：</p>
<!--
    ∷  U+2237  PROPORTION  (\::)
    ⊗  U+2297  CIRCLED TIMES  (\otimes, \ox)
    ∈  U+2208  ELEMENT OF  (\in)
    ∉  U+2209  NOT AN ELEMENT OF  (\inn, \notin)
-->
<pre><code>∷  U+2237  比例  (\::)
⊗  U+2297  带圈的乘号  (\otimes, \ox)
∈  U+2208  元素属于  (\in)
∉  U+2209  元素不属于  (\inn, \notin)</code></pre>
    </div>
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Decidable/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Lists.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Lambda/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

</article>

            </div>
        </main>
        <footer class="site-footer h-card">
    <data class="u-url" href="../"></data>
    <div class="wrapper">
        <h2 class="footer-heading">编程语言基础：Agda 语言描述</h2>
        
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Philip Wadler</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wadler" title="wadler"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wadler</a></li>
    
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Wen Kokke</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wenkokke</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;wenkokke</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Jeremy G. Siek</li>
                    <li>
                        
                        <a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/jsiek" title="jsiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;jsiek</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;jeremysiek</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        
        This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
    </div>
</footer>

    </body>
</html>
