<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../public/css/style.css">
  
  <title>编程语言基础：Agda 语言描述 – Naturals</title>
  
  
  
</head>

    <body>
        <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="../">编程语言基础：Agda 语言描述</a>
        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="../">主页</a>
                <a class="page-link" href="../Announcements/">公告</a>
                <a class="page-link" href="../GettingStarted/">使用说明</a>
                <a class="page-link" href="../Citing/">引用</a>
                <a class="page-link" href="https://plfa.github.io/">English</a>
            </div>
        </nav>
    </div>
</header>

        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../GettingStarted/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Naturals.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Induction/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

    <header class="post-header">
        <h1 class="post-title" id="naturals">Naturals: 自然数</h1>
    </header>
    <div class="post-content">
        <pre class="Agda"><a id="181" class="Keyword">module</a> <a id="188" href="../Naturals/" class="Module">plfa.part1.Naturals</a> <a id="208" class="Keyword">where</a>
</pre>
<!--
The night sky holds more stars than I can count, though fewer than five
thousand are visible to the naked eye.  The observable universe
contains about seventy sextillion stars.
-->
<p>夜空中的星星不计其数，但只有不到五千颗是肉眼可见的。 可观测宇宙中则包含大约 7*10^22 颗恒星。</p>
<!--
But the number of stars is finite, while natural numbers are infinite.
Count all the stars, and you will still have as many natural numbers
left over as you started with.
-->
<p>星星虽多，但却是有限的，而自然数是无限的。就算用自然数把所有的星星都数尽了， 剩下的自然数也和开始的一样多。</p>
<!--
The naturals are an inductive datatype
-->
<h2 id="自然数是一种归纳数据类型inductive-datatype">自然数是一种归纳数据类型（Inductive Datatype）</h2>
<!--
Everyone is familiar with the natural numbers
-->
<p>大家都熟悉自然数，例如：</p>
<pre><code>0
1
2
3
...</code></pre>
<!--
and so on. We write `ℕ` for the *type* of natural numbers, and say that
`0`, `1`, `2`, `3`, and so on are *values* of type `ℕ`, indicated by
writing `0 : ℕ`, `1 : ℕ`, `2 : ℕ`, `3 : ℕ`, and so on.
-->
<p>等等。我们将自然数的<strong>类型（Type）</strong>记作 <code>ℕ</code> ，并称 <code>0</code>、<code>1</code>、<code>2</code>、<code>3</code> 等数 是类型 <code>ℕ</code> 的<strong>值（Value）</strong>，表示为 <code>0 : ℕ</code>，<code>1 : ℕ</code>，<code>2 : ℕ</code>，<code>3 : ℕ</code> 等等。</p>
<!--
The set of natural numbers is infinite, yet we can write down
its definition in just a few lines.  Here is the definition
as a pair of inference rules:
-->
<p>自然数集是无限的，然而其定义只需寥寥几行即可写出。下面是用两条 <strong>推导规则（Inference Rules）</strong>定义的自然数：</p>
<pre><code>--------
zero : ℕ

m : ℕ
---------
suc m : ℕ</code></pre>
<!--
And here is the definition in Agda:
-->
<p>以及用 Agda 定义的自然数：</p>
<pre class="Agda"><a id="1568" class="Keyword">data</a> <a id="ℕ"></a><a id="1573" href="../Naturals/#1573" class="Datatype">ℕ</a> <a id="1575" class="Symbol">:</a> <a id="1577" class="PrimitiveType">Set</a> <a id="1581" class="Keyword">where</a>
  <a id="ℕ.zero"></a><a id="1589" href="../Naturals/#1589" class="InductiveConstructor">zero</a> <a id="1594" class="Symbol">:</a> <a id="1596" href="../Naturals/#1573" class="Datatype">ℕ</a>
  <a id="ℕ.suc"></a><a id="1600" href="../Naturals/#1600" class="InductiveConstructor">suc</a>  <a id="1605" class="Symbol">:</a> <a id="1607" href="../Naturals/#1573" class="Datatype">ℕ</a> <a id="1609" class="Symbol">→</a> <a id="1611" href="../Naturals/#1573" class="Datatype">ℕ</a>
</pre>
<!--
Here `ℕ` is the name of the *datatype* we are defining,
and `zero` and `suc` (short for *successor*) are the
*constructors* of the datatype.
-->
<p>其中 <code>ℕ</code> 是我们定义的<strong>数据类型（Datatype）</strong>的名字，而 <code>zero</code>（零）和 <code>suc</code> （<strong>后继</strong>，即 <strong>Successor</strong> 的简写）是该数据类型的<strong>构造子（Constructor）</strong>。</p>
<!--
Both definitions above tell us the same two things:
-->
<p>这两种定义说的是同一件事：</p>
<!--
_Base case_: `zero` is a natural number.
_Inductive case_: if `m` is a natural number, then `suc m` is also a
  natural number.
-->
<ul>
<li><strong>起始步骤（Base Case）</strong>：<code>zero</code> 是一个自然数。</li>
<li><strong>归纳步骤（Inductive Case）</strong>：如果 <code>m</code> 是一个自然数，那么 <code>suc m</code> 也是。</li>
</ul>
<!--
Further, these two rules give the *only* ways of creating natural numbers.
Hence, the possible natural numbers are:
-->
<p>此外，这两条规则给出了产生自然数<strong>唯一</strong>的方法。因此，可能的自然数包括：</p>
<pre><code>zero
suc zero
suc (suc zero)
suc (suc (suc zero))
...</code></pre>
<!--
We write `0` as shorthand for `zero`; and `1` is shorthand
for `suc zero`, the successor of zero, that is, the natural that comes
after zero; and `2` is shorthand for `suc (suc zero)`, which is the
same as `suc 1`, the successor of one; and `3` is shorthand for the
successor of two; and so on.
-->
<p>我们将 <code>zero</code> 简写为 <code>0</code>；将 <code>suc zero</code>，零的后继数， 也就是排在零之后的自然数，简写为 <code>1</code>；将 <code>suc (suc zero)</code>，也就是 <code>suc 1</code>， 即一的后继数，简写为 <code>2</code>；将二的后继数简写为 <code>3</code>；以此类推。</p>
<!--
#### Exercise `seven` (practice) {name=seven}
-->
<h4 name="seven" id="练习-seven实践">练习 <code>seven</code>（实践）</h4>
<!--
Write out `7` in longhand.
-->
<p>请写出 <code>7</code> 的完整定义。</p>
<!--
<pre class="Agda"><a id="3016" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="3052" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
## Unpacking the inference rules
-->
<h2 id="推导规则分析">推导规则分析</h2>
<!--
Let's unpack the inference rules.  Each inference rule consists of
zero or more _judgments_ written above a horizontal line, called the
_hypotheses_, and a single judgment written below, called the
_conclusion_.  The first rule is the base case. It has no hypotheses,
and the conclusion asserts that `zero` is a natural.  The second rule
is the inductive case. It has one hypothesis, which assumes that `m`
is a natural, and the conclusion asserts that `suc m`
is also a natural.
-->
<p>我们来分析一下刚才的两条推导规则。每条推导规则包含写在一条水平直线上的 零条或多条<strong>判断（Judgment）</strong>，称之为<strong>假设（Hypothesis）</strong>；以及写在 直线下的一条判断，称之为<strong>结论（Conclusion）</strong>。第一条规则是起始步骤：它没 有任何假设，其结论断言 <code>zero</code> 是一个自然数。第二条规则是归纳步骤：它有 一条假设，即 <code>m</code> 是自然数，而结论断言 <code>suc m</code> 也是一个自然数。</p>
<!--
Unpacking the Agda definition
-->
<h2 id="agda-定义分析">Agda 定义分析</h2>
<!--
Let's unpack the Agda definition. The keyword `data` tells us this is an
inductive definition, that is, that we are defining a new datatype
with constructors.  The phrase
-->
<p>现在分析一下 Agda 的定义。关键字 <code>data</code> 表示这是一个归纳定义， 也就是用构造子定义一个新的数据类型。</p>
<pre><code>ℕ : Set</code></pre>
<!--
tells us that `ℕ` is the name of the new datatype, and that it is a
`Set`, which is the way in Agda of saying that it is a type.  The
keyword `where` separates the declaration of the datatype from the
declaration of its constructors. Each constructor is declared on a
separate line, which is indented to indicate that it belongs to the
corresponding `data` declaration.  The lines
-->
<p>表示 <code>ℕ</code> 是新的数据类型的名字，它是一个 <code>Set</code>，也就是在 Agda 中对类型的称呼。 关键字 <code>where</code> 用于分隔数据类型的声明和构造子的声明。 每个构造子的声明独占一行，用缩进来指明它所属的 <code>data</code> 声明。</p>
<pre><code>zero : ℕ
suc  : ℕ → ℕ</code></pre>
<!--
give _signatures_ specifying the types of the constructors `zero` and `suc`.
They tell us that `zero` is a natural number and that `suc` takes a natural
number as an argument and returns a natural number.
-->
<p>这两行给出了构造子 <code>zero</code> 和 <code>suc</code> 的类型<strong>签名（Signature）</strong>。 它们表示 <code>zero</code> 是一个自然数，<code>suc</code> 则取一个自然数作为参数，返回另一个自然数。</p>
<!--
You may have noticed that `ℕ` and `→` don't appear on your keyboard.
They are symbols in _unicode_.  At the end of each chapter is a list
of all unicode symbols introduced in the chapter, including
instructions on how to type them in the Emacs text editor.  Here
_type_ refers to typing with fingers as opposed to data types!
-->
<p>读者可能注意到 <code>ℕ</code> 和 <code>→</code> 在键盘上没有对应的按键。它们是 <strong>Unicode（统一码）</strong>中的符号。每一章的结尾都会有本章节引入的 Unicode 符号列表，以及在 Emacs 编辑器中输入它们的方法。</p>
<!--
The story of creation
-->
<h2 id="创世故事">创世故事</h2>
<!--
Let's look again at the rules that define the natural numbers:
-->
<p>我们再看一下自然数的定义规则：</p>
<!--
_Base case_: `zero` is a natural number.
_Inductive case_: if `m` is a natural number, then `suc m` is also a
  natural number.
-->
<ul>
<li><strong>起始步骤（Base Case）</strong>：<code>zero</code> 是一个自然数。</li>
<li><strong>归纳步骤（Inductive Case）</strong>：如果 <code>m</code> 是一个自然数，那么 <code>suc m</code> 也是。</li>
</ul>
<!--
Hold on! The second line defines natural numbers in terms of natural
numbers. How can that possibly be allowed?  Isn't this as useless a
definition as "Brexit means Brexit"?
-->
<p>等等！第二行用自然数定义了自然数，这怎么能行？这个定义难道 不会像「脱欧即是脱欧」一样无用吗？</p>
<p>【译注：「脱欧即是脱欧」是英国首相特蕾莎·梅提出的一句口号。】</p>
<!--
In fact, it is possible to assign our definition a meaning without
resorting to unpermitted circularities.  Furthermore, we can do so
while only working with _finite_ sets and never referring to the
_infinite_ set of natural numbers.
-->
<p>实际上，不必通过自我指涉，我们的自然数定义也是可以被赋予意义的。 我们甚至只需要处理<strong>有限</strong>的集合，而不必涉及<strong>无限</strong>的自然数集。</p>
<!--
We will think of it as a creation story.  To start with, we know about
no natural numbers at all:
-->
<p>我们可以将这个过程比作一个创世故事。起初，我们对自然数一无所知：</p>
<!--
    -- In the beginning, there are no natural numbers.
-->
<pre><code>-- 起初，世上没有自然数。</code></pre>
<!--
Now, we apply the rules to all the natural numbers we know about.  The
base case tells us that `zero` is a natural number, so we add it to the set
of known natural numbers.  The inductive case tells us that if `m` is a
natural number (on the day before today) then `suc m` is also a
natural number (today).  We didn't know about any natural numbers
before today, so the inductive case doesn't apply:
-->
<p>现在，我们对所有已知的自然数应用之前的规则。起始步骤告诉我们 <code>zero</code> 是 一个自然数，所以我们将它加入已知自然数的集合中。归纳步骤告诉我们如果 「昨天的」<code>m</code> 是一个自然数，那么「今天的」<code>suc m</code> 也是一个自然数。我们在 今天之前并不知道任何自然数，所以归纳步骤在此处不适用。</p>
<!--
    -- On the first day, there is one natural number.
    zero : ℕ
-->
<pre><code>-- 第一天，世上有了一个自然数。
zero : ℕ</code></pre>
<!--
Then we repeat the process. On the next day we know about all the
numbers from the day before, plus any numbers added by the rules.  The
base case tells us that `zero` is a natural number, but we already knew
that. But now the inductive case tells us that since `zero` was a natural
number yesterday, then `suc zero` is a natural number today:
-->
<p>然后我们重复此过程。今天我们知道昨天的所有自然数，以及任何 通过规则添加的数。起始步骤依然告诉我们 <code>zero</code> 是一个自然数，我们 已经知道这件事了。而如今归纳步骤告诉我们，由于 <code>zero</code> 在昨天是自然数， 那么 <code>suc zero</code> 在今天也是自然数：</p>
<!--
    -- On the second day, there are two natural numbers.
    zero : ℕ
    suc zero : ℕ
-->
<pre><code>-- 第二天，世上有了两个自然数。
zero : ℕ
suc zero : ℕ</code></pre>
<!--
And we repeat the process again. Now the inductive case
tells us that since `zero` and `suc zero` are both natural numbers, then
`suc zero` and `suc (suc zero)` are natural numbers. We already knew about
the first of these, but the second is new:
-->
<p>我们再次重复此过程。现在归纳步骤告诉我们，由于 <code>zero</code> 和 <code>suc zero</code> 都是自然 数，因此 <code>suc zero</code> 和 <code>suc (suc zero)</code> 也是自然数。我们已经知道 <code>suc zero</code> 是自然数了，而后者 <code>suc (suc zero)</code> 是新加入的。</p>
<!--
    -- On the third day, there are three natural numbers.
    zero : ℕ
    suc zero : ℕ
    suc (suc zero) : ℕ
-->
<pre><code>-- 第三天，世上有了三个自然数。
zero : ℕ
suc zero : ℕ
suc (suc zero) : ℕ</code></pre>
<!--
You've got the hang of it by now:
-->
<p>此时规律已经很明显了。</p>
<!--
    -- On the fourth day, there are four natural numbers.
    zero : ℕ
    suc zero : ℕ
    suc (suc zero) : ℕ
    suc (suc (suc zero)) : ℕ
-->
<pre><code>-- 第四天，世上有了四个自然数。
zero : ℕ
suc zero : ℕ
suc (suc zero) : ℕ
suc (suc (suc zero)) : ℕ</code></pre>
<!--
The process continues.  On the _n_'th day there will be _n_ distinct
natural numbers. Every natural number will appear on some given day.
In particular, the number _n_ first appears on day _n+1_. And we
never actually define the set of numbers in terms of itself. Instead,
we define the set of numbers on day _n+1_ in terms of the set of
numbers on day _n_.
-->
<p>此过程可以继续下去。在第 <em>n</em> 天会有 <em>n</em> 个不同的自然数。每个自然数都会在 某一天出现。具体来说，自然数 <em>n</em> 在第 <em>n+1</em> 天首次出现。至此，我们并没有使 用自然数集来定义其自身，而是根据第 <em>n</em> 天的数集定义了第 <em>n+1</em> 天的数集。</p>
<!--
A process like this one is called _inductive_. We start with nothing, and
build up a potentially infinite set by applying rules that convert one
finite set into another finite set.
-->
<p>像这样的过程被称作是<strong>归纳的（Inductive）</strong>。我们从一无所有开始，通过应用将 一个有限集合转换到另一个有限集合的规则，逐步生成潜在无限的集合。</p>
<!--
The rule defining zero is called a _base case_, because it introduces
a natural number even when we know no other natural numbers.  The rule
defining successor is called an _inductive case_, because it
introduces more natural numbers once we already know some.  Note the
crucial role of the base case.  If we only had inductive rules, then
we would have no numbers in the beginning, and still no numbers on the
second day, and on the third, and so on.  An inductive definition lacking
a base case is useless, as in the phrase "Brexit means Brexit".
-->
<p>定义了零的规则之所以被称作<strong>起始步骤</strong>，是因为它在我们还不知道其它自然数时 就引入了一个自然数。定义了后继数的规则之所以被称作<strong>归纳步骤</strong>，则是因为它在 已知自然数的基础上引入了更多自然数。其中，起始步骤的重要性不可小觑。如果 只有归纳步骤，那么第一天就没有任何自然数。第二天，第三天，无论多久也依旧没有。 一个没有起始步骤的归纳定义是无用的，就像「脱欧即是脱欧」一样。</p>
<!--
Philosophy and history
-->
<h2 id="哲学和历史">哲学和历史</h2>
<!--
A philosopher might observe that our reference to the first day,
second day, and so on, implicitly involves an understanding of natural
numbers.  In this sense, our definition might indeed be regarded as in
some sense circular, but we need not let this disturb us.
Everyone possesses a good informal understanding of the natural
numbers, which we may take as a foundation for their formal
description.
-->
<p>哲学家发现，我们对「第一天」「第二天」等说法的使用暗含了对自然数的理解。 在这个层面上，我们对自然数的定义也许某种程度上可以说是循环的，但我们不必为此烦恼。 每个人对自然数都有良好的非形式化的理解，而我们可以将它作为形式化描述自然数的基础。</p>
<!--
While the natural numbers have been understood for as long as people
can count, the inductive definition of the natural numbers is relatively
recent.  It can be traced back to Richard Dedekind's paper "_Was sind
und was sollen die Zahlen?_" (What are and what should be the
numbers?), published in 1888, and Giuseppe Peano's book "_Arithmetices
principia, nova methodo exposita_" (The principles of arithmetic
presented by a new method), published the following year.
-->
<p>尽管从人类开始计数起，自然数就被人所认知，然而其归纳定义却是近代的事情。 这可以追溯到理查德·戴德金（Richard Dedekind）于 1888 年发表的论文 <em>Was sind und was sollen die Zahlen?</em>“（《数是什么，应该是什么？》）， 以及朱塞佩·皮亚诺（Giuseppe Peano）于次年发表的著作”<em>Arithmetices principia, nova methodo exposita</em>"（《算术原理：用一种新方法呈现》）。</p>
<!--
A pragma
-->
<h2 id="编译指令">编译指令</h2>
<!--
In Agda, any text following `--` or enclosed between `{-`
and `-}` is considered a _comment_.  Comments have no effect on the
code, with the exception of one special kind of comment, called a
_pragma_, which is enclosed between `{-#` and `#-}`.
-->
<p>在 Agda 中，任何跟在 <code>--</code> 之后或者由 <code>{-</code> 和 <code>-}</code> 包裹的文字都会被视为 <strong>注释（Comment）</strong>。一般的注释对代码没有任何作用，但有一种例外， 这种注释被称作<strong>编译指令（Pragma）</strong>，由 <code>{-#</code> 和 <code>#-}</code> 包裹。</p>
<!--
Including the line
-->
<pre class="Agda"><a id="12070" class="Symbol">{-#</a> <a id="12074" class="Keyword">BUILTIN</a> <a id="12082" class="Keyword">NATURAL</a> <a id="12090" href="../Naturals/#1573" class="Datatype">ℕ</a> <a id="12092" class="Symbol">#-}</a>
</pre>
<!--
tells Agda that `ℕ` corresponds to the natural numbers, and hence one
is permitted to type `0` as shorthand for `zero`, `1` as shorthand for
`suc zero`, `2` as shorthand for `suc (suc zero)`, and so on. The pragma
must be given a previously declared type (in this case `ℕ`) with
precisely two constructors, one with no arguments (in this case `zero`),
and one with a single argument of the given type (in this case `suc`).
-->
<p>这一行告诉 Agda 数据类型 <code>ℕ</code> 对应了自然数，然后编写者就可以将 <code>zero</code> 简写 为 <code>0</code>，将 <code>suc zero</code> 简写为 <code>1</code>，将 <code>suc (suc zero)</code> 简写为 <code>2</code> 了，以此类推。 必须要向编译指令给出之前声明的类型（本例中为 <code>ℕ</code>），该类型有且只有两个构造子， 其中一个没有参数（本例中为 <code>zero</code>），另一个只接受一个所给定类型的参数（本例中为 <code>suc</code>）。</p>
<!--
As well as enabling the above shorthand, the pragma also enables a
more efficient internal representation of naturals using the Haskell
type for arbitrary-precision integers.  Representing the natural _n_
with `zero` and `suc` requires space proportional to _n_, whereas
representing it as an arbitrary-precision integer in Haskell only
requires space proportional to the logarithm of _n_.
-->
<p>在启用上述简写的同时，这条编译指令也会用 Haskell 的任意精度整数类型 来提供更高效的自然数内部表示。用 <code>zero</code> 和 <code>suc</code> 表示自然数 <em>n</em> 要占用正比 于 <em>n</em> 的空间，而将其表示为 Haskell 中的任意精度整数只会占用正比于 <em>n</em> 的对数的空间。</p>
<!--
Imports
-->
<h2 id="导入模块">导入模块</h2>
<!--
Shortly we will want to write some equations that hold between
terms involving natural numbers.  To support doing so, we import
the definition of equality and notations for reasoning
about it from the Agda standard library:
-->
<p>我们很快就能写一些包含自然数的等式了。在此之前，我们需要从 Agda 标准库 中导入<strong>相等性（Equality）</strong>的定义和用于等式推理的记法：</p>
<pre class="Agda"><a id="13619" class="Keyword">import</a> <a id="13626" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="13664" class="Symbol">as</a> <a id="13667" class="Module">Eq</a>
<a id="13670" class="Keyword">open</a> <a id="13675" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="13678" class="Keyword">using</a> <a id="13684" class="Symbol">(</a><a id="13685" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="13688" class="Symbol">;</a> <a id="13690" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="13694" class="Symbol">)</a>
<a id="13696" class="Keyword">open</a> <a id="13701" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2419" class="Module">Eq.≡-Reasoning</a> <a id="13716" class="Keyword">using</a> <a id="13722" class="Symbol">(</a><a id="13723" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin_</a><a id="13729" class="Symbol">;</a> <a id="13731" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">_≡⟨⟩_</a><a id="13736" class="Symbol">;</a> <a id="13738" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">_∎</a><a id="13740" class="Symbol">)</a>
</pre>
<!--
The first line brings the standard library module that defines
equality into scope and gives it the name `Eq`. The second line
opens that module, that is, adds all the names specified in the
`using` clause into the current scope. In this case the names added
are `_≡_`, the equality operator, and `refl`, the name for evidence
that two terms are equal.  The third line takes a module that
specifies operators to support reasoning about equivalence, and adds
all the names specified in the `using` clause into the current scope.
In this case, the names added are `begin_`, `_≡⟨⟩_`, and `_∎`.  We
will see how these are used below.  We take these as givens for now,
but will see how they are defined in
Chapter [Equality](/Equality/).
-->
<p>第一行代码将标准库中定义了相等性的模块导入到当前<strong>作用域（Scope）</strong>中， 并将其命名为 <code>Eq</code>。第二行打开了这个模块，也就是将所有在 <code>using</code> 从句中指定的名称添加到当前作用域中。此处添加的名称有相等性运算符 <code>_≡_</code> 和两个项相等的证据 <code>refl</code>。第三行选取的模块提供了用于等价关系推理的运算符，并将 <code>using</code> 从句中指定的名称添加到当前作用域。此处添加的名称有 <code>begin_</code>、 <code>_≡⟨⟩_</code> 和 <code>_∎</code>。我们后面会看到这些运算符的使用方法。现在暂且把它们当作现成的 工具来使用，不深究其细节。但我们会在<a href="../Equality/">相等性</a>一章中 学习它们的具体定义。</p>
<!--
Agda uses underbars to indicate where terms appear in infix or mixfix
operators. Thus, `_≡_` and `_≡⟨⟩_` are infix (each operator is written
between two terms), while `begin_` is prefix (it is written before a
term), and `_∎` is postfix (it is written after a term).
-->
<p>Agda 用下划线来标注<strong>项（Term）</strong>在中缀（Infix）或混缀（Mixfix）运算符中项出现的位置。 因此，<code>_≡_</code> 和 <code>_≡⟨⟩_</code> 是中缀的（运算符写在两个项之间），而 <code>begin_</code> 是前缀的 （运算符写在项之前），<code>_∎</code> 则是后缀的（运算符写在项之后）。</p>
<!--
Parentheses and semicolons are among the few characters that cannot
appear in names, so we do not need extra spaces in the `using` list.
-->
<p>括号和分号是少有的几个不能在名称中出现的的字符，于是我们在 <code>using</code> 列表中不需要额外的空格来消除歧义。</p>
<!--
## Operations on naturals are recursive functions {name=plus}
-->
<h2 name="plus" id="自然数的运算是递归函数">自然数的运算是递归函数</h2>
<!--
Now that we have the natural numbers, what can we do with them?
For instance, can we define arithmetic operations such as
addition and multiplication?
-->
<p>既然我们有了自然数，那么可以用它们做什么呢？比如，我们能定义 加法和乘法之类的算术运算吗？</p>
<!--
As a child I spent much time memorising tables of addition and
multiplication.  At first the rules seemed tricky and I would often
make mistakes.  It came as a shock to me to discover _recursion_,
a simple technique by which every one of the infinite possible
instances of addition and multiplication can be specified in
just a couple of lines.
-->
<p>我儿时曾花费了大量的时间来记忆加法表和乘法表。最开始，运算规则看起来很 复杂，我也经常犯错。在发现<strong>递归（Recursion）</strong>时，我如同醍醐灌顶。 有了这种简单的技巧，无数的加法和乘法运算只用几行就能概括。</p>
<!--
Here is the definition of addition in Agda:
-->
<p>这是用 Agda 编写的加法定义：</p>
<pre class="Agda"><a id="_+_"></a><a id="16265" href="../Naturals/#16265" class="Function Operator">_+_</a> <a id="16269" class="Symbol">:</a> <a id="16271" href="../Naturals/#1573" class="Datatype">ℕ</a> <a id="16273" class="Symbol">→</a> <a id="16275" href="../Naturals/#1573" class="Datatype">ℕ</a> <a id="16277" class="Symbol">→</a> <a id="16279" href="../Naturals/#1573" class="Datatype">ℕ</a>
<a id="16281" href="../Naturals/#1589" class="InductiveConstructor">zero</a> <a id="16286" href="../Naturals/#16265" class="Function Operator">+</a> <a id="16288" href="../Naturals/#16288" class="Bound">n</a> <a id="16290" class="Symbol">=</a> <a id="16292" href="../Naturals/#16288" class="Bound">n</a>
<a id="16294" class="Symbol">(</a><a id="16295" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="16299" href="../Naturals/#16299" class="Bound">m</a><a id="16300" class="Symbol">)</a> <a id="16302" href="../Naturals/#16265" class="Function Operator">+</a> <a id="16304" href="../Naturals/#16304" class="Bound">n</a> <a id="16306" class="Symbol">=</a> <a id="16308" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="16312" class="Symbol">(</a><a id="16313" href="../Naturals/#16299" class="Bound">m</a> <a id="16315" href="../Naturals/#16265" class="Function Operator">+</a> <a id="16317" href="../Naturals/#16304" class="Bound">n</a><a id="16318" class="Symbol">)</a>
</pre>
<!--
Let's unpack this definition.  Addition is an infix operator.  It is
written with underbars where the arguments go, hence its name is
`_+_`.  The first line is a signature specifying the type of the operator.
The type `ℕ → ℕ → ℕ`, indicates that addition accepts two naturals
and returns a natural.  Infix notation is just a shorthand for application;
the terms `m + n` and `_+_ m n` are equivalent.
-->
<p>我们来分析一下它的定义。加法是一种中缀运算符，其名为 <code>_+_</code>，其中参数的 位置用下划线表示。第一行指定了运算符的类型签名。类型 <code>ℕ → ℕ → ℕ</code> 表示 加法接受两个自然数作为参数，并返回一个自然数。中缀记法只是函数应用的简写， <code>m + n</code> 和 <code>_+_ m n</code> 这两个项是等价的。</p>
<!--
The definition has a base case and an inductive case, corresponding to
those for the natural numbers.  The base case says that adding zero to
a number, `zero + n`, returns that number, `n`.  The inductive case
says that adding the successor of a number to another number,
`(suc m) + n`, returns the successor of adding the two numbers, `suc (m + n)`.
We say we use _pattern matching_ when constructors appear on the
left-hand side of an equation.
-->
<p>它的定义包含一个起始步骤和一个归纳步骤，与自然数的定义对应。起始步骤说明 零加上一个数仍返回这个数，即 <code>zero + n</code> 等于 <code>n</code>。归纳步骤说明一个数的后继数 加上另一个数返回两数之和的后继数，即 <code>(suc m) + n</code> 等于 <code>suc (m + n)</code>。在加法的 定义中，构造子出现在了等式左边，我们称之为<strong>模式匹配（Pattern Matching）</strong>。</p>
<!--
If we write `zero` as `0` and `suc m` as `1 + m`, the definition turns
into two familiar equations:
-->
<p>如果我们将 <code>zero</code> 写作 <code>0</code>，将 <code>suc m</code> 写作 <code>1 + m</code>，上面的定义就变成了 两个熟悉的等式。</p>
<pre><code> 0       + n  ≡  n
 (1 + m) + n  ≡  1 + (m + n)</code></pre>
<!--
The first follows because zero is an identity for addition, and the
second because addition is associative.  In its most general form,
associativity is written
-->
<p>因为零是加法的幺元，所以第一个等式成立。又因为加法满足结合律，所以 第二个等式也成立。加法结合律的一般形式如下，说明运算结果与括号位置无关。</p>
<pre><code> (m + n) + p  ≡  m + (n + p)</code></pre>
<!--
meaning that the location of parentheses is irrelevant.  We get the
second equation from the third by taking `m` to be `1`, `n` to be `m`,
and `p` to be `n`.  We write `=` for definitions, while we
write `≡` for assertions that two already defined things are the same.
-->
<p>将上面第三个等式中的 <code>m</code> 换成 <code>1</code>，<code>n</code> 换成 <code>m</code>，<code>p</code> 换成 <code>n</code>，我们就 得到了第二个等式。我们用等号 <code>=</code> 表示定义，用 <code>≡</code> 断言两个已定义的事物相等。</p>
<!--
The definition is _recursive_, in that the last line defines addition
in terms of addition.  As with the inductive definition of the
naturals, the apparent circularity is not a problem.  It works because
addition of larger numbers is defined in terms of addition of smaller
numbers.  Such a definition is called _well founded_.
-->
<p>加法的定义是<strong>递归（Recursive）</strong>的，因为在最后一行我们用加法定义了加法。 与自然数的归纳定义类似，这种表面上的循环性并不会造成问题，因为较大 的数相加是用较小的数相加定义的。这样的定义被称作是<strong>良基的（Well founded）</strong>。</p>
<!--
For example, let's add two and three:
-->
<p>例如，我们来计算二加三：</p>
<pre class="Agda"><a id="18938" href="../Naturals/#18938" class="Function">_</a> <a id="18940" class="Symbol">:</a> <a id="18942" class="Number">2</a> <a id="18944" href="../Naturals/#16265" class="Function Operator">+</a> <a id="18946" class="Number">3</a> <a id="18948" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="18950" class="Number">5</a>
<a id="18952" class="Symbol">_</a> <a id="18954" class="Symbol">=</a>
  <a id="18958" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="18968" class="Number">2</a> <a id="18970" href="../Naturals/#16265" class="Function Operator">+</a> <a id="18972" class="Number">3</a>
  <a id="18976" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>    <a id="18983" class="Comment">-- 展开为</a>
    <a id="18994" class="Symbol">(</a><a id="18995" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="18999" class="Symbol">(</a><a id="19000" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19004" href="../Naturals/#1589" class="InductiveConstructor">zero</a><a id="19008" class="Symbol">))</a> <a id="19011" href="../Naturals/#16265" class="Function Operator">+</a> <a id="19013" class="Symbol">(</a><a id="19014" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19018" class="Symbol">(</a><a id="19019" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19023" class="Symbol">(</a><a id="19024" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19028" href="../Naturals/#1589" class="InductiveConstructor">zero</a><a id="19032" class="Symbol">)))</a>
  <a id="19038" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>    <a id="19045" class="Comment">-- 归纳步骤</a>
    <a id="19057" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19061" class="Symbol">((</a><a id="19063" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19067" href="../Naturals/#1589" class="InductiveConstructor">zero</a><a id="19071" class="Symbol">)</a> <a id="19073" href="../Naturals/#16265" class="Function Operator">+</a> <a id="19075" class="Symbol">(</a><a id="19076" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19080" class="Symbol">(</a><a id="19081" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19085" class="Symbol">(</a><a id="19086" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19090" href="../Naturals/#1589" class="InductiveConstructor">zero</a><a id="19094" class="Symbol">))))</a>
  <a id="19101" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>    <a id="19108" class="Comment">-- 归纳步骤</a>
    <a id="19120" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19124" class="Symbol">(</a><a id="19125" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19129" class="Symbol">(</a><a id="19130" href="../Naturals/#1589" class="InductiveConstructor">zero</a> <a id="19135" href="../Naturals/#16265" class="Function Operator">+</a> <a id="19137" class="Symbol">(</a><a id="19138" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19142" class="Symbol">(</a><a id="19143" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19147" class="Symbol">(</a><a id="19148" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19152" href="../Naturals/#1589" class="InductiveConstructor">zero</a><a id="19156" class="Symbol">)))))</a>
  <a id="19164" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>    <a id="19171" class="Comment">-- 起始步骤</a>
    <a id="19183" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19187" class="Symbol">(</a><a id="19188" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19192" class="Symbol">(</a><a id="19193" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19197" class="Symbol">(</a><a id="19198" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19202" class="Symbol">(</a><a id="19203" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19207" href="../Naturals/#1589" class="InductiveConstructor">zero</a><a id="19211" class="Symbol">))))</a>
  <a id="19218" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>    <a id="19225" class="Comment">-- 简写为</a>
    <a id="19236" class="Number">5</a>
  <a id="19240" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
We can write the same derivation more compactly by only
expanding shorthand as needed:
-->
<p>我们可以按需展开简写，把同样的推导过程写得更加紧凑。</p>
<pre class="Agda"><a id="19376" href="../Naturals/#19376" class="Function">_</a> <a id="19378" class="Symbol">:</a> <a id="19380" class="Number">2</a> <a id="19382" href="../Naturals/#16265" class="Function Operator">+</a> <a id="19384" class="Number">3</a> <a id="19386" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="19388" class="Number">5</a>
<a id="19390" class="Symbol">_</a> <a id="19392" class="Symbol">=</a>
  <a id="19396" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="19406" class="Number">2</a> <a id="19408" href="../Naturals/#16265" class="Function Operator">+</a> <a id="19410" class="Number">3</a>
  <a id="19414" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="19422" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19426" class="Symbol">(</a><a id="19427" class="Number">1</a> <a id="19429" href="../Naturals/#16265" class="Function Operator">+</a> <a id="19431" class="Number">3</a><a id="19432" class="Symbol">)</a>
  <a id="19436" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="19444" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19448" class="Symbol">(</a><a id="19449" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19453" class="Symbol">(</a><a id="19454" class="Number">0</a> <a id="19456" href="../Naturals/#16265" class="Function Operator">+</a> <a id="19458" class="Number">3</a><a id="19459" class="Symbol">))</a>
  <a id="19464" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="19472" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19476" class="Symbol">(</a><a id="19477" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="19481" class="Number">3</a><a id="19482" class="Symbol">)</a>
  <a id="19486" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="19494" class="Number">5</a>
  <a id="19498" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
The first line matches the inductive case by taking `m = 1` and `n = 3`,
the second line matches the inductive case by taking `m = 0` and `n = 3`,
and the third line matches the base case by taking `n = 3`.
-->
<p>第一行取 <code>m = 1</code> 和 <code>n = 3</code> 匹配了归纳步骤，第二行取 <code>m = 0</code> 和 <code>n = 3</code> 匹配了归纳步骤，第三行取 <code>n = 3</code> 匹配了起始步骤。</p>
<!--
Both derivations consist of a signature (written with a colon, `:`),
giving a type, and a binding (written with an equal sign, `=`),
giving a term of the given type.  Here we use the dummy name `_`.  The
dummy name can be reused, and is convenient for examples.  Names other
than `_` must be used only once in a module.
-->
<p>以上两个推导过程都由一个类型签名（包含冒号 <code>:</code> 的一行）和一个提供对应类型 的项的绑定（Binding）（包含等号 <code>=</code> 的一行及之后的部分）组成。在编写代码时 我们用了虚设名称 <code>_</code>。虚设名称可以被重复使用，在举例时非常方便。除了 <code>_</code> 之外 的名称在一个模块里只能被定义一次。</p>
<!--
Here the type is `2 + 3 ≡ 5` and the term provides _evidence_ for the
corresponding equation, here written in tabular form as a chain of
equations.  The chain starts with `begin` and finishes with `∎`
(pronounced "qed" or "tombstone", the latter from its appearance), and
consists of a series of terms separated by `≡⟨⟩`.
-->
<p>这里的类型是 <code>2 + 3 ≡ 5</code>，而该等式写成列表形式的等式链的项，提供了类型中表示 等式成立的<strong>证据（Evidence）</strong>。该等式链由 <code>begin</code> 开始，以 <code>∎</code> 结束（<code>∎</code> 可读作「qed（证毕）」或「tombstone（墓碑符号）」，后者来自于其外观）， 并由一系列 <code>≡⟨⟩</code> 分隔的项组成。</p>
<!--
In fact, both proofs are longer than need be, and Agda is satisfied
with the following:
-->
<p>其实，以上两种证明都比实际所需的要长，下面的证明就足以让 Agda 满意了。</p>
<pre class="Agda"><a id="20918" href="../Naturals/#20918" class="Function">_</a> <a id="20920" class="Symbol">:</a> <a id="20922" class="Number">2</a> <a id="20924" href="../Naturals/#16265" class="Function Operator">+</a> <a id="20926" class="Number">3</a> <a id="20928" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="20930" class="Number">5</a>
<a id="20932" class="Symbol">_</a> <a id="20934" class="Symbol">=</a> <a id="20936" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<!--
Agda knows how to compute the value of `2 + 3`, and so can immediately
check it is the same as `5`.  A binary relation is said to be _reflexive_
if every value relates to itself.  Evidence that a value is equal to
itself is written `refl`.
-->
<p>Agda 知道如何计算 <code>2 + 3</code> 的值，也可以立刻确定这个值和 <code>5</code> 是一样的。如果一个 二元关系（Binary Relation）中每个值都和自己相关，我们称这个二元关系满足 <strong>自反性（Reflexivity）</strong>。在 Agda 中，一个值等于其自身的证据写作 <code>refl</code>。</p>
<!--
In the chains of equations, all Agda checks is that each term
simplifies to the same value. If we jumble the equations, omit lines, or
add extraneous lines it will still be accepted.  It's up to us to write
the equations in an order that makes sense to the reader.
-->
<p>在等式链中，Agda 只检查每个项是否都能化简为相同的值。如果我们打乱等式顺序， 省略或者加入一些额外的步骤，证明仍然会被接受。我们需要自己来保证等式的顺序 便于理解。</p>
<!--
Here `2 + 3 ≡ 5` is a type, and the chains of equations (and also
`refl`) are terms of the given type; alternatively, one can think of
each term as _evidence_ for the assertion `2 + 3 ≡ 5`.  This duality
of interpretation---of a type as a proposition, and of a term as
evidence---is central to how we formalise concepts in Agda, and will
be a running theme throughout this book.
-->
<p>在这里，<code>2 + 3 ≡ 5</code> 是一个类型，等式链（以及 <code>refl</code>）都是这个类型的项。 换言之，我们也可以把每个项都看作断言 <code>2 + 3 ≡ 5</code> 的<strong>证据</strong>。这种解释的 对偶性——类型即命题，项即证据——是我们在 Agda 中形式化各种概念的核心， 也是贯穿本书的主题。</p>
<!--
Note that when we use the word _evidence_ it is nothing equivocal.  It
is not like testimony in a court which must be weighed to determine
whether the witness is trustworthy.  Rather, it is ironclad.  The
other word for evidence, which we will use interchangeably, is _proof_.
-->
<p>注意，当我们使用<strong>证据</strong>这个词时不容一点含糊。这里的证据确凿不移， 不像法庭上的证词一样必须被反复权衡以决定证人是否可信。 我们也会使用<strong>证明</strong>一词表达相同的意思，在本书中这两个词可以互换使用。</p>
<!--
#### Exercise `+-example` (practice) {name=plus-example}
-->
<h4 name="plus-example" id="练习--example实践">练习 <code>+-example</code>（实践）</h4>
<!--
Compute `3 + 4`, writing out your reasoning as a chain of equations, using the equations for `+`.
-->
<p>计算 <code>3 + 4</code>，将你的推导过程写成等式链，为 <code>+</code> 使用等式。</p>
<!--
<pre class="Agda"><a id="22891" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="22927" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
Multiplication
-->
<h2 id="乘法">乘法</h2>
<!--
Once we have defined addition, we can define multiplication
as repeated addition:
-->
<p>一旦我们定义了加法，我们就可以将乘法定义为重复的加法。</p>
<pre class="Agda"><a id="_*_"></a><a id="23102" href="../Naturals/#23102" class="Function Operator">_*_</a> <a id="23106" class="Symbol">:</a> <a id="23108" href="../Naturals/#1573" class="Datatype">ℕ</a> <a id="23110" class="Symbol">→</a> <a id="23112" href="../Naturals/#1573" class="Datatype">ℕ</a> <a id="23114" class="Symbol">→</a> <a id="23116" href="../Naturals/#1573" class="Datatype">ℕ</a>
<a id="23118" href="../Naturals/#1589" class="InductiveConstructor">zero</a>    <a id="23126" href="../Naturals/#23102" class="Function Operator">*</a> <a id="23128" href="../Naturals/#23128" class="Bound">n</a>  <a id="23131" class="Symbol">=</a>  <a id="23134" href="../Naturals/#1589" class="InductiveConstructor">zero</a>
<a id="23139" class="Symbol">(</a><a id="23140" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="23144" href="../Naturals/#23144" class="Bound">m</a><a id="23145" class="Symbol">)</a> <a id="23147" href="../Naturals/#23102" class="Function Operator">*</a> <a id="23149" href="../Naturals/#23149" class="Bound">n</a>  <a id="23152" class="Symbol">=</a>  <a id="23155" href="../Naturals/#23149" class="Bound">n</a> <a id="23157" href="../Naturals/#16265" class="Function Operator">+</a> <a id="23159" class="Symbol">(</a><a id="23160" href="../Naturals/#23144" class="Bound">m</a> <a id="23162" href="../Naturals/#23102" class="Function Operator">*</a> <a id="23164" href="../Naturals/#23149" class="Bound">n</a><a id="23165" class="Symbol">)</a>
</pre>
<!--
Computing `m * n` returns the sum of `m` copies of `n`.
-->
<p>计算 <code>m * n</code> 返回的结果是 <code>m</code> 个 <code>n</code> 之和。</p>
<!--
Again, rewriting turns the definition into two familiar equations:
-->
<p>重写定义再一次给出了两个熟悉的等式：</p>
<pre><code>0       * n  ≡  0
(1 + m) * n  ≡  n + (m * n)</code></pre>
<!--
The first follows because zero times anything is zero, and the second
follows because multiplication distributes over addition.
In its most general form, distribution of multiplication over addition
is written
-->
<p>因为零乘任何数都是零，所以第一个等式成立。因为乘法对加法有分配律，所以 第二个等式也成立。乘法对加法的分配律的一般形式如下：</p>
<pre><code>(m + n) * p  ≡  (m * p) + (n * p)</code></pre>
<!--
We get the second equation from the third by taking `m` to be `1`, `n`
to be `m`, and `p` to be `n`, and then using the fact that one is an
identity for multiplication, so `1 * n ≡ n`.
-->
<p>将上面第三个等式中的 <code>m</code> 换成 <code>1</code>，<code>n</code> 换成 <code>m</code>，<code>p</code> 换成 <code>n</code>，再根据 一是乘法的幺元，也就是 <code>1 * n ≡ n</code>，我们就得到了第二个等式。</p>
<!--
Again, the definition is well founded in that multiplication of
larger numbers is defined in terms of multiplication of smaller numbers.
-->
<p>这个定义也是良基的，因为较大的数相乘是用较小的数相乘定义的。</p>
<!--
For example, let's multiply two and three:
-->
<p>例如，我们来计算二乘三：</p>
<pre class="Agda"><a id="24277" href="../Naturals/#24277" class="Function">_</a> <a id="24279" class="Symbol">=</a>
  <a id="24283" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="24293" class="Number">2</a> <a id="24295" href="../Naturals/#23102" class="Function Operator">*</a> <a id="24297" class="Number">3</a>
  <a id="24301" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>    <a id="24308" class="Comment">-- 归纳步骤</a>
    <a id="24320" class="Number">3</a> <a id="24322" href="../Naturals/#16265" class="Function Operator">+</a> <a id="24324" class="Symbol">(</a><a id="24325" class="Number">1</a> <a id="24327" href="../Naturals/#23102" class="Function Operator">*</a> <a id="24329" class="Number">3</a><a id="24330" class="Symbol">)</a>
  <a id="24334" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>    <a id="24341" class="Comment">-- 归纳步骤</a>
    <a id="24353" class="Number">3</a> <a id="24355" href="../Naturals/#16265" class="Function Operator">+</a> <a id="24357" class="Symbol">(</a><a id="24358" class="Number">3</a> <a id="24360" href="../Naturals/#16265" class="Function Operator">+</a> <a id="24362" class="Symbol">(</a><a id="24363" class="Number">0</a> <a id="24365" href="../Naturals/#23102" class="Function Operator">*</a> <a id="24367" class="Number">3</a><a id="24368" class="Symbol">))</a>
  <a id="24373" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>    <a id="24380" class="Comment">-- 起始步骤</a>
    <a id="24392" class="Number">3</a> <a id="24394" href="../Naturals/#16265" class="Function Operator">+</a> <a id="24396" class="Symbol">(</a><a id="24397" class="Number">3</a> <a id="24399" href="../Naturals/#16265" class="Function Operator">+</a> <a id="24401" class="Number">0</a><a id="24402" class="Symbol">)</a>
  <a id="24406" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>    <a id="24413" class="Comment">-- 化简</a>
    <a id="24423" class="Number">6</a>
  <a id="24427" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
The first line matches the inductive case by taking `m = 1` and `n = 3`,
the second line matches the inductive case by taking `m = 0` and `n = 3`,
and the third line matches the base case by taking `n = 3`.
Here we have omitted the signature declaring `_ : 2 * 3 ≡ 6`, since
it can easily be inferred from the corresponding term.
-->
<p>第一行取 <code>m = 1</code> 和 <code>n = 3</code> 匹配了归纳步骤，第二行取 <code>m = 0</code> 和 <code>n = 3</code> 匹配了归纳步骤，最后第三行取 <code>n = 3</code> 匹配了起始步骤。在这里我们省略了 <code>_ : 2 * 3 ≡ 6</code> 的签名，因为它很容易从对应的项推导出来。</p>
<!--
#### Exercise `*-example` (practice) {name=times-example}
-->
<h4 name="times-example" id="练习--example实践-1">练习 <code>*-example</code>（实践）</h4>
<!--
Compute `3 * 4`, writing out your reasoning as a chain of equations, using the equations for `*`.
(You do not need to step through the evaluation of `+`.)
-->
<p>计算 <code>3 * 4</code>，将你的推导过程写成等式链，为 <code>*</code> 使用等式。 （不必写出 <code>+</code> 求值的每一步。）</p>
<!--
<pre class="Agda"><a id="25250" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="25286" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
#### Exercise `_^_` (recommended) {name=power}
-->
<h4 name="power" id="练习-__推荐">练习 <code>_^_</code>（推荐）</h4>
<!--
Define exponentiation, which is given by the following equations:
-->
<p>根据以下等式写出乘方的定义。</p>
<pre><code>m ^ 0        =  1
m ^ (1 + n)  =  m * (m ^ n)</code></pre>
<!--
Check that `3 ^ 4` is `81`.
-->
<p>检查 <code>3 ^ 4</code> 是否等于 <code>81</code>。</p>
<!--
<pre class="Agda"><a id="25610" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="25646" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
Monus
-->
<h2 id="饱和减法">饱和减法</h2>
<!--
We can also define subtraction.  Since there are no negative
natural numbers, if we subtract a larger number from a smaller
number we will take the result to be zero.  This adaption of
subtraction to naturals is called _monus_ (a twist on _minus_).
-->
<p>我们也可以定义减法。由于没有负的自然数，如果被减数比减数小， 我们就将结果取零。这种针对自然数的减法变种称作<strong>饱和减法（Monus，由 minus 修改而来）</strong>。</p>
<!--
Monus is our first use of a definition that uses pattern
matching against both arguments:
-->
<p>饱和减法是我们首次在定义中对两个参数都使用模式匹配：</p>
<pre class="Agda"><a id="_∸_"></a><a id="26165" href="../Naturals/#26165" class="Function Operator">_∸_</a> <a id="26169" class="Symbol">:</a> <a id="26171" href="../Naturals/#1573" class="Datatype">ℕ</a> <a id="26173" class="Symbol">→</a> <a id="26175" href="../Naturals/#1573" class="Datatype">ℕ</a> <a id="26177" class="Symbol">→</a> <a id="26179" href="../Naturals/#1573" class="Datatype">ℕ</a>
<a id="26181" href="../Naturals/#26181" class="Bound">m</a>     <a id="26187" href="../Naturals/#26165" class="Function Operator">∸</a> <a id="26189" href="../Naturals/#1589" class="InductiveConstructor">zero</a>   <a id="26196" class="Symbol">=</a>  <a id="26199" href="../Naturals/#26181" class="Bound">m</a>
<a id="26201" href="../Naturals/#1589" class="InductiveConstructor">zero</a>  <a id="26207" href="../Naturals/#26165" class="Function Operator">∸</a> <a id="26209" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="26213" href="../Naturals/#26213" class="Bound">n</a>  <a id="26216" class="Symbol">=</a>  <a id="26219" href="../Naturals/#1589" class="InductiveConstructor">zero</a>
<a id="26224" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="26228" href="../Naturals/#26228" class="Bound">m</a> <a id="26230" href="../Naturals/#26165" class="Function Operator">∸</a> <a id="26232" href="../Naturals/#1600" class="InductiveConstructor">suc</a> <a id="26236" href="../Naturals/#26236" class="Bound">n</a>  <a id="26239" class="Symbol">=</a>  <a id="26242" href="../Naturals/#26228" class="Bound">m</a> <a id="26244" href="../Naturals/#26165" class="Function Operator">∸</a> <a id="26246" href="../Naturals/#26236" class="Bound">n</a>
</pre>
<!--
We can do a simple analysis to show that all the cases are covered.
-->
<p>我们可以通过简单的分析来说明所有的情况都被考虑了。</p>
<!--
   Consider the second argument.
     If it is `zero`, then the first equation applies.
     If it is `suc n`, then consider the first argument.
       If it is `zero`, then the second equation applies.
       If it is `suc m`, then the third equation applies.
-->
<ul>
<li>考虑第二个参数。
<ul>
<li>如果它是 <code>zero</code>，应用第一个等式。</li>
<li>如果它是 <code>suc n</code>，考虑第一个参数。
<ul>
<li>如果它是 <code>zero</code>，应用第二个等式。</li>
<li>如果它是 <code>suc m</code>，应用第三个等式。</li>
</ul></li>
</ul></li>
</ul>
<!--
Again, the recursive definition is well founded because
monus on bigger numbers is defined in terms of monus on
smaller numbers.
-->
<p>此也是良基的，因为较大的数的饱和减法是用较小的数的饱和减法定义的。</p>
<!--
For example, let's subtract two from three:
-->
<p>例如，我们来计算三减二：</p>
<pre class="Agda"><a id="27003" href="../Naturals/#27003" class="Function">_</a> <a id="27005" class="Symbol">=</a>
  <a id="27009" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="27019" class="Number">3</a> <a id="27021" href="../Naturals/#26165" class="Function Operator">∸</a> <a id="27023" class="Number">2</a>
  <a id="27027" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="27035" class="Number">2</a> <a id="27037" href="../Naturals/#26165" class="Function Operator">∸</a> <a id="27039" class="Number">1</a>
  <a id="27043" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="27051" class="Number">1</a> <a id="27053" href="../Naturals/#26165" class="Function Operator">∸</a> <a id="27055" class="Number">0</a>
  <a id="27059" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="27067" class="Number">1</a>
  <a id="27071" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
We did not use the second equation at all, but it will be required
if we try to subtract a larger number from a smaller one:
-->
<p>我们没有使用第二个等式，但是如果被减数比减数小，我们还是会用到它。</p>
<pre class="Agda"><a id="27252" href="../Naturals/#27252" class="Function">_</a> <a id="27254" class="Symbol">=</a>
  <a id="27258" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2517" class="Function Operator">begin</a>
    <a id="27268" class="Number">2</a> <a id="27270" href="../Naturals/#26165" class="Function Operator">∸</a> <a id="27272" class="Number">3</a>
  <a id="27276" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="27284" class="Number">1</a> <a id="27286" href="../Naturals/#26165" class="Function Operator">∸</a> <a id="27288" class="Number">2</a>
  <a id="27292" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="27300" class="Number">0</a> <a id="27302" href="../Naturals/#26165" class="Function Operator">∸</a> <a id="27304" class="Number">1</a>
  <a id="27308" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2575" class="Function Operator">≡⟨⟩</a>
    <a id="27316" class="Number">0</a>
  <a id="27320" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#2816" class="Function Operator">∎</a>
</pre>
<!--
#### Exercise `∸-example₁` and `∸-example₂` (recommended) {name=monus-examples}
-->
<p>练习 <code>∸-example₁</code> 和 <code>∸-example₂</code>（推荐） {name=monus-examples}</p>
<!--
Compute `5 ∸ 3` and `3 ∸ 5`, writing out your reasoning as a chain of equations.
-->
<p>计算 <code>5 ∸ 3</code> 和 <code>3 ∸ 5</code>，将你的推导过程写成等式链。</p>
<!--
<pre class="Agda"><a id="27611" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="27647" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
Precedence
-->
<h2 id="优先级">优先级</h2>
<!--
We often use _precedence_ to avoid writing too many parentheses.
Application _binds more tightly than_ (or _has precedence over_) any
operator, and so we may write `suc m + n` to mean `(suc m) + n`.
As another example, we say that multiplication binds more tightly than
addition, and so write `n + m * n` to mean `n + (m * n)`.
We also sometimes say that addition _associates to the left_, and
so write `m + n + p` to mean `(m + n) + p`.
-->
<p>我们经常使用<strong>优先级（Precedence）</strong>来避免书写大量的括号。 函数应用比其它任何运算符都<strong>结合得更紧密</strong>（即<strong>有更高的优先级</strong>），所以我们 可以用 <code>suc m + n</code> 来表示 <code>(suc m) + n</code>。另一个例子是，我们说乘法比 加法结合得更紧密，所以可以用 <code>n + m * n</code> 来表示 <code>n + (m * n)</code>。我们有 时候也说加法是<strong>左结合的</strong>，所以可以用 <code>m + n + p</code> 来表示 <code>(m + n) + p</code>。</p>
<!--
In Agda the precedence and associativity of infix operators
needs to be declared:
-->
<p>在 Agda 中，中缀运算符的优先级和结合性需要被声明：</p>
<pre class="Agda"><a id="28499" class="Keyword">infixl</a> <a id="28506" class="Number">6</a>  <a id="28509" href="../Naturals/#16265" class="Primitive Operator">_+_</a>  <a id="28514" href="../Naturals/#26165" class="Primitive Operator">_∸_</a>
<a id="28518" class="Keyword">infixl</a> <a id="28525" class="Number">7</a>  <a id="28528" href="../Naturals/#23102" class="Primitive Operator">_*_</a>
</pre>
<!--
This states operators `_+_` and `_∸_` have precedence level 6,
and operator `_*_` has precedence level 7.
Addition and monus bind less tightly than multiplication
because they have lower precedence.
Writing `infixl` indicates that all three
operators associate to the left.  One can also write `infixr` to
indicate that an operator associates to the right, or just `infix` to
indicate that parentheses are always required to disambiguate.
-->
<p>它声明了运算符 <code>_+_</code> 和 <code>_∸_</code> 的优先级为 6，运算符 <code>_*_</code> 的优先级 为 7。因为加法和饱和减法的优先级更低，所以它们结合得不如乘法紧密。 <code>infixl</code> 意味着三个运算符都是左结合的。编写者也可以用 <code>infixr</code> 来表示 某个运算符是右结合的，或者用 <code>infix</code> 来表示总是需要括号来消除歧义。</p>
<!--
Currying
-->
<h2 id="柯里化">柯里化</h2>
<!--
We have chosen to represent a function of two arguments in terms
of a function of the first argument that returns a function of the
second argument.  This trick goes by the name _currying_.
-->
<p>我们曾将接受两个参数的函数表示成「接受第一个参数，返回接受第二个 参数的函数」的函数。这种技巧叫做<strong>柯里化（Currying）</strong>。</p>
<!--
Agda, like other functional languages such as Haskell and ML,
is designed to make currying easy to use.  Function
arrows associate to the right and application associates to the left
-->
<p>与 Haskell 和 ML 等函数式语言类似，Agda 在设计时就考虑了让柯里化更加易用。 函数箭头是右结合的，而函数应用是左结合的。</p>
<p>比如</p>
<!--
`ℕ → ℕ → ℕ` stands for `ℕ → (ℕ → ℕ)`

and

`_+_ 2 3` stands for `(_+_ 2) 3`.
-->
<p><code>ℕ → ℕ → ℕ</code> 表示 <code>ℕ → (ℕ → ℕ)</code></p>
<p>而</p>
<p><code>_+_ 2 3</code> 表示 <code>(_+_ 2) 3</code>。</p>
<!--
The term `_+_ 2` by itself stands for the function that adds two to
its argument, hence applying it to three yields five.
-->
<p><code>_+_ 2</code> 这个项表示一个「将参数加二」的函数，因此将它应用到三就得到了五。</p>
<!--
Currying is named for Haskell Curry, after whom the programming
language Haskell is also named.  Curry's work dates to the 1930's.
When I first learned about currying, I was told it was misattributed,
since the same idea was previously proposed by Moses Schönfinkel in
the 1920's.  I was told a joke: "It should be called schönfinkeling,
but currying is tastier". Only later did I learn that the explanation
of the misattribution was itself a misattribution.  The idea actually
appears in the _Begriffsschrift_ of Gottlob Frege, published in 1879.
-->
<p>柯里化是以哈斯凯尔·柯里（Haskell Curry）的名字命名的，编程语言 Haskell 也是。 柯里的工作可以追溯到 19 世纪 30 年代。当我第一次了解到柯里化时， 有人告诉我柯里化的命名是个归因错误，因为在 20 年代同样的想法就已经被 Moses Schönfinkel 提出了。我也听说过这样一个笑话：「（柯里化）本来该命名成 Schönfinkel 化的，但是咖喱（Curry）更好吃」。直到之后我才了解到， 这个归因错误的解释本身也是个归因错误。柯里化的概念早在戈特洛布·弗雷格 （Gottlob Frege）发表于 1879 年的 <strong>“Begriffsschrift”（《概念文字》）</strong>中就出现了。</p>
<!--
The story of creation, revisited
-->
<h2 id="又一个创世故事">又一个创世故事</h2>
<!--
Just as our inductive definition defines the naturals in terms of the
naturals, so does our recursive definition define addition in terms
of addition.
-->
<p>和归纳定义中用自然数定义了自然数一样，递归定义也用加法定义了加法。</p>
<!--
Again, it is possible to assign our definition a meaning without
resorting to unpermitted circularities.  We do so by reducing our
definition to equivalent inference rules for judgments about equality:
-->
<p>同理，无需利用循环性，我们的加法定义也是可以被赋予意义的。 为此，我们需要将加法的定义规约到用于判断相等性的等价的推导规则上来。</p>
<pre><code>n : ℕ
--------------
zero + n  =  n

m + n  =  p
---------------------
(suc m) + n  =  suc p</code></pre>
<!--
Here we assume we have already defined the infinite set of natural
numbers, specifying the meaning of the judgment `n : ℕ`.  The first
inference rule is the base case.  It asserts that if `n` is a natural number
then adding zero to it gives `n`.  The second inference rule is the inductive
case. It asserts that if adding `m` and `n` gives `p`, then adding `suc m` and
`n` gives `suc p`.
-->
<p>假设我们已经定义了自然数的无限集合，指定了判断 <code>n : ℕ</code> 的意义。 第一条推导规则是起始步骤。它断言如果 <code>n</code> 是一个自然数，那么零加上它得 <code>n</code>。 第二条推导规则是归纳步骤。它断言如果 <code>m</code> 加上 <code>n</code> 得 <code>p</code>，那么 <code>suc m</code> 加 上 <code>n</code> 得 <code>suc p</code>。</p>
<!--
Again we resort to a creation story, where this time we are
concerned with judgments about addition:
-->
<p>我们同样借创世故事来帮助理解，不过这次关注的是关于加法的判断。</p>
<!--
    -- In the beginning, we know nothing about addition.
-->
<pre><code>-- 起初，我们对加法一无所知。</code></pre>
<!--
Now, we apply the rules to all the judgment we know about.
The base case tells us that `zero + n = n` for every natural `n`,
so we add all those equations.  The inductive case tells us that if
`m + n = p` (on the day before today) then `suc m + n = suc p`
(today).  We didn't know any equations about addition before today,
so that rule doesn't give us any new equations:
-->
<p>现在对所有已知的判断应用之前的规则。起始步骤告诉我们，对于 每个自然数 <code>n</code> 都有 <code>zero + n = n</code>，因此我们添加所有的这类等式。 归纳步骤告诉我们，如果「昨天」有 <code>m + n = p</code>，那么「今天」 就有 <code>suc m + n = suc p</code>。在今天之前，我们不知道任何关于加法的等式， 因此这条规则不会给我们任何新的等式。</p>
<!--
    -- On the first day, we know about addition of 0.
    0 + 0 = 0     0 + 1 = 1    0 + 2 = 2     ...
-->
<pre><code>-- 第一天，我们知道了 0 为被加数的加法。
0 + 0 = 0     0 + 1 = 1    0 + 2 = 2     ...</code></pre>
<!--
Then we repeat the process, so on the next day we know about all the
equations from the day before, plus any equations added by the rules.
The base case tells us nothing new, but now the inductive case adds
more equations:
-->
<p>然后我们重复这个过程。今天我们知道来自昨天的所有等式，以及任何通过 规则添加的等式。起始步骤没有告诉我们任何新东西，但是归纳步骤添加了更多的等式。</p>
<!--
    -- On the second day, we know about addition of 0 and 1.
    0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
    1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...
-->
<pre><code>-- 第二天，我们知道了 0，1 为被加数的加法。
0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...</code></pre>
<!--
And we repeat the process again:
-->
<p>我们再次重复这个过程：</p>
<!--
    -- On the third day, we know about addition of 0, 1, and 2.
    0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
    1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...
    2 + 0 = 2     2 + 1 = 3     2 + 2 = 4     2 + 3 = 5     ...
-->
<pre><code>-- 第三天，我们知道了 0，1，2 为被加数的加法。
0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...
2 + 0 = 2     2 + 1 = 3     2 + 2 = 4     2 + 3 = 5     ...</code></pre>
<!--
You've got the hang of it by now:
-->
<p>此时规律已经很明显了：</p>
<!--
    -- On the fourth day, we know about addition of 0, 1, 2, and 3.
    0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
    1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...
    2 + 0 = 2     2 + 1 = 3     2 + 2 = 4     2 + 3 = 5     ...
    3 + 0 = 3     3 + 1 = 4     3 + 2 = 5     3 + 3 = 6     ...
-->
<pre><code>-- 第四天，我们知道了 0，1，2，3 为被加数的加法。
0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...
2 + 0 = 2     2 + 1 = 3     2 + 2 = 4     2 + 3 = 5     ...
3 + 0 = 3     3 + 1 = 4     3 + 2 = 5     3 + 3 = 6     ...</code></pre>
<!--
The process continues.  On the _m_'th day we will know all the
equations where the first number is less than _m_.
-->
<p>此过程可以继续下去。在第 <em>m</em> 天我们将知道所有被加数小于 <em>m</em> 的等式。</p>
<!--
As we can see, the reasoning that justifies inductive and recursive
definitions is quite similar.  They might be considered two sides of
the same coin.
-->
<p>如上所示，归纳定义和递归定义的的推导过程十分相似。它们就像一枚硬币的两面。</p>
<!--
## The story of creation, finitely {name=finite-creation}
-->
<h2 name="finite-creation" id="有限的创世故事">有限的创世故事</h2>
<!--
The above story was told in a stratified way.  First, we create
the infinite set of naturals.  We take that set as given when
creating instances of addition, so even on day one we have an
infinite set of instances.
-->
<p>前面的创世故事是用分层的方式讲述的。首先，我们创造了自然数的无限集合。 然后，我们构造加法的实例时把自然数集视为现成的，所以即使在第一天我 们也有一个无限的实例集合。</p>
<!--
Instead, we could choose to create both the naturals and the instances
of addition at the same time. Then on any day there would be only
a finite set of instances:
-->
<p>然而，我们也可以选择同时构造自然数集和加法的实例。这样在任何一天都只会有 一个有限的实例集合。</p>
<!--
    -- In the beginning, we know nothing.
-->
<pre><code>-- 起初，我们一无所知。</code></pre>
<!--
Now, we apply the rules to all the judgment we know about.  Only the
base case for naturals applies:
-->
<p>现在，对我们已知的所有判断应用之前的规则。只有自然数的起始步骤适用：</p>
<!--
    -- On the first day, we know zero.
    0 : ℕ
-->
<pre><code>-- 第一天，我们知道了零。
0 : ℕ</code></pre>
<!--
Again, we apply all the rules we know.  This gives us a new natural,
and our first equation about addition.
-->
<p>我们再次应用所有的规则。这次我们有了一个新自然数，和加法的第一个等式。</p>
<!--
    -- On the second day, we know one and all sums that yield zero.
    0 : ℕ
    1 : ℕ    0 + 0 = 0
-->
<pre><code>-- 第二天，我们知道了一和所有和为零的加法算式。
0 : ℕ
1 : ℕ    0 + 0 = 0</code></pre>
<!--
Then we repeat the process.  We get one more equation about addition
from the base case, and also get an equation from the inductive case,
applied to equation of the previous day:
-->
<p>然后我们重复这个过程。我们通过加法的起始步骤得到了一个等式，也通过在前一天 的等式上应用加法的归纳步骤得到了一个等式：</p>
<!--
    -- On the third day, we know two and all sums that yield one.
    0 : ℕ
    1 : ℕ    0 + 0 = 0
    2 : ℕ    0 + 1 = 1   1 + 0 = 1
-->
<pre><code>-- 第三天，我们知道了二和所有和为一的加法算式。
0 : ℕ
1 : ℕ    0 + 0 = 0
2 : ℕ    0 + 1 = 1   1 + 0 = 1</code></pre>
<!--
You've got the hang of it by now:
-->
<p>此时规律已经很明显了：</p>
<!--
    -- On the fourth day, we know three and all sums that yield two.
    0 : ℕ
    1 : ℕ    0 + 0 = 0
    2 : ℕ    0 + 1 = 1   1 + 0 = 1
    3 : ℕ    0 + 2 = 2   1 + 1 = 2    2 + 0 = 2
-->
<pre><code>-- 第四天，我们知道了三和所有和为二的加法算式。
0 : ℕ
1 : ℕ    0 + 0 = 0
2 : ℕ    0 + 1 = 1   1 + 0 = 1
3 : ℕ    0 + 2 = 2   1 + 1 = 2    2 + 0 = 2</code></pre>
<!--
On the _n_'th day there will be _n_ distinct natural numbers, and
_n × (n-1) / 2_ equations about addition.  The number _n_ and all equations
for addition of numbers less than _n_ first appear by day _n+1_.
This gives an entirely finitist view of infinite sets of data and
equations relating the data.
-->
<p>在第 <em>n</em> 天会有 <em>n</em> 个不同的自然数和 <em>n × (n-1) / 2</em> 个加法等式。 数字 <em>n</em> 和所有和小于 <em>n</em> 的加法等式在第 <em>n+1</em> 天首次出现。这提供了 一种无限的数据集合及与之相关的等式的有限主义视角。</p>
<!--
Writing definitions interactively
-->
<h2 id="交互式地编写定义">交互式地编写定义</h2>
<!--
Agda is designed to be used with the Emacs text editor, and the two
in combination provide features that help to create definitions
and proofs interactively.
-->
<p>Agda 被设计为使用 Emacs 作为文本编辑器，二者一同提供了很多能帮助 用户交互式地创建定义和证明的功能。</p>
<!--
Begin by typing:
-->
<p>我们从输入以下代码开始：</p>
<pre><code>_+_ : ℕ → ℕ → ℕ
m + n = ?</code></pre>
<!--
The question mark indicates that you would like Agda to help with
filling in that part of the code. If you type `C-c C-l` (pressing
the control key while hitting the `c` key followed by the `l` key),
which stands for **l**oad, the question mark will be
replaced:
-->
<p>问号表示你希望 Agda 帮助你填入这部分代码。如果按下组合键 <code>C-c C-l</code> （按住 Control 键的同时先按 <code>c</code> 键再按 <code>l</code> 键，<code>l</code> 键代表载入 <strong>l</strong>oad），这个问号会被替换：</p>
<pre><code>_+_ : ℕ → ℕ → ℕ
m + n = { }0</code></pre>
<!--
The empty braces are called a *hole*, and 0 is a number used for
referring to the hole.  The hole will display highlighted in green.
Emacs will also create a window displaying the text
-->
<p>这对花括号被称作一个<strong>洞（Hole）</strong>，0 是这个洞的编号。洞将会被高亮显示为 绿色（或蓝色）。同时，Emacs 会创建一个窗口显示如下文字：</p>
<pre><code>?0 : ℕ</code></pre>
<!--
to indicate that hole 0 is to be filled in with a term of type `ℕ`.
Typing `C-c C-f` (for **f**orward) will move you into the next hole.
-->
<p>这表示 0 号洞需要填入一个类型为 <code>ℕ</code> 的项。按组合键 <code>C-c C-f</code> （<code>f</code> 键代表向前 <strong>f</strong>orward）会移动到下一个洞。</p>
<!--
We wish to define addition by recursion on the first argument.
Move the cursor into the hole and type `C-c C-c` (for **c**ase).
You will be given the prompt:
-->
<p>我们希望在第一个参数上递归来定义加法。 将光标移至 0 号洞并按 <code>C-c C-c</code>（<code>c</code> 键代表分情况讨论 <strong>c</strong>ase），你将看见如下提示：</p>
<pre><code>pattern variables to case (empty for split on result):</code></pre>
<p>即「用于分项的模式变量（留空以对结果分项）：」。</p>
<!--
Typing `m` will cause a split on that variable, resulting
in an update to the code:
-->
<p>键入 <code>m</code> 会对名为 <code>m</code> 的变量分项（即自动模式匹配），并将代码更新为：</p>
<pre><code>_+_ : ℕ → ℕ → ℕ
zero + n = { }0
suc m + n = { }1</code></pre>
<!--
There are now two holes, and the window at the bottom tells you the
required type of each:
-->
<p>现在有两个洞了。底部的窗口会告诉你每个洞所需的类型：</p>
<pre><code>?0 : ℕ
?1 : ℕ</code></pre>
<!--
Going into hole 0 and typing `C-c C-,` will display information on the
required type of the hole, and what free variables are available:
-->
<p>移动至 0 号洞，按下 <code>C-c C-,</code> 会显示当前洞所需类型的具体信息，以及 可用的自由变量：</p>
<pre><code>Goal: ℕ
————————————————————————————————————————————————————————————
n : ℕ</code></pre>
<!--
This strongly suggests filling the hole with `n`.  After the hole is
filled, you can type `C-c C-space`, which will remove the hole:
-->
<p>这些信息强烈建议了用 <code>n</code> 填入该洞。填入内容后，你可以按下 <code>C-c C-空格</code> 来移除这个洞。</p>
<pre><code>_+_ : ℕ → ℕ → ℕ
zero + n = n
suc m + n = { }1</code></pre>
<!--
Again, going into hole 1 and typing `C-c C-,` will display information on the
required type of the hole, and what free variables are available:
-->
<p>同理，移动到 1 号洞并按下 <code>C-c C-,</code> 会显示当前洞所需类型的具体信息， 以及可用的自由变量：</p>
<pre><code>Goal: ℕ
————————————————————————————————————————————————————————————
n : ℕ
m : ℕ</code></pre>
<!--
Going into the hole and type `C-c C-r` (for **r**efine) will fill it in
with a constructor (if there is a unique choice) or tell you what constructors
you might use, if there is a choice.  In this case, it displays the following:
-->
<p>移动到一个洞并按下 <code>C-c C-r</code> （<code>r</code> 键表示细分 <strong>r</strong>efine）会将一个构造子填入这个洞（如果有唯一的选择的话）， 或者告诉你有哪些可用的构造子以供选择。在当前情况下，编辑器会显示如下内容：</p>
<pre><code>Don't know which constructor to introduce of zero or suc</code></pre>
<p>即“不知道在 <code>zero</code> 和 <code>suc</code> 中该引入哪一个构造子”。</p>
<!--
Filling the hole with `suc ?` and typing `C-c C-space` results in the following:
-->
<p>我们将 <code>suc ?</code> 填入并按下 <code>C-c C-空格</code>，它会将代码更新为：</p>
<pre><code>_+_ : ℕ → ℕ → ℕ
zero + n = n
suc m + n = suc { }1</code></pre>
<!--
Going into the new hole and typing `C-c C-,` gives similar information to before:
-->
<p>移动到新的洞并按下 <code>C-c C-,</code> 给出了和之前类似的信息：</p>
<pre><code>Goal: ℕ
————————————————————————————————————————————————————————————
n : ℕ
m : ℕ</code></pre>
<!--
We can fill the hole with `m + n` and type `C-c C-space` to complete the program:
-->
<p>我们可以用 <code>m + n</code> 填入该洞并按 <code>C-c C-空格</code> 来完成程序：</p>
<pre><code>_+_ : ℕ → ℕ → ℕ
zero + n = n
suc m + n = suc (m + n)</code></pre>
<!--
Exploiting interaction to this degree is probably not helpful for a program this
simple, but the same techniques can help with more complex programs.  Even for
a program this simple, using `C-c C-c` to split cases can be helpful.
-->
<p>在如此简单的程序上频繁使用交互操作可能帮助不大， 但是同样的技巧能够帮助你构建更复杂的程序。甚至对于加法定义这么简单的程序，使用 <code>C-c C-c</code> 来分项仍然是有用的。</p>
<!--
More pragmas
-->
<h2 id="更多编译指令">更多编译指令</h2>
<!--
Including the lines
-->
<pre class="Agda"><a id="42196" class="Symbol">{-#</a> <a id="42200" class="Keyword">BUILTIN</a> <a id="42208" class="Keyword">NATPLUS</a> <a id="42216" href="../Naturals/#16265" class="Primitive Operator">_+_</a> <a id="42220" class="Symbol">#-}</a>
<a id="42224" class="Symbol">{-#</a> <a id="42228" class="Keyword">BUILTIN</a> <a id="42236" class="Keyword">NATTIMES</a> <a id="42245" href="../Naturals/#23102" class="Primitive Operator">_*_</a> <a id="42249" class="Symbol">#-}</a>
<a id="42253" class="Symbol">{-#</a> <a id="42257" class="Keyword">BUILTIN</a> <a id="42265" class="Keyword">NATMINUS</a> <a id="42274" href="../Naturals/#26165" class="Primitive Operator">_∸_</a> <a id="42278" class="Symbol">#-}</a>
</pre>
<!--
tells Agda that these three operators correspond to the usual ones,
and enables it to perform these computations using the corresponding
Haskell operators on the arbitrary-precision integer type.
Representing naturals with `zero` and `suc` requires time proportional
to _m_ to add _m_ and _n_, whereas representing naturals as integers
in Haskell requires time proportional to the larger of the logarithms
of _m_ and _n_.  Similarly, representing naturals with `zero`
and `suc` requires time proportional to the product of _m_ and _n_ to
multiply _m_ and _n_, whereas representing naturals as integers in
Haskell requires time proportional to the sum of the logarithms of
_m_ and _n_.
-->
<p>以上几行告诉 Agda 这几个运算符和数学中常用的运算符相对应， 以便让它在计算时使用相应的，可处理任意精度整数类型的 Haskell 运算符。 计算 <code>m</code> 加 <code>n</code> 时，用 <code>zero</code> 和 <code>suc</code> 表示的自然数需要正比于 <code>m</code> 的时间， 而用 Haskell 整数表示的情况下只需要正比于 <code>m</code> 和 <code>n</code> 中较大者的对数的时间。 类似地，计算 <code>m</code> 乘 <code>n</code> 时，用 <code>zero</code> 和 <code>suc</code> 表示的自然数需要正比于 <code>m</code> 乘 <code>n</code> 的 时间，而用 Haskell 整数表示的情况下只需要正比于 <code>m</code> 和 <code>n</code> 的对数之和的时间。</p>
<!--
#### Exercise `Bin` (stretch) {name=Bin}
-->
<h4 name="Bin" id="练习-bin拓展">练习 <code>Bin</code>（拓展）</h4>
<!--
A more efficient representation of natural numbers uses a binary
rather than a unary system.  We represent a number as a bitstring:
-->
<p>使用二进制系统能提供比一进制系统更高效的自然数表示。我们可以用一个比特串来表示一个数：</p>
<pre class="Agda"><a id="43538" class="Keyword">data</a> <a id="Bin"></a><a id="43543" href="../Naturals/#43543" class="Datatype">Bin</a> <a id="43547" class="Symbol">:</a> <a id="43549" class="PrimitiveType">Set</a> <a id="43553" class="Keyword">where</a>
  <a id="Bin.⟨⟩"></a><a id="43561" href="../Naturals/#43561" class="InductiveConstructor">⟨⟩</a> <a id="43564" class="Symbol">:</a> <a id="43566" href="../Naturals/#43543" class="Datatype">Bin</a>
  <a id="Bin._O"></a><a id="43572" href="../Naturals/#43572" class="InductiveConstructor Operator">_O</a> <a id="43575" class="Symbol">:</a> <a id="43577" href="../Naturals/#43543" class="Datatype">Bin</a> <a id="43581" class="Symbol">→</a> <a id="43583" href="../Naturals/#43543" class="Datatype">Bin</a>
  <a id="Bin._I"></a><a id="43589" href="../Naturals/#43589" class="InductiveConstructor Operator">_I</a> <a id="43592" class="Symbol">:</a> <a id="43594" href="../Naturals/#43543" class="Datatype">Bin</a> <a id="43598" class="Symbol">→</a> <a id="43600" href="../Naturals/#43543" class="Datatype">Bin</a>
</pre>
<!--
For instance, the bitstring
-->
<p>例如，以下比特串</p>
<pre><code>1011</code></pre>
<!--
standing for the number eleven is encoded as
-->
<p>代表数字十一被编码为了</p>
<pre><code>⟨⟩ I O I I</code></pre>
<!--
Representations are not unique due to leading zeros.
Hence, eleven is also represented by `001011`, encoded as:
-->
<p>由于前导零的存在，表示并不是唯一的。因此，十一同样可以 表示成 <code>001011</code>，编码为：</p>
<pre><code>⟨⟩ O O I O I I</code></pre>
<!--
Define a function
-->
<p>定义这样一个函数</p>
<pre><code>inc : Bin → Bin</code></pre>
<!--
that converts a bitstring to the bitstring for the next higher
number.  For example, since `1100` encodes twelve, we should have:
-->
<p>将一个比特串转换成下一个数的比特串。比如，<code>1100</code> 编码了十二，我们就应该有：</p>
<pre><code>inc (⟨⟩ I O I I) ≡ ⟨⟩ I I O O</code></pre>
<!--
Confirm that this gives the correct answer for the bitstrings
encoding zero through four.
-->
<p>实现这个函数，并验证它对于表示零到四的比特串都能给出正确结果。</p>
<!--
Using the above, define a pair of functions to convert
between the two representations.
-->
<p>使用以上的定义，再定义一对函数用于在两种表示间转换。</p>
<pre><code>to   : ℕ → Bin
from : Bin → ℕ</code></pre>
<!--
For the former, choose the bitstring to have no leading zeros if it
represents a positive natural, and represent zero by `⟨⟩ O`.
Confirm that these both give the correct answer for zero through four.
-->
<p>对于前者，用没有前导零的比特串来表示正数，并用 <code>⟨⟩ O</code> 表示零。 验证这两个函数都能对零到四给出正确结果。</p>
<!--
<pre class="Agda"><a id="44792" class="Comment">-- Your code goes here</a>
</pre>-->
<pre class="Agda"><a id="44828" class="Comment">-- 请将代码写在此处。</a>
</pre>
<!--
Standard library
-->
<h2 id="标准库">标准库</h2>
<!--
At the end of each chapter, we will show where to find relevant
definitions in the standard library.  The naturals, constructors for
them, and basic operators upon them, are defined in the standard
library module `Data.Nat`:
-->
<p>在每一章的结尾，我们将展示如何在标准库中找到相关的定义。 自然数，它们的构造子，以及用于自然数的基本运算符，都在标准库模块 <code>Data.Nat</code> 中定义：</p>
<pre class="Agda"><a id="45199" class="Comment">-- import Data.Nat using (ℕ; zero; suc; _+_; _*_; _^_; _∸_)</a>
</pre>
<!--
Normally, we will show an import as running code, so Agda will
complain if we attempt to import a definition that is not available.
This time, however, we have only shown the import as a comment.  Both
this chapter and the standard library invoke the `NATURAL` pragma, the
former on `ℕ`, and the latter on the equivalent type `Data.Nat.ℕ`.
Such a pragma can only be invoked once, as invoking it twice would
raise confusion as to whether `2` is a value of type `ℕ` or type
`Data.Nat.ℕ`.  Similar confusions arise if other pragmas are invoked
twice. For this reason, we will usually avoid pragmas in future chapters.
Information on pragmas can be found in the (Agda documentation)[https://agda.readthedocs.io/en/v2.6.1/language/pragmas.html].
-->
<p>正常情况下，我们会以运行代码的形式展示一个导入语句， 这样如果我们尝试导入一个不可用的定义，Agda 就会报错。 不过现在，我们只在注释里展示了这个导入语句。这一章和标准库 都调用了 <code>NATURAL</code> 编译指令。我们是在 <code>ℕ</code> 上使用，而标准库是在 等价的类型 <code>Data.Nat.ℕ</code> 上使用。这样的编译指令只能被调用一次，因为 重复调用会导致 <code>2</code> 到底是类型 <code>ℕ</code> 的值还是类型 <code>Data.Nat.ℕ</code> 的 值这样的困惑。重复调用其它的编译指令也会导致同样的问题。基于这个原因， 我们在后续章节中通常会避免使用编译指令。更多关于编译指令的信息可在 <a href="https://agda-zh.readthedocs.io/zh_CN/latest/language/pragmas.html">Agda 文档</a>中找到。</p>
<!--
Unicode
-->
<h2 id="unicode">Unicode</h2>
<!--
This chapter uses the following unicode:

    ℕ  U+2115  DOUBLE-STRUCK CAPITAL N (\bN)
    →  U+2192  RIGHTWARDS ARROW (\to, \r, \->)
    ∸  U+2238  DOT MINUS (\.-)
    ≡  U+2261  IDENTICAL TO (\==)
    ⟨  U+27E8  MATHEMATICAL LEFT ANGLE BRACKET (\<)
    ⟩  U+27E9  MATHEMATICAL RIGHT ANGLE BRACKET (\>)
    ∎  U+220E  END OF PROOF (\qed)
-->
<p>这一章使用了如下的 Unicode 符号：</p>
<pre><code>ℕ  U+2115  双线体大写 N (\bN)
→  U+2192  右箭头 (\to, \r, \-&gt;)
∸  U+2238  点减 (\.-)
≡  U+2261  等价于 (\==)
⟨  U+27E8  数学左尖括号 (\&lt;)
⟩  U+27E9  数学右尖括号 (\&gt;)
∎  U+220E  证毕 (\qed)</code></pre>
<!--
Each line consists of the Unicode character (`ℕ`), the corresponding
code point (`U+2115`), the name of the character (`DOUBLE-STRUCK CAPITAL N`),
and the sequence to type into Emacs to generate the character (`\bN`).
-->
<p>以上的每一行均包含 Unicode 符号（如 <code>ℕ</code>），对应的 Unicode 码点（如 <code>U+2115</code>）， 符号的名称（如 <code>双线体大写 N</code>），以及用于在 Emacs 中键入该符号的按键序列（如 <code>\bN</code>）。</p>
<!--
The command `\r` gives access to a wide variety of rightward arrows.
After typing `\r`, one can access the many available arrows by using
the left, right, up, and down keys to navigate.  The command remembers
where you navigated to the last time, and starts with the same
character next time.  The command `\l` works similarly for left arrows.
-->
<p>通过 <code>\r</code> 命令可以查看多种右箭头符号。在输入 <code>\r</code> 后，你可以 按左、右、上、下键来查看或选择可用的箭头符号。这个命令会记住你上一次选择的位置， 并在下一次使用时从该字符开始。用于输入左箭头的 <code>\l</code> 命令的用法与此类似。</p>
<!--
In place of left, right, up, and down keys, one may also use control
characters:

    C-b  left (backward one character)
    C-f  right (forward one character)
    C-p  up (to the previous line)
    C-n  down (to the next line)
-->
<p>除了在输入箭头的命令中使用左、右、上、下键以外，以下按键也可以起到相同的作用：</p>
<pre><code>C-b  左（后退一个字符）
C-f  右（前进一个字符）
C-p  上（到上一行）
C-n  下（到下一行）</code></pre>
<!--
We write `C-b` to stand for control-b, and similarly.  One can also navigate
left and right by typing the digits that appear in the displayed list.
-->
<p><code>C-b</code> 表示按 Control + b，其余同理。你也可以直接输入显示的列表中的数字编号来选择。</p>
<!--
For a full list of supported characters, use `agda-input-show-translations` with:
-->
<p>要查看所支持字符的完整列表，请执行 <code>agda-input-show-translations</code> 命令：</p>
<pre><code>M-x agda-input-show-translations</code></pre>
<!--
All the characters supported by `agda-mode` are shown. We write M-x to stand for
typing `ESC` followed by `x`.
-->
<p>这样会显示出 <code>agda-mode</code> 中所有支持的字符。我们用 M-x 表示按下 <code>ESC</code> 后再按下 <code>x</code>。</p>
<!--
If you want to know how you input a specific Unicode character in an agda file,
move the cursor onto the character and use `quail-show-key` with:
-->
<p>如果你想知道如何在 agda 文件中输入一个特定的 Unicode 字符，请将光标移至该字符上， 然后执行 <code>quail-show-key</code> 命令：</p>
<pre><code>M-x quail-show-key</code></pre>
<!--
You'll see a key sequence of the character in mini buffer.
If you run `M-x quail-show-key` on say `∸`, you will see `\.-` for the character.
-->
<p>你会在迷你缓冲区中看到输入该字符所需的按键序列。 例如，如果你在 <code>∸</code> 上执行 <code>M-x quail-show-key</code>，就会看到该字符的按键序列为 <code>\.-</code>。</p>
    </div>
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../GettingStarted/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Naturals.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../Induction/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

</article>

            </div>
        </main>
        <footer class="site-footer h-card">
    <data class="u-url" href="../"></data>
    <div class="wrapper">
        <h2 class="footer-heading">编程语言基础：Agda 语言描述</h2>
        
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Philip Wadler</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wadler" title="wadler"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wadler</a></li>
    
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Wen Kokke</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wenkokke</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;wenkokke</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Jeremy G. Siek</li>
                    <li>
                        
                        <a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/jsiek" title="jsiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;jsiek</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;jeremysiek</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        
        This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
    </div>
</footer>

    </body>
</html>
