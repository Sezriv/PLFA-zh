<!DOCTYPE html>
<html lang="en">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../public/css/style.css">
  
  <title>编程语言基础：Agda 语言描述 – Properties</title>
  
  
  
</head>

    <body>
        <header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="../">编程语言基础：Agda 语言描述</a>
        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="../">主页</a>
                <a class="page-link" href="../Announcements/">公告</a>
                <a class="page-link" href="../GettingStarted/">使用说明</a>
                <a class="page-link" href="../Citing/">引用</a>
                <a class="page-link" href="https://plfa.github.io/">English</a>
            </div>
        </nav>
    </div>
</header>

        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Lambda/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part2/Properties.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../DeBruijn/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

    <header class="post-header">
        <h1 class="post-title" id="properties">Properties: Progress and Preservation</h1>
    </header>
    <div class="post-content">
        <pre class="Agda"><a id="152" class="Keyword">module</a> <a id="159" href="../Properties/" class="Module">plfa.part2.Properties</a> <a id="181" class="Keyword">where</a>
</pre>
<p>This chapter covers properties of the simply-typed lambda calculus, as introduced in the previous chapter. The most important of these properties are progress and preservation. We introduce these below, and show how to combine them to get Agda to compute reduction sequences for us.</p>
<h2 id="imports">Imports</h2>
<pre class="Agda"><a id="495" class="Keyword">open</a> <a id="500" class="Keyword">import</a> <a id="507" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="547" class="Keyword">using</a> <a id="553" class="Symbol">(</a><a id="554" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="557" class="Symbol">;</a> <a id="559" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#840" class="Function Operator">_≢_</a><a id="562" class="Symbol">;</a> <a id="564" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="568" class="Symbol">;</a> <a id="570" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a><a id="573" class="Symbol">;</a> <a id="575" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a><a id="579" class="Symbol">;</a> <a id="581" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html#1524" class="Function">cong₂</a><a id="586" class="Symbol">)</a>
<a id="588" class="Keyword">open</a> <a id="593" class="Keyword">import</a> <a id="600" href="https://agda.github.io/agda-stdlib/v1.3/Data.String.html" class="Module">Data.String</a> <a id="612" class="Keyword">using</a> <a id="618" class="Symbol">(</a><a id="619" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.String.html#274" class="Postulate">String</a><a id="625" class="Symbol">;</a> <a id="627" href="https://agda.github.io/agda-stdlib/v1.3/Data.String.Properties.html#2409" class="Function Operator">_≟_</a><a id="630" class="Symbol">)</a>
<a id="632" class="Keyword">open</a> <a id="637" class="Keyword">import</a> <a id="644" href="https://agda.github.io/agda-stdlib/v1.3/Data.Nat.html" class="Module">Data.Nat</a> <a id="653" class="Keyword">using</a> <a id="659" class="Symbol">(</a><a id="660" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="661" class="Symbol">;</a> <a id="663" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="667" class="Symbol">;</a> <a id="669" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="672" class="Symbol">)</a>
<a id="674" class="Keyword">open</a> <a id="679" class="Keyword">import</a> <a id="686" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html" class="Module">Data.Empty</a> <a id="697" class="Keyword">using</a> <a id="703" class="Symbol">(</a><a id="704" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#526" class="Datatype">⊥</a><a id="705" class="Symbol">;</a> <a id="707" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a><a id="713" class="Symbol">)</a>
<a id="715" class="Keyword">open</a> <a id="720" class="Keyword">import</a> <a id="727" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html" class="Module">Data.Product</a>
  <a id="742" class="Keyword">using</a> <a id="748" class="Symbol">(</a><a id="749" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">_×_</a><a id="752" class="Symbol">;</a> <a id="754" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="759" class="Symbol">;</a> <a id="761" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="766" class="Symbol">;</a> <a id="768" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1369" class="Function">∃</a><a id="769" class="Symbol">;</a> <a id="771" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1788" class="Function">∃-syntax</a><a id="779" class="Symbol">)</a>
  <a id="783" class="Keyword">renaming</a> <a id="792" class="Symbol">(</a><a id="793" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="797" class="Symbol">to</a> <a id="_,_"></a><a id="800" href="../Properties/#800" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="805" class="Symbol">)</a>
<a id="807" class="Keyword">open</a> <a id="812" class="Keyword">import</a> <a id="819" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.html" class="Module">Data.Sum</a> <a id="828" class="Keyword">using</a> <a id="834" class="Symbol">(</a><a id="835" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#728" class="Datatype Operator">_⊎_</a><a id="838" class="Symbol">;</a> <a id="840" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#778" class="InductiveConstructor">inj₁</a><a id="844" class="Symbol">;</a> <a id="846" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#803" class="InductiveConstructor">inj₂</a><a id="850" class="Symbol">)</a>
<a id="852" class="Keyword">open</a> <a id="857" class="Keyword">import</a> <a id="864" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="881" class="Keyword">using</a> <a id="887" class="Symbol">(</a><a id="888" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬_</a><a id="890" class="Symbol">;</a> <a id="892" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1508" class="Record">Dec</a><a id="895" class="Symbol">;</a> <a id="897" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a><a id="900" class="Symbol">;</a> <a id="902" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a><a id="904" class="Symbol">)</a>
<a id="906" class="Keyword">open</a> <a id="911" class="Keyword">import</a> <a id="918" href="https://agda.github.io/agda-stdlib/v1.3/Function.html" class="Module">Function</a> <a id="927" class="Keyword">using</a> <a id="933" class="Symbol">(</a><a id="934" href="https://agda.github.io/agda-stdlib/v1.3/Function.Base.html#992" class="Function Operator">_∘_</a><a id="937" class="Symbol">)</a>
<a id="939" class="Keyword">open</a> <a id="944" class="Keyword">import</a> <a id="951" href="../Isomorphism/" class="Module">plfa.part1.Isomorphism</a>
<a id="974" class="Keyword">open</a> <a id="979" class="Keyword">import</a> <a id="986" href="../Lambda/" class="Module">plfa.part2.Lambda</a>
</pre>
<h2 id="introduction">Introduction</h2>
<p>The last chapter introduced simply-typed lambda calculus, including the notions of closed terms, terms that are values, reducing one term to another, and well-typed terms.</p>
<p>Ultimately, we would like to show that we can keep reducing a term until we reach a value. For instance, in the last chapter we showed that two plus two is four,</p>
<pre><code>plus · two · two  —↠  `suc `suc `suc `suc `zero</code></pre>
<p>which was proved by a long chain of reductions, ending in the value on the right. Every term in the chain had the same type, <code>`ℕ</code>. We also saw a second, similar example involving Church numerals.</p>
<p>What we might expect is that every term is either a value or can take a reduction step. As we will see, this property does <em>not</em> hold for every term, but it does hold for every closed, well-typed term.</p>
<p><em>Progress</em>: If <code>∅ ⊢ M ⦂ A</code> then either <code>M</code> is a value or there is an <code>N</code> such that <code>M —→ N</code>.</p>
<p>So, either we have a value, and we are done, or we can take a reduction step. In the latter case, we would like to apply progress again. But to do so we need to know that the term yielded by the reduction is itself closed and well typed. It turns out that this property holds whenever we start with a closed, well-typed term.</p>
<p><em>Preservation</em>: If <code>∅ ⊢ M ⦂ A</code> and <code>M —→ N</code> then <code>∅ ⊢ N ⦂ A</code>.</p>
<p>This gives us a recipe for automating evaluation. Start with a closed and well-typed term. By progress, it is either a value, in which case we are done, or it reduces to some other term. By preservation, that other term will itself be closed and well typed. Repeat. We will either loop forever, in which case evaluation does not terminate, or we will eventually reach a value, which is guaranteed to be closed and of the same type as the original term. We will turn this recipe into Agda code that can compute for us the reduction sequence of <code>plus · two · two</code>, and its Church numeral variant.</p>
<p>(The development in this chapter was inspired by the corresponding development in <em>Software Foundations</em>, Volume <em>Programming Language Foundations</em>, Chapter <em>StlcProp</em>. It will turn out that one of our technical choices — to introduce an explicit judgment <code>Γ ∋ x ⦂ A</code> in place of treating a context as a function from identifiers to types — permits a simpler development. In particular, we can prove substitution preserves types without needing to develop a separate inductive definition of the <code>appears_free_in</code> relation.)</p>
<h2 id="values-do-not-reduce">Values do not reduce</h2>
We start with an easy observation. Values do not reduce:
<pre class="Agda"><a id="V¬—→"></a><a id="3521" href="../Properties/#3521" class="Function">V¬—→</a> <a id="3526" class="Symbol">:</a> <a id="3528" class="Symbol">∀</a> <a id="3530" class="Symbol">{</a><a id="3531" href="../Properties/#3531" class="Bound">M</a> <a id="3533" href="../Properties/#3533" class="Bound">N</a><a id="3534" class="Symbol">}</a>
  <a id="3538" class="Symbol">→</a> <a id="3540" href="../Lambda/#16914" class="Datatype">Value</a> <a id="3546" href="../Properties/#3531" class="Bound">M</a>
    <a id="3552" class="Comment">----------</a>
  <a id="3565" class="Symbol">→</a> <a id="3567" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="3569" class="Symbol">(</a><a id="3570" href="../Properties/#3531" class="Bound">M</a> <a id="3572" href="../Lambda/#27997" class="Datatype Operator">—→</a> <a id="3575" href="../Properties/#3533" class="Bound">N</a><a id="3576" class="Symbol">)</a>
<a id="3578" href="../Properties/#3521" class="Function">V¬—→</a> <a id="3583" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a>        <a id="3594" class="Symbol">()</a>
<a id="3597" href="../Properties/#3521" class="Function">V¬—→</a> <a id="3602" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a>     <a id="3613" class="Symbol">()</a>
<a id="3616" href="../Properties/#3521" class="Function">V¬—→</a> <a id="3621" class="Symbol">(</a><a id="3622" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="3628" href="../Properties/#3628" class="Bound">VM</a><a id="3630" class="Symbol">)</a> <a id="3632" class="Symbol">(</a><a id="3633" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="3639" href="../Properties/#3639" class="Bound">M—→N</a><a id="3643" class="Symbol">)</a> <a id="3645" class="Symbol">=</a> <a id="3647" href="../Properties/#3521" class="Function">V¬—→</a> <a id="3652" href="../Properties/#3628" class="Bound">VM</a> <a id="3655" href="../Properties/#3639" class="Bound">M—→N</a>
</pre>
<p>We consider the three possibilities for values:</p>
<ul>
<li><p>If it is an abstraction then no reduction applies</p></li>
<li><p>If it is zero then no reduction applies</p></li>
<li><p>If it is a successor then rule <code>ξ-suc</code> may apply, but in that case the successor is itself of a value that reduces, which by induction cannot occur.</p></li>
</ul>
As a corollary, terms that reduce are not values:
<pre class="Agda"><a id="—→¬V"></a><a id="4019" href="../Properties/#4019" class="Function">—→¬V</a> <a id="4024" class="Symbol">:</a> <a id="4026" class="Symbol">∀</a> <a id="4028" class="Symbol">{</a><a id="4029" href="../Properties/#4029" class="Bound">M</a> <a id="4031" href="../Properties/#4031" class="Bound">N</a><a id="4032" class="Symbol">}</a>
  <a id="4036" class="Symbol">→</a> <a id="4038" href="../Properties/#4029" class="Bound">M</a> <a id="4040" href="../Lambda/#27997" class="Datatype Operator">—→</a> <a id="4043" href="../Properties/#4031" class="Bound">N</a>
    <a id="4049" class="Comment">---------</a>
  <a id="4061" class="Symbol">→</a> <a id="4063" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="4065" href="../Lambda/#16914" class="Datatype">Value</a> <a id="4071" href="../Properties/#4029" class="Bound">M</a>
<a id="4073" href="../Properties/#4019" class="Function">—→¬V</a> <a id="4078" href="../Properties/#4078" class="Bound">M—→N</a> <a id="4083" href="../Properties/#4083" class="Bound">VM</a>  <a id="4087" class="Symbol">=</a>  <a id="4090" href="../Properties/#3521" class="Function">V¬—→</a> <a id="4095" href="../Properties/#4083" class="Bound">VM</a> <a id="4098" href="../Properties/#4078" class="Bound">M—→N</a>
</pre>
<p>If we expand out the negations, we have</p>
<pre><code>V¬—→ : ∀ {M N} → Value M → M —→ N → ⊥
—→¬V : ∀ {M N} → M —→ N → Value M → ⊥</code></pre>
<p>which are the same function with the arguments swapped.</p>
<h2 id="canonical-forms">Canonical Forms</h2>
Well-typed values must take one of a small number of <em>canonical forms</em>, which provide an analogue of the <code>Value</code> relation that relates values to their types. A lambda expression must have a function type, and a zero or successor expression must be a natural. Further, the body of a function must be well typed in a context containing only its bound variable, and the argument of successor must itself be canonical:
<pre class="Agda"><a id="4731" class="Keyword">infix</a>  <a id="4738" class="Number">4</a> <a id="4740" href="../Properties/#4759" class="Datatype Operator">Canonical_⦂_</a>

<a id="4754" class="Keyword">data</a> <a id="Canonical_⦂_"></a><a id="4759" href="../Properties/#4759" class="Datatype Operator">Canonical_⦂_</a> <a id="4772" class="Symbol">:</a> <a id="4774" href="../Lambda/#5500" class="Datatype">Term</a> <a id="4779" class="Symbol">→</a> <a id="4781" href="../Lambda/#39766" class="Datatype">Type</a> <a id="4786" class="Symbol">→</a> <a id="4788" class="PrimitiveType">Set</a> <a id="4792" class="Keyword">where</a>

  <a id="Canonical_⦂_.C-ƛ"></a><a id="4801" href="../Properties/#4801" class="InductiveConstructor">C-ƛ</a> <a id="4805" class="Symbol">:</a> <a id="4807" class="Symbol">∀</a> <a id="4809" class="Symbol">{</a><a id="4810" href="../Properties/#4810" class="Bound">x</a> <a id="4812" href="../Properties/#4812" class="Bound">A</a> <a id="4814" href="../Properties/#4814" class="Bound">N</a> <a id="4816" href="../Properties/#4816" class="Bound">B</a><a id="4817" class="Symbol">}</a>
    <a id="4823" class="Symbol">→</a> <a id="4825" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="4827" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="4829" href="../Properties/#4810" class="Bound">x</a> <a id="4831" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="4833" href="../Properties/#4812" class="Bound">A</a> <a id="4835" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="4837" href="../Properties/#4814" class="Bound">N</a> <a id="4839" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="4841" href="../Properties/#4816" class="Bound">B</a>
      <a id="4849" class="Comment">-----------------------------</a>
    <a id="4883" class="Symbol">→</a> <a id="4885" href="../Properties/#4759" class="Datatype Operator">Canonical</a> <a id="4895" class="Symbol">(</a><a id="4896" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="4898" href="../Properties/#4810" class="Bound">x</a> <a id="4900" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="4902" href="../Properties/#4814" class="Bound">N</a><a id="4903" class="Symbol">)</a> <a id="4905" href="../Properties/#4759" class="Datatype Operator">⦂</a> <a id="4907" class="Symbol">(</a><a id="4908" href="../Properties/#4812" class="Bound">A</a> <a id="4910" href="../Lambda/#39785" class="InductiveConstructor Operator">⇒</a> <a id="4912" href="../Properties/#4816" class="Bound">B</a><a id="4913" class="Symbol">)</a>

  <a id="Canonical_⦂_.C-zero"></a><a id="4918" href="../Properties/#4918" class="InductiveConstructor">C-zero</a> <a id="4925" class="Symbol">:</a>
      <a id="4933" class="Comment">--------------------</a>
      <a id="4960" href="../Properties/#4759" class="Datatype Operator">Canonical</a> <a id="4970" href="../Lambda/#5652" class="InductiveConstructor">`zero</a> <a id="4976" href="../Properties/#4759" class="Datatype Operator">⦂</a> <a id="4978" href="../Lambda/#39812" class="InductiveConstructor">`ℕ</a>

  <a id="Canonical_⦂_.C-suc"></a><a id="4984" href="../Properties/#4984" class="InductiveConstructor">C-suc</a> <a id="4990" class="Symbol">:</a> <a id="4992" class="Symbol">∀</a> <a id="4994" class="Symbol">{</a><a id="4995" href="../Properties/#4995" class="Bound">V</a><a id="4996" class="Symbol">}</a>
    <a id="5002" class="Symbol">→</a> <a id="5004" href="../Properties/#4759" class="Datatype Operator">Canonical</a> <a id="5014" href="../Properties/#4995" class="Bound">V</a> <a id="5016" href="../Properties/#4759" class="Datatype Operator">⦂</a> <a id="5018" href="../Lambda/#39812" class="InductiveConstructor">`ℕ</a>
      <a id="5027" class="Comment">---------------------</a>
    <a id="5053" class="Symbol">→</a> <a id="5055" href="../Properties/#4759" class="Datatype Operator">Canonical</a> <a id="5065" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="5070" href="../Properties/#4995" class="Bound">V</a> <a id="5072" href="../Properties/#4759" class="Datatype Operator">⦂</a> <a id="5074" href="../Lambda/#39812" class="InductiveConstructor">`ℕ</a>
</pre>
Every closed, well-typed value is canonical:
<pre class="Agda"><a id="canonical"></a><a id="5131" href="../Properties/#5131" class="Function">canonical</a> <a id="5141" class="Symbol">:</a> <a id="5143" class="Symbol">∀</a> <a id="5145" class="Symbol">{</a><a id="5146" href="../Properties/#5146" class="Bound">V</a> <a id="5148" href="../Properties/#5148" class="Bound">A</a><a id="5149" class="Symbol">}</a>
  <a id="5153" class="Symbol">→</a> <a id="5155" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="5157" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="5159" href="../Properties/#5146" class="Bound">V</a> <a id="5161" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="5163" href="../Properties/#5148" class="Bound">A</a>
  <a id="5167" class="Symbol">→</a> <a id="5169" href="../Lambda/#16914" class="Datatype">Value</a> <a id="5175" href="../Properties/#5146" class="Bound">V</a>
    <a id="5181" class="Comment">-----------</a>
  <a id="5195" class="Symbol">→</a> <a id="5197" href="../Properties/#4759" class="Datatype Operator">Canonical</a> <a id="5207" href="../Properties/#5146" class="Bound">V</a> <a id="5209" href="../Properties/#4759" class="Datatype Operator">⦂</a> <a id="5211" href="../Properties/#5148" class="Bound">A</a>
<a id="5213" href="../Properties/#5131" class="Function">canonical</a> <a id="5223" class="Symbol">(</a><a id="5224" href="../Lambda/#46084" class="InductiveConstructor">⊢`</a> <a id="5227" class="Symbol">())</a>          <a id="5240" class="Symbol">()</a>
<a id="5243" href="../Properties/#5131" class="Function">canonical</a> <a id="5253" class="Symbol">(</a><a id="5254" href="../Lambda/#46163" class="InductiveConstructor">⊢ƛ</a> <a id="5257" href="../Properties/#5257" class="Bound">⊢N</a><a id="5259" class="Symbol">)</a>          <a id="5270" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a>         <a id="5282" class="Symbol">=</a>  <a id="5285" href="../Properties/#4801" class="InductiveConstructor">C-ƛ</a> <a id="5289" href="../Properties/#5257" class="Bound">⊢N</a>
<a id="5292" href="../Properties/#5131" class="Function">canonical</a> <a id="5302" class="Symbol">(</a><a id="5303" href="../Properties/#5303" class="Bound">⊢L</a> <a id="5306" href="../Lambda/#46270" class="InductiveConstructor Operator">·</a> <a id="5308" href="../Properties/#5308" class="Bound">⊢M</a><a id="5310" class="Symbol">)</a>        <a id="5319" class="Symbol">()</a>
<a id="5322" href="../Properties/#5131" class="Function">canonical</a> <a id="5332" href="../Lambda/#46379" class="InductiveConstructor">⊢zero</a>            <a id="5349" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a>      <a id="5361" class="Symbol">=</a>  <a id="5364" href="../Properties/#4918" class="InductiveConstructor">C-zero</a>
<a id="5371" href="../Properties/#5131" class="Function">canonical</a> <a id="5381" class="Symbol">(</a><a id="5382" href="../Lambda/#46448" class="InductiveConstructor">⊢suc</a> <a id="5387" href="../Properties/#5387" class="Bound">⊢V</a><a id="5389" class="Symbol">)</a>        <a id="5398" class="Symbol">(</a><a id="5399" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="5405" href="../Properties/#5405" class="Bound">VV</a><a id="5407" class="Symbol">)</a>  <a id="5410" class="Symbol">=</a>  <a id="5413" href="../Properties/#4984" class="InductiveConstructor">C-suc</a> <a id="5419" class="Symbol">(</a><a id="5420" href="../Properties/#5131" class="Function">canonical</a> <a id="5430" href="../Properties/#5387" class="Bound">⊢V</a> <a id="5433" href="../Properties/#5405" class="Bound">VV</a><a id="5435" class="Symbol">)</a>
<a id="5437" href="../Properties/#5131" class="Function">canonical</a> <a id="5447" class="Symbol">(</a><a id="5448" href="../Lambda/#46536" class="InductiveConstructor">⊢case</a> <a id="5454" href="../Properties/#5454" class="Bound">⊢L</a> <a id="5457" href="../Properties/#5457" class="Bound">⊢M</a> <a id="5460" href="../Properties/#5460" class="Bound">⊢N</a><a id="5462" class="Symbol">)</a> <a id="5464" class="Symbol">()</a>
<a id="5467" href="../Properties/#5131" class="Function">canonical</a> <a id="5477" class="Symbol">(</a><a id="5478" href="../Lambda/#46708" class="InductiveConstructor">⊢μ</a> <a id="5481" href="../Properties/#5481" class="Bound">⊢M</a><a id="5483" class="Symbol">)</a>          <a id="5494" class="Symbol">()</a>
</pre>
<p>There are only three interesting cases to consider:</p>
<ul>
<li><p>If the term is a lambda abstraction, then well-typing of the term guarantees well-typing of the body.</p></li>
<li><p>If the term is zero then it is canonical trivially.</p></li>
<li><p>If the term is a successor then since it is well typed its argument is well typed, and since it is a value its argument is a value. Hence, by induction its argument is also canonical.</p></li>
</ul>
<p>The variable case is thrown out because a closed term has no free variables and because a variable is not a value. The cases for application, case expression, and fixpoint are thrown out because they are not values.</p>
Conversely, if a term is canonical then it is a value and it is well typed in the empty context:
<pre class="Agda"><a id="value"></a><a id="6226" href="../Properties/#6226" class="Function">value</a> <a id="6232" class="Symbol">:</a> <a id="6234" class="Symbol">∀</a> <a id="6236" class="Symbol">{</a><a id="6237" href="../Properties/#6237" class="Bound">M</a> <a id="6239" href="../Properties/#6239" class="Bound">A</a><a id="6240" class="Symbol">}</a>
  <a id="6244" class="Symbol">→</a> <a id="6246" href="../Properties/#4759" class="Datatype Operator">Canonical</a> <a id="6256" href="../Properties/#6237" class="Bound">M</a> <a id="6258" href="../Properties/#4759" class="Datatype Operator">⦂</a> <a id="6260" href="../Properties/#6239" class="Bound">A</a>
    <a id="6266" class="Comment">----------------</a>
  <a id="6285" class="Symbol">→</a> <a id="6287" href="../Lambda/#16914" class="Datatype">Value</a> <a id="6293" href="../Properties/#6237" class="Bound">M</a>
<a id="6295" href="../Properties/#6226" class="Function">value</a> <a id="6301" class="Symbol">(</a><a id="6302" href="../Properties/#4801" class="InductiveConstructor">C-ƛ</a> <a id="6306" href="../Properties/#6306" class="Bound">⊢N</a><a id="6308" class="Symbol">)</a>    <a id="6313" class="Symbol">=</a>  <a id="6316" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a>
<a id="6320" href="../Properties/#6226" class="Function">value</a> <a id="6326" href="../Properties/#4918" class="InductiveConstructor">C-zero</a>      <a id="6338" class="Symbol">=</a>  <a id="6341" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a>
<a id="6348" href="../Properties/#6226" class="Function">value</a> <a id="6354" class="Symbol">(</a><a id="6355" href="../Properties/#4984" class="InductiveConstructor">C-suc</a> <a id="6361" href="../Properties/#6361" class="Bound">CM</a><a id="6363" class="Symbol">)</a>  <a id="6366" class="Symbol">=</a>  <a id="6369" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="6375" class="Symbol">(</a><a id="6376" href="../Properties/#6226" class="Function">value</a> <a id="6382" href="../Properties/#6361" class="Bound">CM</a><a id="6384" class="Symbol">)</a>

<a id="typed"></a><a id="6387" href="../Properties/#6387" class="Function">typed</a> <a id="6393" class="Symbol">:</a> <a id="6395" class="Symbol">∀</a> <a id="6397" class="Symbol">{</a><a id="6398" href="../Properties/#6398" class="Bound">M</a> <a id="6400" href="../Properties/#6400" class="Bound">A</a><a id="6401" class="Symbol">}</a>
  <a id="6405" class="Symbol">→</a> <a id="6407" href="../Properties/#4759" class="Datatype Operator">Canonical</a> <a id="6417" href="../Properties/#6398" class="Bound">M</a> <a id="6419" href="../Properties/#4759" class="Datatype Operator">⦂</a> <a id="6421" href="../Properties/#6400" class="Bound">A</a>
    <a id="6427" class="Comment">---------------</a>
  <a id="6445" class="Symbol">→</a> <a id="6447" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="6449" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="6451" href="../Properties/#6398" class="Bound">M</a> <a id="6453" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="6455" href="../Properties/#6400" class="Bound">A</a>
<a id="6457" href="../Properties/#6387" class="Function">typed</a> <a id="6463" class="Symbol">(</a><a id="6464" href="../Properties/#4801" class="InductiveConstructor">C-ƛ</a> <a id="6468" href="../Properties/#6468" class="Bound">⊢N</a><a id="6470" class="Symbol">)</a>    <a id="6475" class="Symbol">=</a>  <a id="6478" href="../Lambda/#46163" class="InductiveConstructor">⊢ƛ</a> <a id="6481" href="../Properties/#6468" class="Bound">⊢N</a>
<a id="6484" href="../Properties/#6387" class="Function">typed</a> <a id="6490" href="../Properties/#4918" class="InductiveConstructor">C-zero</a>      <a id="6502" class="Symbol">=</a>  <a id="6505" href="../Lambda/#46379" class="InductiveConstructor">⊢zero</a>
<a id="6511" href="../Properties/#6387" class="Function">typed</a> <a id="6517" class="Symbol">(</a><a id="6518" href="../Properties/#4984" class="InductiveConstructor">C-suc</a> <a id="6524" href="../Properties/#6524" class="Bound">CM</a><a id="6526" class="Symbol">)</a>  <a id="6529" class="Symbol">=</a>  <a id="6532" href="../Lambda/#46448" class="InductiveConstructor">⊢suc</a> <a id="6537" class="Symbol">(</a><a id="6538" href="../Properties/#6387" class="Function">typed</a> <a id="6544" href="../Properties/#6524" class="Bound">CM</a><a id="6546" class="Symbol">)</a>
</pre>
<p>The proofs are straightforward, and again use induction in the case of successor.</p>
<h2 id="progress">Progress</h2>
<p>We would like to show that every term is either a value or takes a reduction step. However, this is not true in general. The term</p>
<pre><code>`zero · `suc `zero</code></pre>
<p>is neither a value nor can take a reduction step. And if <code>s ⦂ `ℕ ⇒ `ℕ</code> then the term</p>
<pre><code> s · `zero</code></pre>
<p>cannot reduce because we do not know which function is bound to the free variable <code>s</code>. The first of those terms is ill typed, and the second has a free variable. Every term that is well typed and closed has the desired property.</p>
<p><em>Progress</em>: If <code>∅ ⊢ M ⦂ A</code> then either <code>M</code> is a value or there is an <code>N</code> such that <code>M —→ N</code>.</p>
To formulate this property, we first introduce a relation that captures what it means for a term <code>M</code> to make progress:
<pre class="Agda"><a id="7361" class="Keyword">data</a> <a id="Progress"></a><a id="7366" href="../Properties/#7366" class="Datatype">Progress</a> <a id="7375" class="Symbol">(</a><a id="7376" href="../Properties/#7376" class="Bound">M</a> <a id="7378" class="Symbol">:</a> <a id="7380" href="../Lambda/#5500" class="Datatype">Term</a><a id="7384" class="Symbol">)</a> <a id="7386" class="Symbol">:</a> <a id="7388" class="PrimitiveType">Set</a> <a id="7392" class="Keyword">where</a>

  <a id="Progress.step"></a><a id="7401" href="../Properties/#7401" class="InductiveConstructor">step</a> <a id="7406" class="Symbol">:</a> <a id="7408" class="Symbol">∀</a> <a id="7410" class="Symbol">{</a><a id="7411" href="../Properties/#7411" class="Bound">N</a><a id="7412" class="Symbol">}</a>
    <a id="7418" class="Symbol">→</a> <a id="7420" href="../Properties/#7376" class="Bound">M</a> <a id="7422" href="../Lambda/#27997" class="Datatype Operator">—→</a> <a id="7425" href="../Properties/#7411" class="Bound">N</a>
      <a id="7433" class="Comment">----------</a>
    <a id="7448" class="Symbol">→</a> <a id="7450" href="../Properties/#7366" class="Datatype">Progress</a> <a id="7459" href="../Properties/#7376" class="Bound">M</a>

  <a id="Progress.done"></a><a id="7464" href="../Properties/#7464" class="InductiveConstructor">done</a> <a id="7469" class="Symbol">:</a>
      <a id="7477" href="../Lambda/#16914" class="Datatype">Value</a> <a id="7483" href="../Properties/#7376" class="Bound">M</a>
      <a id="7491" class="Comment">----------</a>
    <a id="7506" class="Symbol">→</a> <a id="7508" href="../Properties/#7366" class="Datatype">Progress</a> <a id="7517" href="../Properties/#7376" class="Bound">M</a>
</pre>
<p>A term <code>M</code> makes progress if either it can take a step, meaning there exists a term <code>N</code> such that <code>M —→ N</code>, or if it is done, meaning that <code>M</code> is a value.</p>
If a term is well typed in the empty context then it satisfies progress:
<pre class="Agda"><a id="progress"></a><a id="7756" href="../Properties/#7756" class="Function">progress</a> <a id="7765" class="Symbol">:</a> <a id="7767" class="Symbol">∀</a> <a id="7769" class="Symbol">{</a><a id="7770" href="../Properties/#7770" class="Bound">M</a> <a id="7772" href="../Properties/#7772" class="Bound">A</a><a id="7773" class="Symbol">}</a>
  <a id="7777" class="Symbol">→</a> <a id="7779" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="7781" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="7783" href="../Properties/#7770" class="Bound">M</a> <a id="7785" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="7787" href="../Properties/#7772" class="Bound">A</a>
    <a id="7793" class="Comment">----------</a>
  <a id="7806" class="Symbol">→</a> <a id="7808" href="../Properties/#7366" class="Datatype">Progress</a> <a id="7817" href="../Properties/#7770" class="Bound">M</a>
<a id="7819" href="../Properties/#7756" class="Function">progress</a> <a id="7828" class="Symbol">(</a><a id="7829" href="../Lambda/#46084" class="InductiveConstructor">⊢`</a> <a id="7832" class="Symbol">())</a>
<a id="7836" href="../Properties/#7756" class="Function">progress</a> <a id="7845" class="Symbol">(</a><a id="7846" href="../Lambda/#46163" class="InductiveConstructor">⊢ƛ</a> <a id="7849" href="../Properties/#7849" class="Bound">⊢N</a><a id="7851" class="Symbol">)</a>                            <a id="7880" class="Symbol">=</a>  <a id="7883" href="../Properties/#7464" class="InductiveConstructor">done</a> <a id="7888" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a>
<a id="7892" href="../Properties/#7756" class="Function">progress</a> <a id="7901" class="Symbol">(</a><a id="7902" href="../Properties/#7902" class="Bound">⊢L</a> <a id="7905" href="../Lambda/#46270" class="InductiveConstructor Operator">·</a> <a id="7907" href="../Properties/#7907" class="Bound">⊢M</a><a id="7909" class="Symbol">)</a> <a id="7911" class="Keyword">with</a> <a id="7916" href="../Properties/#7756" class="Function">progress</a> <a id="7925" href="../Properties/#7902" class="Bound">⊢L</a>
<a id="7928" class="Symbol">...</a> <a id="7932" class="Symbol">|</a> <a id="7934" href="../Properties/#7401" class="InductiveConstructor">step</a> <a id="7939" href="../Properties/#7939" class="Bound">L—→L′</a>                            <a id="7972" class="Symbol">=</a>  <a id="7975" href="../Properties/#7401" class="InductiveConstructor">step</a> <a id="7980" class="Symbol">(</a><a id="7981" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="7986" href="../Properties/#7939" class="Bound">L—→L′</a><a id="7991" class="Symbol">)</a>
<a id="7993" class="Symbol">...</a> <a id="7997" class="Symbol">|</a> <a id="7999" href="../Properties/#7464" class="InductiveConstructor">done</a> <a id="8004" href="../Properties/#8004" class="Bound">VL</a> <a id="8007" class="Keyword">with</a> <a id="8012" href="../Properties/#7756" class="Function">progress</a> <a id="8021" class="Bound">⊢M</a>
<a id="8024" class="Symbol">...</a>   <a id="8030" class="Symbol">|</a> <a id="8032" href="../Properties/#7401" class="InductiveConstructor">step</a> <a id="8037" href="../Properties/#8037" class="Bound">M—→M′</a>                          <a id="8068" class="Symbol">=</a>  <a id="8071" href="../Properties/#7401" class="InductiveConstructor">step</a> <a id="8076" class="Symbol">(</a><a id="8077" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="8082" class="Bound">VL</a> <a id="8085" href="../Properties/#8037" class="Bound">M—→M′</a><a id="8090" class="Symbol">)</a>
<a id="8092" class="Symbol">...</a>   <a id="8098" class="Symbol">|</a> <a id="8100" href="../Properties/#7464" class="InductiveConstructor">done</a> <a id="8105" href="../Properties/#8105" class="Bound">VM</a> <a id="8108" class="Keyword">with</a> <a id="8113" href="../Properties/#5131" class="Function">canonical</a> <a id="8123" class="Bound">⊢L</a> <a id="8126" class="Bound">VL</a>
<a id="8129" class="Symbol">...</a>     <a id="8137" class="Symbol">|</a> <a id="8139" href="../Properties/#4801" class="InductiveConstructor">C-ƛ</a> <a id="8143" class="Symbol">_</a>                             <a id="8173" class="Symbol">=</a>  <a id="8176" href="../Properties/#7401" class="InductiveConstructor">step</a> <a id="8181" class="Symbol">(</a><a id="8182" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="8186" class="Bound">VM</a><a id="8188" class="Symbol">)</a>
<a id="8190" href="../Properties/#7756" class="Function">progress</a> <a id="8199" href="../Lambda/#46379" class="InductiveConstructor">⊢zero</a>                              <a id="8234" class="Symbol">=</a>  <a id="8237" href="../Properties/#7464" class="InductiveConstructor">done</a> <a id="8242" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a>
<a id="8249" href="../Properties/#7756" class="Function">progress</a> <a id="8258" class="Symbol">(</a><a id="8259" href="../Lambda/#46448" class="InductiveConstructor">⊢suc</a> <a id="8264" href="../Properties/#8264" class="Bound">⊢M</a><a id="8266" class="Symbol">)</a> <a id="8268" class="Keyword">with</a> <a id="8273" href="../Properties/#7756" class="Function">progress</a> <a id="8282" href="../Properties/#8264" class="Bound">⊢M</a>
<a id="8285" class="Symbol">...</a>  <a id="8290" class="Symbol">|</a> <a id="8292" href="../Properties/#7401" class="InductiveConstructor">step</a> <a id="8297" href="../Properties/#8297" class="Bound">M—→M′</a>                           <a id="8329" class="Symbol">=</a>  <a id="8332" href="../Properties/#7401" class="InductiveConstructor">step</a> <a id="8337" class="Symbol">(</a><a id="8338" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="8344" href="../Properties/#8297" class="Bound">M—→M′</a><a id="8349" class="Symbol">)</a>
<a id="8351" class="Symbol">...</a>  <a id="8356" class="Symbol">|</a> <a id="8358" href="../Properties/#7464" class="InductiveConstructor">done</a> <a id="8363" href="../Properties/#8363" class="Bound">VM</a>                              <a id="8395" class="Symbol">=</a>  <a id="8398" href="../Properties/#7464" class="InductiveConstructor">done</a> <a id="8403" class="Symbol">(</a><a id="8404" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="8410" href="../Properties/#8363" class="Bound">VM</a><a id="8412" class="Symbol">)</a>
<a id="8414" href="../Properties/#7756" class="Function">progress</a> <a id="8423" class="Symbol">(</a><a id="8424" href="../Lambda/#46536" class="InductiveConstructor">⊢case</a> <a id="8430" href="../Properties/#8430" class="Bound">⊢L</a> <a id="8433" href="../Properties/#8433" class="Bound">⊢M</a> <a id="8436" href="../Properties/#8436" class="Bound">⊢N</a><a id="8438" class="Symbol">)</a> <a id="8440" class="Keyword">with</a> <a id="8445" href="../Properties/#7756" class="Function">progress</a> <a id="8454" href="../Properties/#8430" class="Bound">⊢L</a>
<a id="8457" class="Symbol">...</a> <a id="8461" class="Symbol">|</a> <a id="8463" href="../Properties/#7401" class="InductiveConstructor">step</a> <a id="8468" href="../Properties/#8468" class="Bound">L—→L′</a>                            <a id="8501" class="Symbol">=</a>  <a id="8504" href="../Properties/#7401" class="InductiveConstructor">step</a> <a id="8509" class="Symbol">(</a><a id="8510" href="../Lambda/#28396" class="InductiveConstructor">ξ-case</a> <a id="8517" href="../Properties/#8468" class="Bound">L—→L′</a><a id="8522" class="Symbol">)</a>
<a id="8524" class="Symbol">...</a> <a id="8528" class="Symbol">|</a> <a id="8530" href="../Properties/#7464" class="InductiveConstructor">done</a> <a id="8535" href="../Properties/#8535" class="Bound">VL</a> <a id="8538" class="Keyword">with</a> <a id="8543" href="../Properties/#5131" class="Function">canonical</a> <a id="8553" class="Bound">⊢L</a> <a id="8556" href="../Properties/#8535" class="Bound">VL</a>
<a id="8559" class="Symbol">...</a>   <a id="8565" class="Symbol">|</a> <a id="8567" href="../Properties/#4918" class="InductiveConstructor">C-zero</a>                              <a id="8603" class="Symbol">=</a>  <a id="8606" href="../Properties/#7401" class="InductiveConstructor">step</a> <a id="8611" href="../Lambda/#28577" class="InductiveConstructor">β-zero</a>
<a id="8618" class="Symbol">...</a>   <a id="8624" class="Symbol">|</a> <a id="8626" href="../Properties/#4984" class="InductiveConstructor">C-suc</a> <a id="8632" href="../Properties/#8632" class="Bound">CL</a>                            <a id="8662" class="Symbol">=</a>  <a id="8665" href="../Properties/#7401" class="InductiveConstructor">step</a> <a id="8670" class="Symbol">(</a><a id="8671" href="../Lambda/#28690" class="InductiveConstructor">β-suc</a> <a id="8677" class="Symbol">(</a><a id="8678" href="../Properties/#6226" class="Function">value</a> <a id="8684" href="../Properties/#8632" class="Bound">CL</a><a id="8686" class="Symbol">))</a>
<a id="8689" href="../Properties/#7756" class="Function">progress</a> <a id="8698" class="Symbol">(</a><a id="8699" href="../Lambda/#46708" class="InductiveConstructor">⊢μ</a> <a id="8702" href="../Properties/#8702" class="Bound">⊢M</a><a id="8704" class="Symbol">)</a>                            <a id="8733" class="Symbol">=</a>  <a id="8736" href="../Properties/#7401" class="InductiveConstructor">step</a> <a id="8741" href="../Lambda/#28841" class="InductiveConstructor">β-μ</a>
</pre>
<p>We induct on the evidence that the term is well typed. Let’s unpack the first three cases:</p>
<ul>
<li><p>The term cannot be a variable, since no variable is well typed in the empty context.</p></li>
<li><p>If the term is a lambda abstraction then it is a value.</p></li>
<li><p>If the term is an application <code>L · M</code>, recursively apply progress to the derivation that <code>L</code> is well typed:</p>
<ul>
<li><p>If the term steps, we have evidence that <code>L —→ L′</code>, which by <code>ξ-·₁</code> means that our original term steps to <code>L′ · M</code></p></li>
<li><p>If the term is done, we have evidence that <code>L</code> is a value. Recursively apply progress to the derivation that <code>M</code> is well typed:</p>
<ul>
<li><p>If the term steps, we have evidence that <code>M —→ M′</code>, which by <code>ξ-·₂</code> means that our original term steps to <code>L · M′</code>. Step <code>ξ-·₂</code> applies only if we have evidence that <code>L</code> is a value, but progress on that subterm has already supplied the required evidence.</p></li>
<li><p>If the term is done, we have evidence that <code>M</code> is a value. We apply the canonical forms lemma to the evidence that <code>L</code> is well typed and a value, which since we are in an application leads to the conclusion that <code>L</code> must be a lambda abstraction. We also have evidence that <code>M</code> is a value, so our original term steps by <code>β-ƛ</code>.</p></li>
</ul></li>
</ul></li>
</ul>
<p>The remaining cases are similar. If by induction we have a <code>step</code> case we apply a <code>ξ</code> rule, and if we have a <code>done</code> case then either we have a value or apply a <code>β</code> rule. For fixpoint, no induction is required as the <code>β</code> rule applies immediately.</p>
<p>Our code reads neatly in part because we consider the <code>step</code> option before the <code>done</code> option. We could, of course, do it the other way around, but then the <code>...</code> abbreviation no longer works, and we will need to write out all the arguments in full. In general, the rule of thumb is to consider the easy case (here <code>step</code>) before the hard case (here <code>done</code>). If you have two hard cases, you will have to expand out <code>...</code> or introduce subsidiary functions.</p>
Instead of defining a data type for <code>Progress M</code>, we could have formulated progress using disjunction and existentials:
<pre class="Agda"><a id="10859" class="Keyword">postulate</a>
  <a id="progress′"></a><a id="10871" href="../Properties/#10871" class="Postulate">progress′</a> <a id="10881" class="Symbol">:</a> <a id="10883" class="Symbol">∀</a> <a id="10885" href="../Properties/#10885" class="Bound">M</a> <a id="10887" class="Symbol">{</a><a id="10888" href="../Properties/#10888" class="Bound">A</a><a id="10889" class="Symbol">}</a> <a id="10891" class="Symbol">→</a> <a id="10893" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="10895" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="10897" href="../Properties/#10885" class="Bound">M</a> <a id="10899" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="10901" href="../Properties/#10888" class="Bound">A</a> <a id="10903" class="Symbol">→</a> <a id="10905" href="../Lambda/#16914" class="Datatype">Value</a> <a id="10911" href="../Properties/#10885" class="Bound">M</a> <a id="10913" href="https://agda.github.io/agda-stdlib/v1.3/Data.Sum.Base.html#728" class="Datatype Operator">⊎</a> <a id="10915" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1788" class="Function">∃[</a> <a id="10918" href="../Properties/#10918" class="Bound">N</a> <a id="10920" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1788" class="Function">]</a><a id="10921" class="Symbol">(</a><a id="10922" href="../Properties/#10885" class="Bound">M</a> <a id="10924" href="../Lambda/#27997" class="Datatype Operator">—→</a> <a id="10927" href="../Properties/#10918" class="Bound">N</a><a id="10928" class="Symbol">)</a>
</pre>
<p>This leads to a less perspicuous proof. Instead of the mnemonic <code>done</code> and <code>step</code> we use <code>inj₁</code> and <code>inj₂</code>, and the term <code>N</code> is no longer implicit and so must be written out in full. In the case for <code>β-ƛ</code> this requires that we match against the lambda expression <code>L</code> to determine its bound variable and body, <code>ƛ x ⇒ N</code>, so we can show that <code>L · M</code> reduces to <code>N [ x := M ]</code>.</p>
<h4 id="exercise-progress--practice">Exercise <code>Progress-≃</code> (practice)</h4>
<p>Show that <code>Progress M</code> is isomorphic to <code>Value M ⊎ ∃[ N ](M —→ N)</code>.</p>
<pre class="Agda"><a id="11424" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-progress-practice">Exercise <code>progress′</code> (practice)</h4>
<p>Write out the proof of <code>progress′</code> in full, and compare it to the proof of <code>progress</code> above.</p>
<pre class="Agda"><a id="11588" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-value-practice">Exercise <code>value?</code> (practice)</h4>
Combine <code>progress</code> and <code>—→¬V</code> to write a program that decides whether a well-typed term is a value:
<pre class="Agda"><a id="11755" class="Keyword">postulate</a>
  <a id="value?"></a><a id="11767" href="../Properties/#11767" class="Postulate">value?</a> <a id="11774" class="Symbol">:</a> <a id="11776" class="Symbol">∀</a> <a id="11778" class="Symbol">{</a><a id="11779" href="../Properties/#11779" class="Bound">A</a> <a id="11781" href="../Properties/#11781" class="Bound">M</a><a id="11782" class="Symbol">}</a> <a id="11784" class="Symbol">→</a> <a id="11786" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="11788" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="11790" href="../Properties/#11781" class="Bound">M</a> <a id="11792" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="11794" href="../Properties/#11779" class="Bound">A</a> <a id="11796" class="Symbol">→</a> <a id="11798" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1508" class="Record">Dec</a> <a id="11802" class="Symbol">(</a><a id="11803" href="../Lambda/#16914" class="Datatype">Value</a> <a id="11809" href="../Properties/#11781" class="Bound">M</a><a id="11810" class="Symbol">)</a>
</pre>
<h2 id="prelude-to-preservation">Prelude to preservation</h2>
<p>The other property we wish to prove, preservation of typing under reduction, turns out to require considerably more work. The proof has three key steps.</p>
<p>The first step is to show that types are preserved by <em>renaming</em>.</p>
<p><em>Renaming</em>: Let <code>Γ</code> and <code>Δ</code> be two contexts such that every variable that appears in <code>Γ</code> also appears with the same type in <code>Δ</code>. Then if any term is typeable under <code>Γ</code>, it has the same type under <code>Δ</code>.</p>
<p>In symbols:</p>
<pre><code>∀ {x A} → Γ ∋ x ⦂ A  →  Δ ∋ x ⦂ A
---------------------------------
∀ {M A} → Γ ⊢ M ⦂ A  →  Δ ⊢ M ⦂ A</code></pre>
<p>Three important corollaries follow. The <em>weaken</em> lemma asserts that a term which is well typed in the empty context is also well typed in an arbitrary context. The <em>drop</em> lemma asserts that a term which is well typed in a context where the same variable appears twice remains well typed if we drop the shadowed occurrence. The <em>swap</em> lemma asserts that a term which is well typed in a context remains well typed if we swap two variables.</p>
<p>(Renaming is similar to the <em>context invariance</em> lemma in <em>Software Foundations</em>, but it does not require the definition of <code>appears_free_in</code> nor the <code>free_in_context</code> lemma.)</p>
<p>The second step is to show that types are preserved by <em>substitution</em>.</p>
<p><em>Substitution</em>: Say we have a closed term <code>V</code> of type <code>A</code>, and under the assumption that <code>x</code> has type <code>A</code> the term <code>N</code> has type <code>B</code>. Then substituting <code>V</code> for <code>x</code> in <code>N</code> yields a term that also has type <code>B</code>.</p>
<p>In symbols:</p>
<pre><code>∅ ⊢ V ⦂ A
Γ , x ⦂ A ⊢ N ⦂ B
--------------------
Γ ⊢ N [ x := V ] ⦂ B</code></pre>
<p>The result does not depend on <code>V</code> being a value, but it does require that <code>V</code> be closed; recall that we restricted our attention to substitution by closed terms in order to avoid the need to rename bound variables. The term into which we are substituting is typed in an arbitrary context <code>Γ</code>, extended by the variable <code>x</code> for which we are substituting; and the result term is typed in <code>Γ</code>.</p>
<p>The lemma establishes that substitution composes well with typing: typing the components separately guarantees that the result of combining them is also well typed.</p>
<p>The third step is to show preservation.</p>
<p><em>Preservation</em>: If <code>∅ ⊢ M ⦂ A</code> and <code>M —→ N</code> then <code>∅ ⊢ N ⦂ A</code>.</p>
<p>The proof is by induction over the possible reductions, and the substitution lemma is crucial in showing that each of the <code>β</code> rules that uses substitution preserves types.</p>
<p>We now proceed with our three-step programme.</p>
<h2 id="renaming">Renaming</h2>
<p>We often need to “rebase” a type derivation, replacing a derivation <code>Γ ⊢ M ⦂ A</code> by a related derivation <code>Δ ⊢ M ⦂ A</code>. We may do so as long as every variable that appears in <code>Γ</code> also appears in <code>Δ</code>, and with the same type.</p>
<p>Three of the rules for typing (lambda abstraction, case on naturals, and fixpoint) have hypotheses that extend the context to include a bound variable. In each of these rules, <code>Γ</code> appears in the conclusion and <code>Γ , x ⦂ A</code> appears in a hypothesis. Thus:</p>
<pre><code>Γ , x ⦂ A ⊢ N ⦂ B
------------------- ⊢ƛ
Γ ⊢ ƛ x ⇒ N ⦂ A ⇒ B</code></pre>
for lambda expressions, and similarly for case and fixpoint. To deal with this situation, we first prove a lemma showing that if one context maps to another, this is still true after adding the same variable to both contexts:
<pre class="Agda"><a id="ext"></a><a id="15076" href="../Properties/#15076" class="Function">ext</a> <a id="15080" class="Symbol">:</a> <a id="15082" class="Symbol">∀</a> <a id="15084" class="Symbol">{</a><a id="15085" href="../Properties/#15085" class="Bound">Γ</a> <a id="15087" href="../Properties/#15087" class="Bound">Δ</a><a id="15088" class="Symbol">}</a>
  <a id="15092" class="Symbol">→</a> <a id="15094" class="Symbol">(∀</a> <a id="15097" class="Symbol">{</a><a id="15098" href="../Properties/#15098" class="Bound">x</a> <a id="15100" href="../Properties/#15100" class="Bound">A</a><a id="15101" class="Symbol">}</a>     <a id="15107" class="Symbol">→</a>         <a id="15117" href="../Properties/#15085" class="Bound">Γ</a> <a id="15119" href="../Lambda/#43958" class="Datatype Operator">∋</a> <a id="15121" href="../Properties/#15098" class="Bound">x</a> <a id="15123" href="../Lambda/#43958" class="Datatype Operator">⦂</a> <a id="15125" href="../Properties/#15100" class="Bound">A</a> <a id="15127" class="Symbol">→</a>         <a id="15137" href="../Properties/#15087" class="Bound">Δ</a> <a id="15139" href="../Lambda/#43958" class="Datatype Operator">∋</a> <a id="15141" href="../Properties/#15098" class="Bound">x</a> <a id="15143" href="../Lambda/#43958" class="Datatype Operator">⦂</a> <a id="15145" href="../Properties/#15100" class="Bound">A</a><a id="15146" class="Symbol">)</a>
    <a id="15152" class="Comment">-----------------------------------------------------</a>
  <a id="15208" class="Symbol">→</a> <a id="15210" class="Symbol">(∀</a> <a id="15213" class="Symbol">{</a><a id="15214" href="../Properties/#15214" class="Bound">x</a> <a id="15216" href="../Properties/#15216" class="Bound">y</a> <a id="15218" href="../Properties/#15218" class="Bound">A</a> <a id="15220" href="../Properties/#15220" class="Bound">B</a><a id="15221" class="Symbol">}</a> <a id="15223" class="Symbol">→</a> <a id="15225" href="../Properties/#15085" class="Bound">Γ</a> <a id="15227" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="15229" href="../Properties/#15216" class="Bound">y</a> <a id="15231" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="15233" href="../Properties/#15220" class="Bound">B</a> <a id="15235" href="../Lambda/#43958" class="Datatype Operator">∋</a> <a id="15237" href="../Properties/#15214" class="Bound">x</a> <a id="15239" href="../Lambda/#43958" class="Datatype Operator">⦂</a> <a id="15241" href="../Properties/#15218" class="Bound">A</a> <a id="15243" class="Symbol">→</a> <a id="15245" href="../Properties/#15087" class="Bound">Δ</a> <a id="15247" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="15249" href="../Properties/#15216" class="Bound">y</a> <a id="15251" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="15253" href="../Properties/#15220" class="Bound">B</a> <a id="15255" href="../Lambda/#43958" class="Datatype Operator">∋</a> <a id="15257" href="../Properties/#15214" class="Bound">x</a> <a id="15259" href="../Lambda/#43958" class="Datatype Operator">⦂</a> <a id="15261" href="../Properties/#15218" class="Bound">A</a><a id="15262" class="Symbol">)</a>
<a id="15264" href="../Properties/#15076" class="Function">ext</a> <a id="15268" href="../Properties/#15268" class="Bound">ρ</a> <a id="15270" href="../Lambda/#44001" class="InductiveConstructor">Z</a>           <a id="15282" class="Symbol">=</a>  <a id="15285" href="../Lambda/#44001" class="InductiveConstructor">Z</a>
<a id="15287" href="../Properties/#15076" class="Function">ext</a> <a id="15291" href="../Properties/#15291" class="Bound">ρ</a> <a id="15293" class="Symbol">(</a><a id="15294" href="../Lambda/#44067" class="InductiveConstructor">S</a> <a id="15296" href="../Properties/#15296" class="Bound">x≢y</a> <a id="15300" href="../Properties/#15300" class="Bound">∋x</a><a id="15302" class="Symbol">)</a>  <a id="15305" class="Symbol">=</a>  <a id="15308" href="../Lambda/#44067" class="InductiveConstructor">S</a> <a id="15310" href="../Properties/#15296" class="Bound">x≢y</a> <a id="15314" class="Symbol">(</a><a id="15315" href="../Properties/#15291" class="Bound">ρ</a> <a id="15317" href="../Properties/#15300" class="Bound">∋x</a><a id="15319" class="Symbol">)</a>
</pre>
<p>Let <code>ρ</code> be the name of the map that takes evidence that <code>x</code> appears in <code>Γ</code> to evidence that <code>x</code> appears in <code>Δ</code>. The proof is by case analysis of the evidence that <code>x</code> appears in the extended map <code>Γ , y ⦂ B</code>:</p>
<ul>
<li><p>If <code>x</code> is the same as <code>y</code>, we used <code>Z</code> to access the last variable in the extended <code>Γ</code>; and can similarly use <code>Z</code> to access the last variable in the extended <code>Δ</code>.</p></li>
<li><p>If <code>x</code> differs from <code>y</code>, then we used <code>S</code> to skip over the last variable in the extended <code>Γ</code>, where <code>x≢y</code> is evidence that <code>x</code> and <code>y</code> differ, and <code>∋x</code> is the evidence that <code>x</code> appears in <code>Γ</code>; and we can similarly use <code>S</code> to skip over the last variable in the extended <code>Δ</code>, applying <code>ρ</code> to find the evidence that <code>x</code> appears in <code>Δ</code>.</p></li>
</ul>
With the extension lemma under our belts, it is straightforward to prove renaming preserves types:
<pre class="Agda"><a id="rename"></a><a id="16139" href="../Properties/#16139" class="Function">rename</a> <a id="16146" class="Symbol">:</a> <a id="16148" class="Symbol">∀</a> <a id="16150" class="Symbol">{</a><a id="16151" href="../Properties/#16151" class="Bound">Γ</a> <a id="16153" href="../Properties/#16153" class="Bound">Δ</a><a id="16154" class="Symbol">}</a>
  <a id="16158" class="Symbol">→</a> <a id="16160" class="Symbol">(∀</a> <a id="16163" class="Symbol">{</a><a id="16164" href="../Properties/#16164" class="Bound">x</a> <a id="16166" href="../Properties/#16166" class="Bound">A</a><a id="16167" class="Symbol">}</a> <a id="16169" class="Symbol">→</a> <a id="16171" href="../Properties/#16151" class="Bound">Γ</a> <a id="16173" href="../Lambda/#43958" class="Datatype Operator">∋</a> <a id="16175" href="../Properties/#16164" class="Bound">x</a> <a id="16177" href="../Lambda/#43958" class="Datatype Operator">⦂</a> <a id="16179" href="../Properties/#16166" class="Bound">A</a> <a id="16181" class="Symbol">→</a> <a id="16183" href="../Properties/#16153" class="Bound">Δ</a> <a id="16185" href="../Lambda/#43958" class="Datatype Operator">∋</a> <a id="16187" href="../Properties/#16164" class="Bound">x</a> <a id="16189" href="../Lambda/#43958" class="Datatype Operator">⦂</a> <a id="16191" href="../Properties/#16166" class="Bound">A</a><a id="16192" class="Symbol">)</a>
    <a id="16198" class="Comment">----------------------------------</a>
  <a id="16235" class="Symbol">→</a> <a id="16237" class="Symbol">(∀</a> <a id="16240" class="Symbol">{</a><a id="16241" href="../Properties/#16241" class="Bound">M</a> <a id="16243" href="../Properties/#16243" class="Bound">A</a><a id="16244" class="Symbol">}</a> <a id="16246" class="Symbol">→</a> <a id="16248" href="../Properties/#16151" class="Bound">Γ</a> <a id="16250" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="16252" href="../Properties/#16241" class="Bound">M</a> <a id="16254" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="16256" href="../Properties/#16243" class="Bound">A</a> <a id="16258" class="Symbol">→</a> <a id="16260" href="../Properties/#16153" class="Bound">Δ</a> <a id="16262" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="16264" href="../Properties/#16241" class="Bound">M</a> <a id="16266" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="16268" href="../Properties/#16243" class="Bound">A</a><a id="16269" class="Symbol">)</a>
<a id="16271" href="../Properties/#16139" class="Function">rename</a> <a id="16278" href="../Properties/#16278" class="Bound">ρ</a> <a id="16280" class="Symbol">(</a><a id="16281" href="../Lambda/#46084" class="InductiveConstructor">⊢`</a> <a id="16284" href="../Properties/#16284" class="Bound">∋w</a><a id="16286" class="Symbol">)</a>           <a id="16298" class="Symbol">=</a>  <a id="16301" href="../Lambda/#46084" class="InductiveConstructor">⊢`</a> <a id="16304" class="Symbol">(</a><a id="16305" href="../Properties/#16278" class="Bound">ρ</a> <a id="16307" href="../Properties/#16284" class="Bound">∋w</a><a id="16309" class="Symbol">)</a>
<a id="16311" href="../Properties/#16139" class="Function">rename</a> <a id="16318" href="../Properties/#16318" class="Bound">ρ</a> <a id="16320" class="Symbol">(</a><a id="16321" href="../Lambda/#46163" class="InductiveConstructor">⊢ƛ</a> <a id="16324" href="../Properties/#16324" class="Bound">⊢N</a><a id="16326" class="Symbol">)</a>           <a id="16338" class="Symbol">=</a>  <a id="16341" href="../Lambda/#46163" class="InductiveConstructor">⊢ƛ</a> <a id="16344" class="Symbol">(</a><a id="16345" href="../Properties/#16139" class="Function">rename</a> <a id="16352" class="Symbol">(</a><a id="16353" href="../Properties/#15076" class="Function">ext</a> <a id="16357" href="../Properties/#16318" class="Bound">ρ</a><a id="16358" class="Symbol">)</a> <a id="16360" href="../Properties/#16324" class="Bound">⊢N</a><a id="16362" class="Symbol">)</a>
<a id="16364" href="../Properties/#16139" class="Function">rename</a> <a id="16371" href="../Properties/#16371" class="Bound">ρ</a> <a id="16373" class="Symbol">(</a><a id="16374" href="../Properties/#16374" class="Bound">⊢L</a> <a id="16377" href="../Lambda/#46270" class="InductiveConstructor Operator">·</a> <a id="16379" href="../Properties/#16379" class="Bound">⊢M</a><a id="16381" class="Symbol">)</a>         <a id="16391" class="Symbol">=</a>  <a id="16394" class="Symbol">(</a><a id="16395" href="../Properties/#16139" class="Function">rename</a> <a id="16402" href="../Properties/#16371" class="Bound">ρ</a> <a id="16404" href="../Properties/#16374" class="Bound">⊢L</a><a id="16406" class="Symbol">)</a> <a id="16408" href="../Lambda/#46270" class="InductiveConstructor Operator">·</a> <a id="16410" class="Symbol">(</a><a id="16411" href="../Properties/#16139" class="Function">rename</a> <a id="16418" href="../Properties/#16371" class="Bound">ρ</a> <a id="16420" href="../Properties/#16379" class="Bound">⊢M</a><a id="16422" class="Symbol">)</a>
<a id="16424" href="../Properties/#16139" class="Function">rename</a> <a id="16431" href="../Properties/#16431" class="Bound">ρ</a> <a id="16433" href="../Lambda/#46379" class="InductiveConstructor">⊢zero</a>             <a id="16451" class="Symbol">=</a>  <a id="16454" href="../Lambda/#46379" class="InductiveConstructor">⊢zero</a>
<a id="16460" href="../Properties/#16139" class="Function">rename</a> <a id="16467" href="../Properties/#16467" class="Bound">ρ</a> <a id="16469" class="Symbol">(</a><a id="16470" href="../Lambda/#46448" class="InductiveConstructor">⊢suc</a> <a id="16475" href="../Properties/#16475" class="Bound">⊢M</a><a id="16477" class="Symbol">)</a>         <a id="16487" class="Symbol">=</a>  <a id="16490" href="../Lambda/#46448" class="InductiveConstructor">⊢suc</a> <a id="16495" class="Symbol">(</a><a id="16496" href="../Properties/#16139" class="Function">rename</a> <a id="16503" href="../Properties/#16467" class="Bound">ρ</a> <a id="16505" href="../Properties/#16475" class="Bound">⊢M</a><a id="16507" class="Symbol">)</a>
<a id="16509" href="../Properties/#16139" class="Function">rename</a> <a id="16516" href="../Properties/#16516" class="Bound">ρ</a> <a id="16518" class="Symbol">(</a><a id="16519" href="../Lambda/#46536" class="InductiveConstructor">⊢case</a> <a id="16525" href="../Properties/#16525" class="Bound">⊢L</a> <a id="16528" href="../Properties/#16528" class="Bound">⊢M</a> <a id="16531" href="../Properties/#16531" class="Bound">⊢N</a><a id="16533" class="Symbol">)</a>  <a id="16536" class="Symbol">=</a>  <a id="16539" href="../Lambda/#46536" class="InductiveConstructor">⊢case</a> <a id="16545" class="Symbol">(</a><a id="16546" href="../Properties/#16139" class="Function">rename</a> <a id="16553" href="../Properties/#16516" class="Bound">ρ</a> <a id="16555" href="../Properties/#16525" class="Bound">⊢L</a><a id="16557" class="Symbol">)</a> <a id="16559" class="Symbol">(</a><a id="16560" href="../Properties/#16139" class="Function">rename</a> <a id="16567" href="../Properties/#16516" class="Bound">ρ</a> <a id="16569" href="../Properties/#16528" class="Bound">⊢M</a><a id="16571" class="Symbol">)</a> <a id="16573" class="Symbol">(</a><a id="16574" href="../Properties/#16139" class="Function">rename</a> <a id="16581" class="Symbol">(</a><a id="16582" href="../Properties/#15076" class="Function">ext</a> <a id="16586" href="../Properties/#16516" class="Bound">ρ</a><a id="16587" class="Symbol">)</a> <a id="16589" href="../Properties/#16531" class="Bound">⊢N</a><a id="16591" class="Symbol">)</a>
<a id="16593" href="../Properties/#16139" class="Function">rename</a> <a id="16600" href="../Properties/#16600" class="Bound">ρ</a> <a id="16602" class="Symbol">(</a><a id="16603" href="../Lambda/#46708" class="InductiveConstructor">⊢μ</a> <a id="16606" href="../Properties/#16606" class="Bound">⊢M</a><a id="16608" class="Symbol">)</a>           <a id="16620" class="Symbol">=</a>  <a id="16623" href="../Lambda/#46708" class="InductiveConstructor">⊢μ</a> <a id="16626" class="Symbol">(</a><a id="16627" href="../Properties/#16139" class="Function">rename</a> <a id="16634" class="Symbol">(</a><a id="16635" href="../Properties/#15076" class="Function">ext</a> <a id="16639" href="../Properties/#16600" class="Bound">ρ</a><a id="16640" class="Symbol">)</a> <a id="16642" href="../Properties/#16606" class="Bound">⊢M</a><a id="16644" class="Symbol">)</a>
</pre>
<p>As before, let <code>ρ</code> be the name of the map that takes evidence that <code>x</code> appears in <code>Γ</code> to evidence that <code>x</code> appears in <code>Δ</code>. We induct on the evidence that <code>M</code> is well typed in <code>Γ</code>. Let’s unpack the first three cases:</p>
<ul>
<li><p>If the term is a variable, then applying <code>ρ</code> to the evidence that the variable appears in <code>Γ</code> yields the corresponding evidence that the variable appears in <code>Δ</code>.</p></li>
<li><p>If the term is a lambda abstraction, use the previous lemma to extend the map <code>ρ</code> suitably and use induction to rename the body of the abstraction.</p></li>
<li><p>If the term is an application, use induction to rename both the function and the argument.</p></li>
</ul>
<p>The remaining cases are similar, using induction for each subterm, and extending the map whenever the construct introduces a bound variable.</p>
<p>The induction is over the derivation that the term is well typed, so extending the context doesn’t invalidate the inductive hypothesis. Equivalently, the recursion terminates because the second argument always grows smaller, even though the first argument sometimes grows larger.</p>
<p>We have three important corollaries, each proved by constructing a suitable map between contexts.</p>
First, a closed term can be weakened to any context:
<pre class="Agda"><a id="weaken"></a><a id="17858" href="../Properties/#17858" class="Function">weaken</a> <a id="17865" class="Symbol">:</a> <a id="17867" class="Symbol">∀</a> <a id="17869" class="Symbol">{</a><a id="17870" href="../Properties/#17870" class="Bound">Γ</a> <a id="17872" href="../Properties/#17872" class="Bound">M</a> <a id="17874" href="../Properties/#17874" class="Bound">A</a><a id="17875" class="Symbol">}</a>
  <a id="17879" class="Symbol">→</a> <a id="17881" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="17883" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="17885" href="../Properties/#17872" class="Bound">M</a> <a id="17887" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="17889" href="../Properties/#17874" class="Bound">A</a>
    <a id="17895" class="Comment">----------</a>
  <a id="17908" class="Symbol">→</a> <a id="17910" href="../Properties/#17870" class="Bound">Γ</a> <a id="17912" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="17914" href="../Properties/#17872" class="Bound">M</a> <a id="17916" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="17918" href="../Properties/#17874" class="Bound">A</a>
<a id="17920" href="../Properties/#17858" class="Function">weaken</a> <a id="17927" class="Symbol">{</a><a id="17928" href="../Properties/#17928" class="Bound">Γ</a><a id="17929" class="Symbol">}</a> <a id="17931" href="../Properties/#17931" class="Bound">⊢M</a> <a id="17934" class="Symbol">=</a> <a id="17936" href="../Properties/#16139" class="Function">rename</a> <a id="17943" href="../Properties/#17958" class="Function">ρ</a> <a id="17945" href="../Properties/#17931" class="Bound">⊢M</a>
  <a id="17950" class="Keyword">where</a>
  <a id="17958" href="../Properties/#17958" class="Function">ρ</a> <a id="17960" class="Symbol">:</a> <a id="17962" class="Symbol">∀</a> <a id="17964" class="Symbol">{</a><a id="17965" href="../Properties/#17965" class="Bound">z</a> <a id="17967" href="../Properties/#17967" class="Bound">C</a><a id="17968" class="Symbol">}</a>
    <a id="17974" class="Symbol">→</a> <a id="17976" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="17978" href="../Lambda/#43958" class="Datatype Operator">∋</a> <a id="17980" href="../Properties/#17965" class="Bound">z</a> <a id="17982" href="../Lambda/#43958" class="Datatype Operator">⦂</a> <a id="17984" href="../Properties/#17967" class="Bound">C</a>
      <a id="17992" class="Comment">---------</a>
    <a id="18006" class="Symbol">→</a> <a id="18008" href="../Properties/#17928" class="Bound">Γ</a> <a id="18010" href="../Lambda/#43958" class="Datatype Operator">∋</a> <a id="18012" href="../Properties/#17965" class="Bound">z</a> <a id="18014" href="../Lambda/#43958" class="Datatype Operator">⦂</a> <a id="18016" href="../Properties/#17967" class="Bound">C</a>
  <a id="18020" href="../Properties/#17958" class="Function">ρ</a> <a id="18022" class="Symbol">()</a>
</pre>
<p>Here the map <code>ρ</code> is trivial, since there are no possible arguments in the empty context <code>∅</code>.</p>
Second, if the last two variables in a context are equal then we can drop the shadowed one:
<pre class="Agda"><a id="drop"></a><a id="18219" href="../Properties/#18219" class="Function">drop</a> <a id="18224" class="Symbol">:</a> <a id="18226" class="Symbol">∀</a> <a id="18228" class="Symbol">{</a><a id="18229" href="../Properties/#18229" class="Bound">Γ</a> <a id="18231" href="../Properties/#18231" class="Bound">x</a> <a id="18233" href="../Properties/#18233" class="Bound">M</a> <a id="18235" href="../Properties/#18235" class="Bound">A</a> <a id="18237" href="../Properties/#18237" class="Bound">B</a> <a id="18239" href="../Properties/#18239" class="Bound">C</a><a id="18240" class="Symbol">}</a>
  <a id="18244" class="Symbol">→</a> <a id="18246" href="../Properties/#18229" class="Bound">Γ</a> <a id="18248" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="18250" href="../Properties/#18231" class="Bound">x</a> <a id="18252" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="18254" href="../Properties/#18235" class="Bound">A</a> <a id="18256" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="18258" href="../Properties/#18231" class="Bound">x</a> <a id="18260" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="18262" href="../Properties/#18237" class="Bound">B</a> <a id="18264" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="18266" href="../Properties/#18233" class="Bound">M</a> <a id="18268" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="18270" href="../Properties/#18239" class="Bound">C</a>
    <a id="18276" class="Comment">--------------------------</a>
  <a id="18305" class="Symbol">→</a> <a id="18307" href="../Properties/#18229" class="Bound">Γ</a> <a id="18309" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="18311" href="../Properties/#18231" class="Bound">x</a> <a id="18313" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="18315" href="../Properties/#18237" class="Bound">B</a> <a id="18317" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="18319" href="../Properties/#18233" class="Bound">M</a> <a id="18321" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="18323" href="../Properties/#18239" class="Bound">C</a>
<a id="18325" href="../Properties/#18219" class="Function">drop</a> <a id="18330" class="Symbol">{</a><a id="18331" href="../Properties/#18331" class="Bound">Γ</a><a id="18332" class="Symbol">}</a> <a id="18334" class="Symbol">{</a><a id="18335" href="../Properties/#18335" class="Bound">x</a><a id="18336" class="Symbol">}</a> <a id="18338" class="Symbol">{</a><a id="18339" href="../Properties/#18339" class="Bound">M</a><a id="18340" class="Symbol">}</a> <a id="18342" class="Symbol">{</a><a id="18343" href="../Properties/#18343" class="Bound">A</a><a id="18344" class="Symbol">}</a> <a id="18346" class="Symbol">{</a><a id="18347" href="../Properties/#18347" class="Bound">B</a><a id="18348" class="Symbol">}</a> <a id="18350" class="Symbol">{</a><a id="18351" href="../Properties/#18351" class="Bound">C</a><a id="18352" class="Symbol">}</a> <a id="18354" href="../Properties/#18354" class="Bound">⊢M</a> <a id="18357" class="Symbol">=</a> <a id="18359" href="../Properties/#16139" class="Function">rename</a> <a id="18366" href="../Properties/#18381" class="Function">ρ</a> <a id="18368" href="../Properties/#18354" class="Bound">⊢M</a>
  <a id="18373" class="Keyword">where</a>
  <a id="18381" href="../Properties/#18381" class="Function">ρ</a> <a id="18383" class="Symbol">:</a> <a id="18385" class="Symbol">∀</a> <a id="18387" class="Symbol">{</a><a id="18388" href="../Properties/#18388" class="Bound">z</a> <a id="18390" href="../Properties/#18390" class="Bound">C</a><a id="18391" class="Symbol">}</a>
    <a id="18397" class="Symbol">→</a> <a id="18399" href="../Properties/#18331" class="Bound">Γ</a> <a id="18401" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="18403" href="../Properties/#18335" class="Bound">x</a> <a id="18405" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="18407" href="../Properties/#18343" class="Bound">A</a> <a id="18409" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="18411" href="../Properties/#18335" class="Bound">x</a> <a id="18413" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="18415" href="../Properties/#18347" class="Bound">B</a> <a id="18417" href="../Lambda/#43958" class="Datatype Operator">∋</a> <a id="18419" href="../Properties/#18388" class="Bound">z</a> <a id="18421" href="../Lambda/#43958" class="Datatype Operator">⦂</a> <a id="18423" href="../Properties/#18390" class="Bound">C</a>
      <a id="18431" class="Comment">-------------------------</a>
    <a id="18461" class="Symbol">→</a> <a id="18463" href="../Properties/#18331" class="Bound">Γ</a> <a id="18465" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="18467" href="../Properties/#18335" class="Bound">x</a> <a id="18469" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="18471" href="../Properties/#18347" class="Bound">B</a> <a id="18473" href="../Lambda/#43958" class="Datatype Operator">∋</a> <a id="18475" href="../Properties/#18388" class="Bound">z</a> <a id="18477" href="../Lambda/#43958" class="Datatype Operator">⦂</a> <a id="18479" href="../Properties/#18390" class="Bound">C</a>
  <a id="18483" href="../Properties/#18381" class="Function">ρ</a> <a id="18485" href="../Lambda/#44001" class="InductiveConstructor">Z</a>                 <a id="18503" class="Symbol">=</a>  <a id="18506" href="../Lambda/#44001" class="InductiveConstructor">Z</a>
  <a id="18510" href="../Properties/#18381" class="Function">ρ</a> <a id="18512" class="Symbol">(</a><a id="18513" href="../Lambda/#44067" class="InductiveConstructor">S</a> <a id="18515" href="../Properties/#18515" class="Bound">x≢x</a> <a id="18519" href="../Lambda/#44001" class="InductiveConstructor">Z</a><a id="18520" class="Symbol">)</a>         <a id="18530" class="Symbol">=</a>  <a id="18533" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="18540" class="Symbol">(</a><a id="18541" href="../Properties/#18515" class="Bound">x≢x</a> <a id="18545" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="18549" class="Symbol">)</a>
  <a id="18553" href="../Properties/#18381" class="Function">ρ</a> <a id="18555" class="Symbol">(</a><a id="18556" href="../Lambda/#44067" class="InductiveConstructor">S</a> <a id="18558" href="../Properties/#18558" class="Bound">z≢x</a> <a id="18562" class="Symbol">(</a><a id="18563" href="../Lambda/#44067" class="InductiveConstructor">S</a> <a id="18565" class="Symbol">_</a> <a id="18567" href="../Properties/#18567" class="Bound">∋z</a><a id="18569" class="Symbol">))</a>  <a id="18573" class="Symbol">=</a>  <a id="18576" href="../Lambda/#44067" class="InductiveConstructor">S</a> <a id="18578" href="../Properties/#18558" class="Bound">z≢x</a> <a id="18582" href="../Properties/#18567" class="Bound">∋z</a>
</pre>
<p>Here map <code>ρ</code> can never be invoked on the inner occurrence of <code>x</code> since it is masked by the outer occurrence. Skipping over the <code>x</code> in the first position can only happen if the variable looked for differs from <code>x</code> (the evidence for which is <code>x≢x</code> or <code>z≢x</code>) but if the variable is found in the second position, which also contains <code>x</code>, this leads to a contradiction (evidenced by <code>x≢x refl</code>).</p>
Third, if the last two variables in a context differ then we can swap them:
<pre class="Agda"><a id="swap"></a><a id="19062" href="../Properties/#19062" class="Function">swap</a> <a id="19067" class="Symbol">:</a> <a id="19069" class="Symbol">∀</a> <a id="19071" class="Symbol">{</a><a id="19072" href="../Properties/#19072" class="Bound">Γ</a> <a id="19074" href="../Properties/#19074" class="Bound">x</a> <a id="19076" href="../Properties/#19076" class="Bound">y</a> <a id="19078" href="../Properties/#19078" class="Bound">M</a> <a id="19080" href="../Properties/#19080" class="Bound">A</a> <a id="19082" href="../Properties/#19082" class="Bound">B</a> <a id="19084" href="../Properties/#19084" class="Bound">C</a><a id="19085" class="Symbol">}</a>
  <a id="19089" class="Symbol">→</a> <a id="19091" href="../Properties/#19074" class="Bound">x</a> <a id="19093" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#840" class="Function Operator">≢</a> <a id="19095" href="../Properties/#19076" class="Bound">y</a>
  <a id="19099" class="Symbol">→</a> <a id="19101" href="../Properties/#19072" class="Bound">Γ</a> <a id="19103" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="19105" href="../Properties/#19076" class="Bound">y</a> <a id="19107" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="19109" href="../Properties/#19082" class="Bound">B</a> <a id="19111" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="19113" href="../Properties/#19074" class="Bound">x</a> <a id="19115" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="19117" href="../Properties/#19080" class="Bound">A</a> <a id="19119" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="19121" href="../Properties/#19078" class="Bound">M</a> <a id="19123" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="19125" href="../Properties/#19084" class="Bound">C</a>
    <a id="19131" class="Comment">--------------------------</a>
  <a id="19160" class="Symbol">→</a> <a id="19162" href="../Properties/#19072" class="Bound">Γ</a> <a id="19164" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="19166" href="../Properties/#19074" class="Bound">x</a> <a id="19168" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="19170" href="../Properties/#19080" class="Bound">A</a> <a id="19172" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="19174" href="../Properties/#19076" class="Bound">y</a> <a id="19176" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="19178" href="../Properties/#19082" class="Bound">B</a> <a id="19180" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="19182" href="../Properties/#19078" class="Bound">M</a> <a id="19184" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="19186" href="../Properties/#19084" class="Bound">C</a>
<a id="19188" href="../Properties/#19062" class="Function">swap</a> <a id="19193" class="Symbol">{</a><a id="19194" href="../Properties/#19194" class="Bound">Γ</a><a id="19195" class="Symbol">}</a> <a id="19197" class="Symbol">{</a><a id="19198" href="../Properties/#19198" class="Bound">x</a><a id="19199" class="Symbol">}</a> <a id="19201" class="Symbol">{</a><a id="19202" href="../Properties/#19202" class="Bound">y</a><a id="19203" class="Symbol">}</a> <a id="19205" class="Symbol">{</a><a id="19206" href="../Properties/#19206" class="Bound">M</a><a id="19207" class="Symbol">}</a> <a id="19209" class="Symbol">{</a><a id="19210" href="../Properties/#19210" class="Bound">A</a><a id="19211" class="Symbol">}</a> <a id="19213" class="Symbol">{</a><a id="19214" href="../Properties/#19214" class="Bound">B</a><a id="19215" class="Symbol">}</a> <a id="19217" class="Symbol">{</a><a id="19218" href="../Properties/#19218" class="Bound">C</a><a id="19219" class="Symbol">}</a> <a id="19221" href="../Properties/#19221" class="Bound">x≢y</a> <a id="19225" href="../Properties/#19225" class="Bound">⊢M</a> <a id="19228" class="Symbol">=</a> <a id="19230" href="../Properties/#16139" class="Function">rename</a> <a id="19237" href="../Properties/#19252" class="Function">ρ</a> <a id="19239" href="../Properties/#19225" class="Bound">⊢M</a>
  <a id="19244" class="Keyword">where</a>
  <a id="19252" href="../Properties/#19252" class="Function">ρ</a> <a id="19254" class="Symbol">:</a> <a id="19256" class="Symbol">∀</a> <a id="19258" class="Symbol">{</a><a id="19259" href="../Properties/#19259" class="Bound">z</a> <a id="19261" href="../Properties/#19261" class="Bound">C</a><a id="19262" class="Symbol">}</a>
    <a id="19268" class="Symbol">→</a> <a id="19270" href="../Properties/#19194" class="Bound">Γ</a> <a id="19272" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="19274" href="../Properties/#19202" class="Bound">y</a> <a id="19276" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="19278" href="../Properties/#19214" class="Bound">B</a> <a id="19280" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="19282" href="../Properties/#19198" class="Bound">x</a> <a id="19284" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="19286" href="../Properties/#19210" class="Bound">A</a> <a id="19288" href="../Lambda/#43958" class="Datatype Operator">∋</a> <a id="19290" href="../Properties/#19259" class="Bound">z</a> <a id="19292" href="../Lambda/#43958" class="Datatype Operator">⦂</a> <a id="19294" href="../Properties/#19261" class="Bound">C</a>
      <a id="19302" class="Comment">--------------------------</a>
    <a id="19333" class="Symbol">→</a> <a id="19335" href="../Properties/#19194" class="Bound">Γ</a> <a id="19337" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="19339" href="../Properties/#19198" class="Bound">x</a> <a id="19341" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="19343" href="../Properties/#19210" class="Bound">A</a> <a id="19345" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="19347" href="../Properties/#19202" class="Bound">y</a> <a id="19349" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="19351" href="../Properties/#19214" class="Bound">B</a> <a id="19353" href="../Lambda/#43958" class="Datatype Operator">∋</a> <a id="19355" href="../Properties/#19259" class="Bound">z</a> <a id="19357" href="../Lambda/#43958" class="Datatype Operator">⦂</a> <a id="19359" href="../Properties/#19261" class="Bound">C</a>
  <a id="19363" href="../Properties/#19252" class="Function">ρ</a> <a id="19365" href="../Lambda/#44001" class="InductiveConstructor">Z</a>                   <a id="19385" class="Symbol">=</a>  <a id="19388" href="../Lambda/#44067" class="InductiveConstructor">S</a> <a id="19390" href="../Properties/#19221" class="Bound">x≢y</a> <a id="19394" href="../Lambda/#44001" class="InductiveConstructor">Z</a>
  <a id="19398" href="../Properties/#19252" class="Function">ρ</a> <a id="19400" class="Symbol">(</a><a id="19401" href="../Lambda/#44067" class="InductiveConstructor">S</a> <a id="19403" href="../Properties/#19403" class="Bound">z≢x</a> <a id="19407" href="../Lambda/#44001" class="InductiveConstructor">Z</a><a id="19408" class="Symbol">)</a>           <a id="19420" class="Symbol">=</a>  <a id="19423" href="../Lambda/#44001" class="InductiveConstructor">Z</a>
  <a id="19427" href="../Properties/#19252" class="Function">ρ</a> <a id="19429" class="Symbol">(</a><a id="19430" href="../Lambda/#44067" class="InductiveConstructor">S</a> <a id="19432" href="../Properties/#19432" class="Bound">z≢x</a> <a id="19436" class="Symbol">(</a><a id="19437" href="../Lambda/#44067" class="InductiveConstructor">S</a> <a id="19439" href="../Properties/#19439" class="Bound">z≢y</a> <a id="19443" href="../Properties/#19443" class="Bound">∋z</a><a id="19445" class="Symbol">))</a>  <a id="19449" class="Symbol">=</a>  <a id="19452" href="../Lambda/#44067" class="InductiveConstructor">S</a> <a id="19454" href="../Properties/#19439" class="Bound">z≢y</a> <a id="19458" class="Symbol">(</a><a id="19459" href="../Lambda/#44067" class="InductiveConstructor">S</a> <a id="19461" href="../Properties/#19432" class="Bound">z≢x</a> <a id="19465" href="../Properties/#19443" class="Bound">∋z</a><a id="19467" class="Symbol">)</a>
</pre>
<p>Here the renaming map takes a variable at the end into a variable one from the end, and vice versa. The first line is responsible for moving <code>x</code> from a position at the end to a position one from the end with <code>y</code> at the end, and requires the provided evidence that <code>x ≢ y</code>.</p>
<h2 id="substitution">Substitution</h2>
<p>The key to preservation – and the trickiest bit of the proof – is the lemma establishing that substitution preserves types.</p>
<p>Recall that in order to avoid renaming bound variables, substitution is restricted to be by closed terms only. This restriction was not enforced by our definition of substitution, but it is captured by our lemma to assert that substitution preserves typing.</p>
<p>Our concern is with reducing closed terms, which means that when we apply <code>β</code> reduction, the term substituted in contains a single free variable (the bound variable of the lambda abstraction, or similarly for case or fixpoint). However, substitution is defined by recursion, and as we descend into terms with bound variables the context grows. So for the induction to go through, we require an arbitrary context <code>Γ</code>, as in the statement of the lemma.</p>
Here is the formal statement and proof that substitution preserves types:
<pre class="Agda"><a id="subst"></a><a id="20681" href="../Properties/#20681" class="Function">subst</a> <a id="20687" class="Symbol">:</a> <a id="20689" class="Symbol">∀</a> <a id="20691" class="Symbol">{</a><a id="20692" href="../Properties/#20692" class="Bound">Γ</a> <a id="20694" href="../Properties/#20694" class="Bound">x</a> <a id="20696" href="../Properties/#20696" class="Bound">N</a> <a id="20698" href="../Properties/#20698" class="Bound">V</a> <a id="20700" href="../Properties/#20700" class="Bound">A</a> <a id="20702" href="../Properties/#20702" class="Bound">B</a><a id="20703" class="Symbol">}</a>
  <a id="20707" class="Symbol">→</a> <a id="20709" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="20711" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="20713" href="../Properties/#20698" class="Bound">V</a> <a id="20715" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="20717" href="../Properties/#20700" class="Bound">A</a>
  <a id="20721" class="Symbol">→</a> <a id="20723" href="../Properties/#20692" class="Bound">Γ</a> <a id="20725" href="../Lambda/#42171" class="InductiveConstructor Operator">,</a> <a id="20727" href="../Properties/#20694" class="Bound">x</a> <a id="20729" href="../Lambda/#42171" class="InductiveConstructor Operator">⦂</a> <a id="20731" href="../Properties/#20700" class="Bound">A</a> <a id="20733" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="20735" href="../Properties/#20696" class="Bound">N</a> <a id="20737" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="20739" href="../Properties/#20702" class="Bound">B</a>
    <a id="20745" class="Comment">--------------------</a>
  <a id="20768" class="Symbol">→</a> <a id="20770" href="../Properties/#20692" class="Bound">Γ</a> <a id="20772" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="20774" href="../Properties/#20696" class="Bound">N</a> <a id="20776" href="../Lambda/#21999" class="Function Operator">[</a> <a id="20778" href="../Properties/#20694" class="Bound">x</a> <a id="20780" href="../Lambda/#21999" class="Function Operator">:=</a> <a id="20783" href="../Properties/#20698" class="Bound">V</a> <a id="20785" href="../Lambda/#21999" class="Function Operator">]</a> <a id="20787" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="20789" href="../Properties/#20702" class="Bound">B</a>
<a id="20791" href="../Properties/#20681" class="Function">subst</a> <a id="20797" class="Symbol">{</a><a id="20798" class="Argument">x</a> <a id="20800" class="Symbol">=</a> <a id="20802" href="../Properties/#20802" class="Bound">y</a><a id="20803" class="Symbol">}</a> <a id="20805" href="../Properties/#20805" class="Bound">⊢V</a> <a id="20808" class="Symbol">(</a><a id="20809" href="../Lambda/#46084" class="InductiveConstructor">⊢`</a> <a id="20812" class="Symbol">{</a><a id="20813" class="Argument">x</a> <a id="20815" class="Symbol">=</a> <a id="20817" href="../Properties/#20817" class="Bound">x</a><a id="20818" class="Symbol">}</a> <a id="20820" href="../Lambda/#44001" class="InductiveConstructor">Z</a><a id="20821" class="Symbol">)</a> <a id="20823" class="Keyword">with</a> <a id="20828" href="../Properties/#20817" class="Bound">x</a> <a id="20830" href="https://agda.github.io/agda-stdlib/v1.3/Data.String.Properties.html#2409" class="Function Operator">≟</a> <a id="20832" href="../Properties/#20802" class="Bound">y</a>
<a id="20834" class="Symbol">...</a> <a id="20838" class="Symbol">|</a> <a id="20840" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="20844" class="Symbol">_</a>           <a id="20856" class="Symbol">=</a>  <a id="20859" href="../Properties/#17858" class="Function">weaken</a> <a id="20866" class="Bound">⊢V</a>
<a id="20869" class="Symbol">...</a> <a id="20873" class="Symbol">|</a> <a id="20875" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a>  <a id="20879" href="../Properties/#20879" class="Bound">x≢y</a>         <a id="20891" class="Symbol">=</a>  <a id="20894" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="20901" class="Symbol">(</a><a id="20902" href="../Properties/#20879" class="Bound">x≢y</a> <a id="20906" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="20910" class="Symbol">)</a>
<a id="20912" href="../Properties/#20681" class="Function">subst</a> <a id="20918" class="Symbol">{</a><a id="20919" class="Argument">x</a> <a id="20921" class="Symbol">=</a> <a id="20923" href="../Properties/#20923" class="Bound">y</a><a id="20924" class="Symbol">}</a> <a id="20926" href="../Properties/#20926" class="Bound">⊢V</a> <a id="20929" class="Symbol">(</a><a id="20930" href="../Lambda/#46084" class="InductiveConstructor">⊢`</a> <a id="20933" class="Symbol">{</a><a id="20934" class="Argument">x</a> <a id="20936" class="Symbol">=</a> <a id="20938" href="../Properties/#20938" class="Bound">x</a><a id="20939" class="Symbol">}</a> <a id="20941" class="Symbol">(</a><a id="20942" href="../Lambda/#44067" class="InductiveConstructor">S</a> <a id="20944" href="../Properties/#20944" class="Bound">x≢y</a> <a id="20948" href="../Properties/#20948" class="Bound">∋x</a><a id="20950" class="Symbol">))</a> <a id="20953" class="Keyword">with</a> <a id="20958" href="../Properties/#20938" class="Bound">x</a> <a id="20960" href="https://agda.github.io/agda-stdlib/v1.3/Data.String.Properties.html#2409" class="Function Operator">≟</a> <a id="20962" href="../Properties/#20923" class="Bound">y</a>
<a id="20964" class="Symbol">...</a> <a id="20968" class="Symbol">|</a> <a id="20970" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="20974" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>        <a id="20986" class="Symbol">=</a>  <a id="20989" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="20996" class="Symbol">(</a><a id="20997" class="Bound">x≢y</a> <a id="21001" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="21005" class="Symbol">)</a>
<a id="21007" class="Symbol">...</a> <a id="21011" class="Symbol">|</a> <a id="21013" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a>  <a id="21017" class="Symbol">_</a>           <a id="21029" class="Symbol">=</a>  <a id="21032" href="../Lambda/#46084" class="InductiveConstructor">⊢`</a> <a id="21035" class="Bound">∋x</a>
<a id="21038" href="../Properties/#20681" class="Function">subst</a> <a id="21044" class="Symbol">{</a><a id="21045" class="Argument">x</a> <a id="21047" class="Symbol">=</a> <a id="21049" href="../Properties/#21049" class="Bound">y</a><a id="21050" class="Symbol">}</a> <a id="21052" href="../Properties/#21052" class="Bound">⊢V</a> <a id="21055" class="Symbol">(</a><a id="21056" href="../Lambda/#46163" class="InductiveConstructor">⊢ƛ</a> <a id="21059" class="Symbol">{</a><a id="21060" class="Argument">x</a> <a id="21062" class="Symbol">=</a> <a id="21064" href="../Properties/#21064" class="Bound">x</a><a id="21065" class="Symbol">}</a> <a id="21067" href="../Properties/#21067" class="Bound">⊢N</a><a id="21069" class="Symbol">)</a> <a id="21071" class="Keyword">with</a> <a id="21076" href="../Properties/#21064" class="Bound">x</a> <a id="21078" href="https://agda.github.io/agda-stdlib/v1.3/Data.String.Properties.html#2409" class="Function Operator">≟</a> <a id="21080" href="../Properties/#21049" class="Bound">y</a>
<a id="21082" class="Symbol">...</a> <a id="21086" class="Symbol">|</a> <a id="21088" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="21092" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>        <a id="21104" class="Symbol">=</a>  <a id="21107" href="../Lambda/#46163" class="InductiveConstructor">⊢ƛ</a> <a id="21110" class="Symbol">(</a><a id="21111" href="../Properties/#18219" class="Function">drop</a> <a id="21116" class="Bound">⊢N</a><a id="21118" class="Symbol">)</a>
<a id="21120" class="Symbol">...</a> <a id="21124" class="Symbol">|</a> <a id="21126" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a>  <a id="21130" href="../Properties/#21130" class="Bound">x≢y</a>         <a id="21142" class="Symbol">=</a>  <a id="21145" href="../Lambda/#46163" class="InductiveConstructor">⊢ƛ</a> <a id="21148" class="Symbol">(</a><a id="21149" href="../Properties/#20681" class="Function">subst</a> <a id="21155" class="Bound">⊢V</a> <a id="21158" class="Symbol">(</a><a id="21159" href="../Properties/#19062" class="Function">swap</a> <a id="21164" href="../Properties/#21130" class="Bound">x≢y</a> <a id="21168" class="Bound">⊢N</a><a id="21170" class="Symbol">))</a>
<a id="21173" href="../Properties/#20681" class="Function">subst</a> <a id="21179" href="../Properties/#21179" class="Bound">⊢V</a> <a id="21182" class="Symbol">(</a><a id="21183" href="../Properties/#21183" class="Bound">⊢L</a> <a id="21186" href="../Lambda/#46270" class="InductiveConstructor Operator">·</a> <a id="21188" href="../Properties/#21188" class="Bound">⊢M</a><a id="21190" class="Symbol">)</a>    <a id="21195" class="Symbol">=</a>  <a id="21198" class="Symbol">(</a><a id="21199" href="../Properties/#20681" class="Function">subst</a> <a id="21205" href="../Properties/#21179" class="Bound">⊢V</a> <a id="21208" href="../Properties/#21183" class="Bound">⊢L</a><a id="21210" class="Symbol">)</a> <a id="21212" href="../Lambda/#46270" class="InductiveConstructor Operator">·</a> <a id="21214" class="Symbol">(</a><a id="21215" href="../Properties/#20681" class="Function">subst</a> <a id="21221" href="../Properties/#21179" class="Bound">⊢V</a> <a id="21224" href="../Properties/#21188" class="Bound">⊢M</a><a id="21226" class="Symbol">)</a>
<a id="21228" href="../Properties/#20681" class="Function">subst</a> <a id="21234" href="../Properties/#21234" class="Bound">⊢V</a> <a id="21237" href="../Lambda/#46379" class="InductiveConstructor">⊢zero</a>        <a id="21250" class="Symbol">=</a>  <a id="21253" href="../Lambda/#46379" class="InductiveConstructor">⊢zero</a>
<a id="21259" href="../Properties/#20681" class="Function">subst</a> <a id="21265" href="../Properties/#21265" class="Bound">⊢V</a> <a id="21268" class="Symbol">(</a><a id="21269" href="../Lambda/#46448" class="InductiveConstructor">⊢suc</a> <a id="21274" href="../Properties/#21274" class="Bound">⊢M</a><a id="21276" class="Symbol">)</a>    <a id="21281" class="Symbol">=</a>  <a id="21284" href="../Lambda/#46448" class="InductiveConstructor">⊢suc</a> <a id="21289" class="Symbol">(</a><a id="21290" href="../Properties/#20681" class="Function">subst</a> <a id="21296" href="../Properties/#21265" class="Bound">⊢V</a> <a id="21299" href="../Properties/#21274" class="Bound">⊢M</a><a id="21301" class="Symbol">)</a>
<a id="21303" href="../Properties/#20681" class="Function">subst</a> <a id="21309" class="Symbol">{</a><a id="21310" class="Argument">x</a> <a id="21312" class="Symbol">=</a> <a id="21314" href="../Properties/#21314" class="Bound">y</a><a id="21315" class="Symbol">}</a> <a id="21317" href="../Properties/#21317" class="Bound">⊢V</a> <a id="21320" class="Symbol">(</a><a id="21321" href="../Lambda/#46536" class="InductiveConstructor">⊢case</a> <a id="21327" class="Symbol">{</a><a id="21328" class="Argument">x</a> <a id="21330" class="Symbol">=</a> <a id="21332" href="../Properties/#21332" class="Bound">x</a><a id="21333" class="Symbol">}</a> <a id="21335" href="../Properties/#21335" class="Bound">⊢L</a> <a id="21338" href="../Properties/#21338" class="Bound">⊢M</a> <a id="21341" href="../Properties/#21341" class="Bound">⊢N</a><a id="21343" class="Symbol">)</a> <a id="21345" class="Keyword">with</a> <a id="21350" href="../Properties/#21332" class="Bound">x</a> <a id="21352" href="https://agda.github.io/agda-stdlib/v1.3/Data.String.Properties.html#2409" class="Function Operator">≟</a> <a id="21354" href="../Properties/#21314" class="Bound">y</a>
<a id="21356" class="Symbol">...</a> <a id="21360" class="Symbol">|</a> <a id="21362" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="21366" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>        <a id="21378" class="Symbol">=</a>  <a id="21381" href="../Lambda/#46536" class="InductiveConstructor">⊢case</a> <a id="21387" class="Symbol">(</a><a id="21388" href="../Properties/#20681" class="Function">subst</a> <a id="21394" class="Bound">⊢V</a> <a id="21397" class="Bound">⊢L</a><a id="21399" class="Symbol">)</a> <a id="21401" class="Symbol">(</a><a id="21402" href="../Properties/#20681" class="Function">subst</a> <a id="21408" class="Bound">⊢V</a> <a id="21411" class="Bound">⊢M</a><a id="21413" class="Symbol">)</a> <a id="21415" class="Symbol">(</a><a id="21416" href="../Properties/#18219" class="Function">drop</a> <a id="21421" class="Bound">⊢N</a><a id="21423" class="Symbol">)</a>
<a id="21425" class="Symbol">...</a> <a id="21429" class="Symbol">|</a> <a id="21431" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a>  <a id="21435" href="../Properties/#21435" class="Bound">x≢y</a>         <a id="21447" class="Symbol">=</a>  <a id="21450" href="../Lambda/#46536" class="InductiveConstructor">⊢case</a> <a id="21456" class="Symbol">(</a><a id="21457" href="../Properties/#20681" class="Function">subst</a> <a id="21463" class="Bound">⊢V</a> <a id="21466" class="Bound">⊢L</a><a id="21468" class="Symbol">)</a> <a id="21470" class="Symbol">(</a><a id="21471" href="../Properties/#20681" class="Function">subst</a> <a id="21477" class="Bound">⊢V</a> <a id="21480" class="Bound">⊢M</a><a id="21482" class="Symbol">)</a> <a id="21484" class="Symbol">(</a><a id="21485" href="../Properties/#20681" class="Function">subst</a> <a id="21491" class="Bound">⊢V</a> <a id="21494" class="Symbol">(</a><a id="21495" href="../Properties/#19062" class="Function">swap</a> <a id="21500" href="../Properties/#21435" class="Bound">x≢y</a> <a id="21504" class="Bound">⊢N</a><a id="21506" class="Symbol">))</a>
<a id="21509" href="../Properties/#20681" class="Function">subst</a> <a id="21515" class="Symbol">{</a><a id="21516" class="Argument">x</a> <a id="21518" class="Symbol">=</a> <a id="21520" href="../Properties/#21520" class="Bound">y</a><a id="21521" class="Symbol">}</a> <a id="21523" href="../Properties/#21523" class="Bound">⊢V</a> <a id="21526" class="Symbol">(</a><a id="21527" href="../Lambda/#46708" class="InductiveConstructor">⊢μ</a> <a id="21530" class="Symbol">{</a><a id="21531" class="Argument">x</a> <a id="21533" class="Symbol">=</a> <a id="21535" href="../Properties/#21535" class="Bound">x</a><a id="21536" class="Symbol">}</a> <a id="21538" href="../Properties/#21538" class="Bound">⊢M</a><a id="21540" class="Symbol">)</a> <a id="21542" class="Keyword">with</a> <a id="21547" href="../Properties/#21535" class="Bound">x</a> <a id="21549" href="https://agda.github.io/agda-stdlib/v1.3/Data.String.Properties.html#2409" class="Function Operator">≟</a> <a id="21551" href="../Properties/#21520" class="Bound">y</a>
<a id="21553" class="Symbol">...</a> <a id="21557" class="Symbol">|</a> <a id="21559" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="21563" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>        <a id="21575" class="Symbol">=</a>  <a id="21578" href="../Lambda/#46708" class="InductiveConstructor">⊢μ</a> <a id="21581" class="Symbol">(</a><a id="21582" href="../Properties/#18219" class="Function">drop</a> <a id="21587" class="Bound">⊢M</a><a id="21589" class="Symbol">)</a>
<a id="21591" class="Symbol">...</a> <a id="21595" class="Symbol">|</a> <a id="21597" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#1682" class="InductiveConstructor">no</a>  <a id="21601" href="../Properties/#21601" class="Bound">x≢y</a>         <a id="21613" class="Symbol">=</a>  <a id="21616" href="../Lambda/#46708" class="InductiveConstructor">⊢μ</a> <a id="21619" class="Symbol">(</a><a id="21620" href="../Properties/#20681" class="Function">subst</a> <a id="21626" class="Bound">⊢V</a> <a id="21629" class="Symbol">(</a><a id="21630" href="../Properties/#19062" class="Function">swap</a> <a id="21635" href="../Properties/#21601" class="Bound">x≢y</a> <a id="21639" class="Bound">⊢M</a><a id="21641" class="Symbol">))</a>
</pre>
<p>We induct on the evidence that <code>N</code> is well typed in the context <code>Γ</code> extended by <code>x</code>.</p>
<p>First, we note a wee issue with naming. In the lemma statement, the variable <code>x</code> is an implicit parameter for the variable substituted, while in the type rules for variables, abstractions, cases, and fixpoints, the variable <code>x</code> is an implicit parameter for the relevant variable. We are going to need to get hold of both variables, so we use the syntax <code>{x = y}</code> to bind <code>y</code> to the substituted variable and the syntax <code>{x = x}</code> to bind <code>x</code> to the relevant variable in the patterns for <code>⊢`</code>, <code>⊢ƛ</code>, <code>⊢case</code>, and <code>⊢μ</code>. Using the name <code>y</code> here is consistent with the naming in the original definition of substitution in the previous chapter. The proof never mentions the types of <code>x</code>, <code>y</code>, <code>V</code>, or <code>N</code>, so in what follows we choose type names as convenient.</p>
<p>Now that naming is resolved, let’s unpack the first three cases:</p>
<ul>
<li><p>In the variable case, we must show</p>
<pre><code>∅ ⊢ V ⦂ B
Γ , y ⦂ B ⊢ ` x ⦂ A
------------------------
Γ ⊢ ` x [ y := V ] ⦂ A</code></pre>
<p>where the second hypothesis follows from:</p>
<pre><code>Γ , y ⦂ B ∋ x ⦂ A</code></pre>
<p>There are two subcases, depending on the evidence for this judgment:</p>
<ul>
<li><p>The lookup judgment is evidenced by rule <code>Z</code>:</p>
<pre><code>----------------
Γ , x ⦂ A ∋ x ⦂ A</code></pre>
<p>In this case, <code>x</code> and <code>y</code> are necessarily identical, as are <code>A</code> and <code>B</code>. Nonetheless, we must evaluate <code>x ≟ y</code> in order to allow the definition of substitution to simplify:</p>
<ul>
<li><p>If the variables are equal, then after simplification we must show</p>
<pre><code>∅ ⊢ V ⦂ A
---------
Γ ⊢ V ⦂ A</code></pre>
<p>which follows by weakening.</p></li>
<li><p>If the variables are unequal we have a contradiction.</p></li>
</ul></li>
<li><p>The lookup judgment is evidenced by rule <code>S</code>:</p>
<pre><code>x ≢ y
Γ ∋ x ⦂ A
-----------------
Γ , y ⦂ B ∋ x ⦂ A</code></pre>
<p>In this case, <code>x</code> and <code>y</code> are necessarily distinct. Nonetheless, we must again evaluate <code>x ≟ y</code> in order to allow the definition of substitution to simplify:</p>
<ul>
<li><p>If the variables are equal we have a contradiction.</p></li>
<li><p>If the variables are unequal, then after simplification we must show</p>
<pre><code>∅ ⊢ V ⦂ B
x ≢ y
Γ ∋ x ⦂ A
-------------
Γ ⊢ ` x ⦂ A</code></pre>
<p>which follows by the typing rule for variables.</p></li>
</ul></li>
</ul></li>
<li><p>In the abstraction case, we must show</p>
<pre><code>∅ ⊢ V ⦂ B
Γ , y ⦂ B ⊢ (ƛ x ⇒ N) ⦂ A ⇒ C
--------------------------------
Γ ⊢ (ƛ x ⇒ N) [ y := V ] ⦂ A ⇒ C</code></pre>
<p>where the second hypothesis follows from</p>
<pre><code>Γ , y ⦂ B , x ⦂ A ⊢ N ⦂ C</code></pre>
<p>We evaluate <code>x ≟ y</code> in order to allow the definition of substitution to simplify:</p>
<ul>
<li><p>If the variables are equal then after simplification we must show:</p>
<pre><code>∅ ⊢ V ⦂ B
Γ , x ⦂ B , x ⦂ A ⊢ N ⦂ C
-------------------------
Γ ⊢ ƛ x ⇒ N ⦂ A ⇒ C</code></pre>
<p>From the drop lemma, <code>drop</code>, we may conclude:</p>
<pre><code>Γ , x ⦂ B , x ⦂ A ⊢ N ⦂ C
-------------------------
Γ , x ⦂ A ⊢ N ⦂ C</code></pre>
<p>The typing rule for abstractions then yields the required conclusion.</p></li>
<li><p>If the variables are distinct then after simplification we must show:</p>
<pre><code>∅ ⊢ V ⦂ B
Γ , y ⦂ B , x ⦂ A ⊢ N ⦂ C
--------------------------------
Γ ⊢ ƛ x ⇒ (N [ y := V ]) ⦂ A ⇒ C</code></pre>
<p>From the swap lemma we may conclude:</p>
<pre><code>Γ , y ⦂ B , x ⦂ A ⊢ N ⦂ C
-------------------------
Γ , x ⦂ A , y ⦂ B ⊢ N ⦂ C</code></pre>
<p>The inductive hypothesis gives us:</p>
<pre><code>∅ ⊢ V ⦂ B
Γ , x ⦂ A , y ⦂ B ⊢ N ⦂ C
----------------------------
Γ , x ⦂ A ⊢ N [ y := V ] ⦂ C</code></pre>
<p>The typing rule for abstractions then yields the required conclusion.</p></li>
</ul></li>
<li><p>In the application case, we must show</p>
<pre><code>∅ ⊢ V ⦂ C
Γ , y ⦂ C ⊢ L · M ⦂ B
--------------------------
Γ ⊢ (L · M) [ y := V ] ⦂ B</code></pre>
<p>where the second hypothesis follows from the two judgments</p>
<pre><code>Γ , y ⦂ C ⊢ L ⦂ A ⇒ B
Γ , y ⦂ C ⊢ M ⦂ A</code></pre>
<p>By the definition of substitution, we must show:</p>
<pre><code>∅ ⊢ V ⦂ C
Γ , y ⦂ C ⊢ L ⦂ A ⇒ B
Γ , y ⦂ C ⊢ M ⦂ A
---------------------------------------
Γ ⊢ (L [ y := V ]) · (M [ y := V ]) ⦂ B</code></pre>
<p>Applying the induction hypothesis for <code>L</code> and <code>M</code> and the typing rule for applications yields the required conclusion.</p></li>
</ul>
<p>The remaining cases are similar, using induction for each subterm. Where the construct introduces a bound variable we need to compare it with the substituted variable, applying the drop lemma if they are equal and the swap lemma if they are distinct.</p>
<p>For Agda it makes a difference whether we write <code>x ≟ y</code> or <code>y ≟ x</code>. In an interactive proof, Agda will show which residual <code>with</code> clauses in the definition of <code>_[_:=_]</code> need to be simplified, and the <code>with</code> clauses in <code>subst</code> need to match these exactly. The guideline is that Agda knows nothing about symmetry or commutativity, which require invoking appropriate lemmas, so it is important to think about order of arguments and to be consistent.</p>
<h4 id="exercise-subst-stretch">Exercise <code>subst′</code> (stretch)</h4>
<p>Rewrite <code>subst</code> to work with the modified definition <code>_[_:=_]′</code> from the exercise in the previous chapter. As before, this should factor dealing with bound variables into a single function, defined by mutual recursion with the proof that substitution preserves types.</p>
<pre class="Agda"><a id="26929" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="preservation">Preservation</h2>
<p>Once we have shown that substitution preserves types, showing that reduction preserves types is straightforward:</p>
<pre class="Agda"><a id="preserve"></a><a id="27093" href="../Properties/#27093" class="Function">preserve</a> <a id="27102" class="Symbol">:</a> <a id="27104" class="Symbol">∀</a> <a id="27106" class="Symbol">{</a><a id="27107" href="../Properties/#27107" class="Bound">M</a> <a id="27109" href="../Properties/#27109" class="Bound">N</a> <a id="27111" href="../Properties/#27111" class="Bound">A</a><a id="27112" class="Symbol">}</a>
  <a id="27116" class="Symbol">→</a> <a id="27118" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="27120" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="27122" href="../Properties/#27107" class="Bound">M</a> <a id="27124" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="27126" href="../Properties/#27111" class="Bound">A</a>
  <a id="27130" class="Symbol">→</a> <a id="27132" href="../Properties/#27107" class="Bound">M</a> <a id="27134" href="../Lambda/#27997" class="Datatype Operator">—→</a> <a id="27137" href="../Properties/#27109" class="Bound">N</a>
    <a id="27143" class="Comment">----------</a>
  <a id="27156" class="Symbol">→</a> <a id="27158" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="27160" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="27162" href="../Properties/#27109" class="Bound">N</a> <a id="27164" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="27166" href="../Properties/#27111" class="Bound">A</a>
<a id="27168" href="../Properties/#27093" class="Function">preserve</a> <a id="27177" class="Symbol">(</a><a id="27178" href="../Lambda/#46084" class="InductiveConstructor">⊢`</a> <a id="27181" class="Symbol">())</a>
<a id="27185" href="../Properties/#27093" class="Function">preserve</a> <a id="27194" class="Symbol">(</a><a id="27195" href="../Lambda/#46163" class="InductiveConstructor">⊢ƛ</a> <a id="27198" href="../Properties/#27198" class="Bound">⊢N</a><a id="27200" class="Symbol">)</a>                 <a id="27218" class="Symbol">()</a>
<a id="27221" href="../Properties/#27093" class="Function">preserve</a> <a id="27230" class="Symbol">(</a><a id="27231" href="../Properties/#27231" class="Bound">⊢L</a> <a id="27234" href="../Lambda/#46270" class="InductiveConstructor Operator">·</a> <a id="27236" href="../Properties/#27236" class="Bound">⊢M</a><a id="27238" class="Symbol">)</a>               <a id="27254" class="Symbol">(</a><a id="27255" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="27260" href="../Properties/#27260" class="Bound">L—→L′</a><a id="27265" class="Symbol">)</a>     <a id="27271" class="Symbol">=</a>  <a id="27274" class="Symbol">(</a><a id="27275" href="../Properties/#27093" class="Function">preserve</a> <a id="27284" href="../Properties/#27231" class="Bound">⊢L</a> <a id="27287" href="../Properties/#27260" class="Bound">L—→L′</a><a id="27292" class="Symbol">)</a> <a id="27294" href="../Lambda/#46270" class="InductiveConstructor Operator">·</a> <a id="27296" href="../Properties/#27236" class="Bound">⊢M</a>
<a id="27299" href="../Properties/#27093" class="Function">preserve</a> <a id="27308" class="Symbol">(</a><a id="27309" href="../Properties/#27309" class="Bound">⊢L</a> <a id="27312" href="../Lambda/#46270" class="InductiveConstructor Operator">·</a> <a id="27314" href="../Properties/#27314" class="Bound">⊢M</a><a id="27316" class="Symbol">)</a>               <a id="27332" class="Symbol">(</a><a id="27333" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="27338" href="../Properties/#27338" class="Bound">VL</a> <a id="27341" href="../Properties/#27341" class="Bound">M—→M′</a><a id="27346" class="Symbol">)</a>  <a id="27349" class="Symbol">=</a>  <a id="27352" href="../Properties/#27309" class="Bound">⊢L</a> <a id="27355" href="../Lambda/#46270" class="InductiveConstructor Operator">·</a> <a id="27357" class="Symbol">(</a><a id="27358" href="../Properties/#27093" class="Function">preserve</a> <a id="27367" href="../Properties/#27314" class="Bound">⊢M</a> <a id="27370" href="../Properties/#27341" class="Bound">M—→M′</a><a id="27375" class="Symbol">)</a>
<a id="27377" href="../Properties/#27093" class="Function">preserve</a> <a id="27386" class="Symbol">((</a><a id="27388" href="../Lambda/#46163" class="InductiveConstructor">⊢ƛ</a> <a id="27391" href="../Properties/#27391" class="Bound">⊢N</a><a id="27393" class="Symbol">)</a> <a id="27395" href="../Lambda/#46270" class="InductiveConstructor Operator">·</a> <a id="27397" href="../Properties/#27397" class="Bound">⊢V</a><a id="27399" class="Symbol">)</a>          <a id="27410" class="Symbol">(</a><a id="27411" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="27415" href="../Properties/#27415" class="Bound">VV</a><a id="27417" class="Symbol">)</a>         <a id="27427" class="Symbol">=</a>  <a id="27430" href="../Properties/#20681" class="Function">subst</a> <a id="27436" href="../Properties/#27397" class="Bound">⊢V</a> <a id="27439" href="../Properties/#27391" class="Bound">⊢N</a>
<a id="27442" href="../Properties/#27093" class="Function">preserve</a> <a id="27451" href="../Lambda/#46379" class="InductiveConstructor">⊢zero</a>                   <a id="27475" class="Symbol">()</a>
<a id="27478" href="../Properties/#27093" class="Function">preserve</a> <a id="27487" class="Symbol">(</a><a id="27488" href="../Lambda/#46448" class="InductiveConstructor">⊢suc</a> <a id="27493" href="../Properties/#27493" class="Bound">⊢M</a><a id="27495" class="Symbol">)</a>               <a id="27511" class="Symbol">(</a><a id="27512" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="27518" href="../Properties/#27518" class="Bound">M—→M′</a><a id="27523" class="Symbol">)</a>    <a id="27528" class="Symbol">=</a>  <a id="27531" href="../Lambda/#46448" class="InductiveConstructor">⊢suc</a> <a id="27536" class="Symbol">(</a><a id="27537" href="../Properties/#27093" class="Function">preserve</a> <a id="27546" href="../Properties/#27493" class="Bound">⊢M</a> <a id="27549" href="../Properties/#27518" class="Bound">M—→M′</a><a id="27554" class="Symbol">)</a>
<a id="27556" href="../Properties/#27093" class="Function">preserve</a> <a id="27565" class="Symbol">(</a><a id="27566" href="../Lambda/#46536" class="InductiveConstructor">⊢case</a> <a id="27572" href="../Properties/#27572" class="Bound">⊢L</a> <a id="27575" href="../Properties/#27575" class="Bound">⊢M</a> <a id="27578" href="../Properties/#27578" class="Bound">⊢N</a><a id="27580" class="Symbol">)</a>        <a id="27589" class="Symbol">(</a><a id="27590" href="../Lambda/#28396" class="InductiveConstructor">ξ-case</a> <a id="27597" href="../Properties/#27597" class="Bound">L—→L′</a><a id="27602" class="Symbol">)</a>   <a id="27606" class="Symbol">=</a>  <a id="27609" href="../Lambda/#46536" class="InductiveConstructor">⊢case</a> <a id="27615" class="Symbol">(</a><a id="27616" href="../Properties/#27093" class="Function">preserve</a> <a id="27625" href="../Properties/#27572" class="Bound">⊢L</a> <a id="27628" href="../Properties/#27597" class="Bound">L—→L′</a><a id="27633" class="Symbol">)</a> <a id="27635" href="../Properties/#27575" class="Bound">⊢M</a> <a id="27638" href="../Properties/#27578" class="Bound">⊢N</a>
<a id="27641" href="../Properties/#27093" class="Function">preserve</a> <a id="27650" class="Symbol">(</a><a id="27651" href="../Lambda/#46536" class="InductiveConstructor">⊢case</a> <a id="27657" href="../Lambda/#46379" class="InductiveConstructor">⊢zero</a> <a id="27663" href="../Properties/#27663" class="Bound">⊢M</a> <a id="27666" href="../Properties/#27666" class="Bound">⊢N</a><a id="27668" class="Symbol">)</a>     <a id="27674" class="Symbol">(</a><a id="27675" href="../Lambda/#28577" class="InductiveConstructor">β-zero</a><a id="27681" class="Symbol">)</a>         <a id="27691" class="Symbol">=</a>  <a id="27694" href="../Properties/#27663" class="Bound">⊢M</a>
<a id="27697" href="../Properties/#27093" class="Function">preserve</a> <a id="27706" class="Symbol">(</a><a id="27707" href="../Lambda/#46536" class="InductiveConstructor">⊢case</a> <a id="27713" class="Symbol">(</a><a id="27714" href="../Lambda/#46448" class="InductiveConstructor">⊢suc</a> <a id="27719" href="../Properties/#27719" class="Bound">⊢V</a><a id="27721" class="Symbol">)</a> <a id="27723" href="../Properties/#27723" class="Bound">⊢M</a> <a id="27726" href="../Properties/#27726" class="Bound">⊢N</a><a id="27728" class="Symbol">)</a> <a id="27730" class="Symbol">(</a><a id="27731" href="../Lambda/#28690" class="InductiveConstructor">β-suc</a> <a id="27737" href="../Properties/#27737" class="Bound">VV</a><a id="27739" class="Symbol">)</a>       <a id="27747" class="Symbol">=</a>  <a id="27750" href="../Properties/#20681" class="Function">subst</a> <a id="27756" href="../Properties/#27719" class="Bound">⊢V</a> <a id="27759" href="../Properties/#27726" class="Bound">⊢N</a>
<a id="27762" href="../Properties/#27093" class="Function">preserve</a> <a id="27771" class="Symbol">(</a><a id="27772" href="../Lambda/#46708" class="InductiveConstructor">⊢μ</a> <a id="27775" href="../Properties/#27775" class="Bound">⊢M</a><a id="27777" class="Symbol">)</a>                 <a id="27795" class="Symbol">(</a><a id="27796" href="../Lambda/#28841" class="InductiveConstructor">β-μ</a><a id="27799" class="Symbol">)</a>            <a id="27812" class="Symbol">=</a>  <a id="27815" href="../Properties/#20681" class="Function">subst</a> <a id="27821" class="Symbol">(</a><a id="27822" href="../Lambda/#46708" class="InductiveConstructor">⊢μ</a> <a id="27825" href="../Properties/#27775" class="Bound">⊢M</a><a id="27827" class="Symbol">)</a> <a id="27829" href="../Properties/#27775" class="Bound">⊢M</a>
</pre>
<p>The proof never mentions the types of <code>M</code> or <code>N</code>, so in what follows we choose type name as convenient.</p>
<p>Let’s unpack the cases for two of the reduction rules:</p>
<ul>
<li><p>Rule <code>ξ-·₁</code>. We have</p>
<pre><code>L —→ L′
----------------
L · M —→ L′ · M</code></pre>
<p>where the left-hand side is typed by</p>
<pre><code>Γ ⊢ L ⦂ A ⇒ B
Γ ⊢ M ⦂ A
-------------
Γ ⊢ L · M ⦂ B</code></pre>
<p>By induction, we have</p>
<pre><code>Γ ⊢ L ⦂ A ⇒ B
L —→ L′
--------------
Γ ⊢ L′ ⦂ A ⇒ B</code></pre>
<p>from which the typing of the right-hand side follows immediately.</p></li>
<li><p>Rule <code>β-ƛ</code>. We have</p>
<pre><code>Value V
-----------------------------
(ƛ x ⇒ N) · V —→ N [ x := V ]</code></pre>
<p>where the left-hand side is typed by</p>
<pre><code>Γ , x ⦂ A ⊢ N ⦂ B
-------------------
Γ ⊢ ƛ x ⇒ N ⦂ A ⇒ B    Γ ⊢ V ⦂ A
--------------------------------
Γ ⊢ (ƛ x ⇒ N) · V ⦂ B</code></pre>
<p>By the substitution lemma, we have</p>
<pre><code>Γ ⊢ V ⦂ A
Γ , x ⦂ A ⊢ N ⦂ B
--------------------
Γ ⊢ N [ x := V ] ⦂ B</code></pre>
<p>from which the typing of the right-hand side follows immediately.</p></li>
</ul>
<p>The remaining cases are similar. Each <code>ξ</code> rule follows by induction, and each <code>β</code> rule follows by the substitution lemma.</p>
<h2 id="evaluation">Evaluation</h2>
<p>By repeated application of progress and preservation, we can evaluate any well-typed term. In this section, we will present an Agda function that computes the reduction sequence from any given closed, well-typed term to its value, if it has one.</p>
Some terms may reduce forever. Here is a simple example:
<pre class="Agda"><a id="sucμ"></a><a id="29330" href="../Properties/#29330" class="Function">sucμ</a>  <a id="29336" class="Symbol">=</a>  <a id="29339" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="29341" class="String">&quot;x&quot;</a> <a id="29345" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a> <a id="29347" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="29352" class="Symbol">(</a><a id="29353" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="29355" class="String">&quot;x&quot;</a><a id="29358" class="Symbol">)</a>

<a id="29361" href="../Properties/#29361" class="Function">_</a> <a id="29363" class="Symbol">=</a>
  <a id="29367" href="../Lambda/#31812" class="Function Operator">begin</a>
    <a id="29377" href="../Properties/#29330" class="Function">sucμ</a>
  <a id="29384" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="29388" href="../Lambda/#28841" class="InductiveConstructor">β-μ</a> <a id="29392" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="29398" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="29403" href="../Properties/#29330" class="Function">sucμ</a>
  <a id="29410" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="29414" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="29420" href="../Lambda/#28841" class="InductiveConstructor">β-μ</a> <a id="29424" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="29430" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="29435" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="29440" href="../Properties/#29330" class="Function">sucμ</a>
  <a id="29447" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="29451" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="29457" class="Symbol">(</a><a id="29458" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="29464" href="../Lambda/#28841" class="InductiveConstructor">β-μ</a><a id="29467" class="Symbol">)</a> <a id="29469" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="29475" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="29480" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="29485" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="29490" href="../Properties/#29330" class="Function">sucμ</a>
  <a id="29497" class="Comment">--  ...</a>
  <a id="29507" href="../Lambda/#31695" class="InductiveConstructor Operator">∎</a>
</pre>
<p>Since every Agda computation must terminate, we cannot simply ask Agda to reduce a term to a value. Instead, we will provide a natural number to Agda, and permit it to stop short of a value if the term requires more than the given number of reduction steps.</p>
<p>A similar issue arises with cryptocurrencies. Systems which use smart contracts require the miners that maintain the blockchain to evaluate the program which embodies the contract. For instance, validating a transaction on Ethereum may require executing a program for the Ethereum Virtual Machine (EVM). A long-running or non-terminating program might cause the miner to invest arbitrary effort in validating a contract for little or no return. To avoid this situation, each transaction is accompanied by an amount of <em>gas</em> available for computation. Each step executed on the EVM is charged an advertised amount of gas, and the transaction pays for the gas at a published rate: a given number of Ethers (the currency of Ethereum) per unit of gas.</p>
By analogy, we will use the name <em>gas</em> for the parameter which puts a bound on the number of reduction steps. <code>Gas</code> is specified by a natural number:
<pre class="Agda"><a id="30681" class="Keyword">record</a> <a id="Gas"></a><a id="30688" href="../Properties/#30688" class="Record">Gas</a> <a id="30692" class="Symbol">:</a> <a id="30694" class="PrimitiveType">Set</a> <a id="30698" class="Keyword">where</a>
  <a id="30706" class="Keyword">constructor</a> <a id="gas"></a><a id="30718" href="../Properties/#30718" class="InductiveConstructor">gas</a>
  <a id="30724" class="Keyword">field</a>
    <a id="Gas.amount"></a><a id="30734" href="../Properties/#30734" class="Field">amount</a> <a id="30741" class="Symbol">:</a> <a id="30743" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
</pre>
When our evaluator returns a term <code>N</code>, it will either give evidence that <code>N</code> is a value or indicate that it ran out of gas:
<pre class="Agda"><a id="30877" class="Keyword">data</a> <a id="Finished"></a><a id="30882" href="../Properties/#30882" class="Datatype">Finished</a> <a id="30891" class="Symbol">(</a><a id="30892" href="../Properties/#30892" class="Bound">N</a> <a id="30894" class="Symbol">:</a> <a id="30896" href="../Lambda/#5500" class="Datatype">Term</a><a id="30900" class="Symbol">)</a> <a id="30902" class="Symbol">:</a> <a id="30904" class="PrimitiveType">Set</a> <a id="30908" class="Keyword">where</a>

  <a id="Finished.done"></a><a id="30917" href="../Properties/#30917" class="InductiveConstructor">done</a> <a id="30922" class="Symbol">:</a>
      <a id="30930" href="../Lambda/#16914" class="Datatype">Value</a> <a id="30936" href="../Properties/#30892" class="Bound">N</a>
      <a id="30944" class="Comment">----------</a>
    <a id="30959" class="Symbol">→</a> <a id="30961" href="../Properties/#30882" class="Datatype">Finished</a> <a id="30970" href="../Properties/#30892" class="Bound">N</a>

  <a id="Finished.out-of-gas"></a><a id="30975" href="../Properties/#30975" class="InductiveConstructor">out-of-gas</a> <a id="30986" class="Symbol">:</a>
      <a id="30994" class="Comment">----------</a>
      <a id="31011" href="../Properties/#30882" class="Datatype">Finished</a> <a id="31020" href="../Properties/#30892" class="Bound">N</a>
</pre>
Given a term <code>L</code> of type <code>A</code>, the evaluator will, for some <code>N</code>, return a reduction sequence from <code>L</code> to <code>N</code> and an indication of whether reduction finished:
<pre class="Agda"><a id="31187" class="Keyword">data</a> <a id="Steps"></a><a id="31192" href="../Properties/#31192" class="Datatype">Steps</a> <a id="31198" class="Symbol">(</a><a id="31199" href="../Properties/#31199" class="Bound">L</a> <a id="31201" class="Symbol">:</a> <a id="31203" href="../Lambda/#5500" class="Datatype">Term</a><a id="31207" class="Symbol">)</a> <a id="31209" class="Symbol">:</a> <a id="31211" class="PrimitiveType">Set</a> <a id="31215" class="Keyword">where</a>

  <a id="Steps.steps"></a><a id="31224" href="../Properties/#31224" class="InductiveConstructor">steps</a> <a id="31230" class="Symbol">:</a> <a id="31232" class="Symbol">∀</a> <a id="31234" class="Symbol">{</a><a id="31235" href="../Properties/#31235" class="Bound">N</a><a id="31236" class="Symbol">}</a>
    <a id="31242" class="Symbol">→</a> <a id="31244" href="../Properties/#31199" class="Bound">L</a> <a id="31246" href="../Lambda/#31662" class="Datatype Operator">—↠</a> <a id="31249" href="../Properties/#31235" class="Bound">N</a>
    <a id="31255" class="Symbol">→</a> <a id="31257" href="../Properties/#30882" class="Datatype">Finished</a> <a id="31266" href="../Properties/#31235" class="Bound">N</a>
      <a id="31274" class="Comment">----------</a>
    <a id="31289" class="Symbol">→</a> <a id="31291" href="../Properties/#31192" class="Datatype">Steps</a> <a id="31297" href="../Properties/#31199" class="Bound">L</a>
</pre>
The evaluator takes gas and evidence that a term is well typed, and returns the corresponding steps:
<pre class="Agda"><a id="eval"></a><a id="31408" href="../Properties/#31408" class="Function">eval</a> <a id="31413" class="Symbol">:</a> <a id="31415" class="Symbol">∀</a> <a id="31417" class="Symbol">{</a><a id="31418" href="../Properties/#31418" class="Bound">L</a> <a id="31420" href="../Properties/#31420" class="Bound">A</a><a id="31421" class="Symbol">}</a>
  <a id="31425" class="Symbol">→</a> <a id="31427" href="../Properties/#30688" class="Record">Gas</a>
  <a id="31433" class="Symbol">→</a> <a id="31435" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="31437" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="31439" href="../Properties/#31418" class="Bound">L</a> <a id="31441" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="31443" href="../Properties/#31420" class="Bound">A</a>
    <a id="31449" class="Comment">---------</a>
  <a id="31461" class="Symbol">→</a> <a id="31463" href="../Properties/#31192" class="Datatype">Steps</a> <a id="31469" href="../Properties/#31418" class="Bound">L</a>
<a id="31471" href="../Properties/#31408" class="Function">eval</a> <a id="31476" class="Symbol">{</a><a id="31477" href="../Properties/#31477" class="Bound">L</a><a id="31478" class="Symbol">}</a> <a id="31480" class="Symbol">(</a><a id="31481" href="../Properties/#30718" class="InductiveConstructor">gas</a> <a id="31485" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="31489" class="Symbol">)</a>    <a id="31494" href="../Properties/#31494" class="Bound">⊢L</a>                                <a id="31528" class="Symbol">=</a>  <a id="31531" href="../Properties/#31224" class="InductiveConstructor">steps</a> <a id="31537" class="Symbol">(</a><a id="31538" href="../Properties/#31477" class="Bound">L</a> <a id="31540" href="../Lambda/#31695" class="InductiveConstructor Operator">∎</a><a id="31541" class="Symbol">)</a> <a id="31543" href="../Properties/#30975" class="InductiveConstructor">out-of-gas</a>
<a id="31554" href="../Properties/#31408" class="Function">eval</a> <a id="31559" class="Symbol">{</a><a id="31560" href="../Properties/#31560" class="Bound">L</a><a id="31561" class="Symbol">}</a> <a id="31563" class="Symbol">(</a><a id="31564" href="../Properties/#30718" class="InductiveConstructor">gas</a> <a id="31568" class="Symbol">(</a><a id="31569" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="31573" href="../Properties/#31573" class="Bound">m</a><a id="31574" class="Symbol">))</a> <a id="31577" href="../Properties/#31577" class="Bound">⊢L</a> <a id="31580" class="Keyword">with</a> <a id="31585" href="../Properties/#7756" class="Function">progress</a> <a id="31594" href="../Properties/#31577" class="Bound">⊢L</a>
<a id="31597" class="Symbol">...</a> <a id="31601" class="Symbol">|</a> <a id="31603" href="../Properties/#7464" class="InductiveConstructor">done</a> <a id="31608" href="../Properties/#31608" class="Bound">VL</a>                                            <a id="31654" class="Symbol">=</a>  <a id="31657" href="../Properties/#31224" class="InductiveConstructor">steps</a> <a id="31663" class="Symbol">(</a><a id="31664" class="Bound">L</a> <a id="31666" href="../Lambda/#31695" class="InductiveConstructor Operator">∎</a><a id="31667" class="Symbol">)</a> <a id="31669" class="Symbol">(</a><a id="31670" href="../Properties/#30917" class="InductiveConstructor">done</a> <a id="31675" href="../Properties/#31608" class="Bound">VL</a><a id="31677" class="Symbol">)</a>
<a id="31679" class="Symbol">...</a> <a id="31683" class="Symbol">|</a> <a id="31685" href="../Properties/#7401" class="InductiveConstructor">step</a> <a id="31690" class="Symbol">{</a><a id="31691" href="../Properties/#31691" class="Bound">M</a><a id="31692" class="Symbol">}</a> <a id="31694" href="../Properties/#31694" class="Bound">L—→M</a> <a id="31699" class="Keyword">with</a> <a id="31704" href="../Properties/#31408" class="Function">eval</a> <a id="31709" class="Symbol">(</a><a id="31710" href="../Properties/#30718" class="InductiveConstructor">gas</a> <a id="31714" class="Bound">m</a><a id="31715" class="Symbol">)</a> <a id="31717" class="Symbol">(</a><a id="31718" href="../Properties/#27093" class="Function">preserve</a> <a id="31727" class="Bound">⊢L</a> <a id="31730" href="../Properties/#31694" class="Bound">L—→M</a><a id="31734" class="Symbol">)</a>
<a id="31736" class="Symbol">...</a>    <a id="31743" class="Symbol">|</a> <a id="31745" href="../Properties/#31224" class="InductiveConstructor">steps</a> <a id="31751" href="../Properties/#31751" class="Bound">M—↠N</a> <a id="31756" href="../Properties/#31756" class="Bound">fin</a>                                  <a id="31793" class="Symbol">=</a>  <a id="31796" href="../Properties/#31224" class="InductiveConstructor">steps</a> <a id="31802" class="Symbol">(</a><a id="31803" class="Bound">L</a> <a id="31805" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="31809" class="Bound">L—→M</a> <a id="31814" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a> <a id="31816" href="../Properties/#31751" class="Bound">M—↠N</a><a id="31820" class="Symbol">)</a> <a id="31822" href="../Properties/#31756" class="Bound">fin</a>
</pre>
<p>Let <code>L</code> be the name of the term we are reducing, and <code>⊢L</code> be the evidence that <code>L</code> is well typed. We consider the amount of gas remaining. There are two possibilities:</p>
<ul>
<li><p>It is zero, so we stop early. We return the trivial reduction sequence <code>L —↠ L</code>, evidence that <code>L</code> is well typed, and an indication that we are out of gas.</p></li>
<li><p>It is non-zero and after the next step we have <code>m</code> gas remaining. Apply progress to the evidence that term <code>L</code> is well typed. There are two possibilities:</p>
<ul>
<li><p>Term <code>L</code> is a value, so we are done. We return the trivial reduction sequence <code>L —↠ L</code>, evidence that <code>L</code> is well typed, and the evidence that <code>L</code> is a value.</p></li>
<li><p>Term <code>L</code> steps to another term <code>M</code>. Preservation provides evidence that <code>M</code> is also well typed, and we recursively invoke <code>eval</code> on the remaining gas. The result is evidence that <code>M —↠ N</code>, together with evidence that <code>N</code> is well typed and an indication of whether reduction finished. We combine the evidence that <code>L —→ M</code> and <code>M —↠ N</code> to return evidence that <code>L —↠ N</code>, together with the other relevant evidence.</p></li>
</ul></li>
</ul>
<h3 id="examples">Examples</h3>
We can now use Agda to compute the non-terminating reduction sequence given earlier. First, we show that the term <code>sucμ</code> is well typed:
<pre class="Agda"><a id="⊢sucμ"></a><a id="33100" href="../Properties/#33100" class="Function">⊢sucμ</a> <a id="33106" class="Symbol">:</a> <a id="33108" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="33110" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="33112" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="33114" class="String">&quot;x&quot;</a> <a id="33118" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a> <a id="33120" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="33125" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="33127" class="String">&quot;x&quot;</a> <a id="33131" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="33133" href="../Lambda/#39812" class="InductiveConstructor">`ℕ</a>
<a id="33136" href="../Properties/#33100" class="Function">⊢sucμ</a> <a id="33142" class="Symbol">=</a> <a id="33144" href="../Lambda/#46708" class="InductiveConstructor">⊢μ</a> <a id="33147" class="Symbol">(</a><a id="33148" href="../Lambda/#46448" class="InductiveConstructor">⊢suc</a> <a id="33153" class="Symbol">(</a><a id="33154" href="../Lambda/#46084" class="InductiveConstructor">⊢`</a> <a id="33157" href="../Properties/#33172" class="Function">∋x</a><a id="33159" class="Symbol">))</a>
  <a id="33164" class="Keyword">where</a>
  <a id="33172" href="../Properties/#33172" class="Function">∋x</a> <a id="33175" class="Symbol">=</a> <a id="33177" href="../Lambda/#44001" class="InductiveConstructor">Z</a>
</pre>
To show the first three steps of the infinite reduction sequence, we evaluate with three steps worth of gas:
<pre class="Agda"><a id="33296" href="../Properties/#33296" class="Function">_</a> <a id="33298" class="Symbol">:</a> <a id="33300" href="../Properties/#31408" class="Function">eval</a> <a id="33305" class="Symbol">(</a><a id="33306" href="../Properties/#30718" class="InductiveConstructor">gas</a> <a id="33310" class="Number">3</a><a id="33311" class="Symbol">)</a> <a id="33313" href="../Properties/#33100" class="Function">⊢sucμ</a> <a id="33319" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a>
  <a id="33323" href="../Properties/#31224" class="InductiveConstructor">steps</a>
   <a id="33332" class="Symbol">(</a><a id="33333" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="33335" class="String">&quot;x&quot;</a> <a id="33339" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a> <a id="33341" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="33346" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="33348" class="String">&quot;x&quot;</a>
   <a id="33355" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="33359" href="../Lambda/#28841" class="InductiveConstructor">β-μ</a> <a id="33363" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="33369" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="33374" class="Symbol">(</a><a id="33375" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="33377" class="String">&quot;x&quot;</a> <a id="33381" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a> <a id="33383" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="33388" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="33390" class="String">&quot;x&quot;</a><a id="33393" class="Symbol">)</a>
   <a id="33398" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="33402" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="33408" href="../Lambda/#28841" class="InductiveConstructor">β-μ</a> <a id="33412" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="33418" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="33423" class="Symbol">(</a><a id="33424" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="33429" class="Symbol">(</a><a id="33430" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="33432" class="String">&quot;x&quot;</a> <a id="33436" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a> <a id="33438" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="33443" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="33445" class="String">&quot;x&quot;</a><a id="33448" class="Symbol">))</a>
   <a id="33454" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="33458" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="33464" class="Symbol">(</a><a id="33465" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="33471" href="../Lambda/#28841" class="InductiveConstructor">β-μ</a><a id="33474" class="Symbol">)</a> <a id="33476" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="33482" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="33487" class="Symbol">(</a><a id="33488" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="33493" class="Symbol">(</a><a id="33494" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="33499" class="Symbol">(</a><a id="33500" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="33502" class="String">&quot;x&quot;</a> <a id="33506" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a> <a id="33508" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="33513" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="33515" class="String">&quot;x&quot;</a><a id="33518" class="Symbol">)))</a>
   <a id="33525" href="../Lambda/#31695" class="InductiveConstructor Operator">∎</a><a id="33526" class="Symbol">)</a>
   <a id="33531" href="../Properties/#30975" class="InductiveConstructor">out-of-gas</a>
<a id="33542" class="Symbol">_</a> <a id="33544" class="Symbol">=</a> <a id="33546" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
Similarly, we can use Agda to compute the reduction sequences given in the previous chapter. We start with the Church numeral two applied to successor and zero. Supplying 100 steps of gas is more than enough:
<pre class="Agda"><a id="33771" href="../Properties/#33771" class="Function">_</a> <a id="33773" class="Symbol">:</a> <a id="33775" href="../Properties/#31408" class="Function">eval</a> <a id="33780" class="Symbol">(</a><a id="33781" href="../Properties/#30718" class="InductiveConstructor">gas</a> <a id="33785" class="Number">100</a><a id="33788" class="Symbol">)</a> <a id="33790" class="Symbol">(</a><a id="33791" href="../Lambda/#49997" class="Function">⊢twoᶜ</a> <a id="33797" href="../Lambda/#46270" class="InductiveConstructor Operator">·</a> <a id="33799" href="../Lambda/#51578" class="Function">⊢sucᶜ</a> <a id="33805" href="../Lambda/#46270" class="InductiveConstructor Operator">·</a> <a id="33807" href="../Lambda/#46379" class="InductiveConstructor">⊢zero</a><a id="33812" class="Symbol">)</a> <a id="33814" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a>
  <a id="33818" href="../Properties/#31224" class="InductiveConstructor">steps</a>
   <a id="33827" class="Symbol">((</a><a id="33829" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="33831" class="String">&quot;s&quot;</a> <a id="33835" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="33837" class="Symbol">(</a><a id="33838" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="33840" class="String">&quot;z&quot;</a> <a id="33844" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="33846" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="33848" class="String">&quot;s&quot;</a> <a id="33852" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="33854" class="Symbol">(</a><a id="33855" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="33857" class="String">&quot;s&quot;</a> <a id="33861" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="33863" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="33865" class="String">&quot;z&quot;</a><a id="33868" class="Symbol">)))</a> <a id="33872" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="33874" class="Symbol">(</a><a id="33875" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="33877" class="String">&quot;n&quot;</a> <a id="33881" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="33883" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="33888" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="33890" class="String">&quot;n&quot;</a><a id="33893" class="Symbol">)</a>
   <a id="33898" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="33900" href="../Lambda/#5652" class="InductiveConstructor">`zero</a>
   <a id="33909" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="33913" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="33918" class="Symbol">(</a><a id="33919" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="33923" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a><a id="33926" class="Symbol">)</a> <a id="33928" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="33934" class="Symbol">(</a><a id="33935" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="33937" class="String">&quot;z&quot;</a> <a id="33941" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="33943" class="Symbol">(</a><a id="33944" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="33946" class="String">&quot;n&quot;</a> <a id="33950" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="33952" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="33957" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="33959" class="String">&quot;n&quot;</a><a id="33962" class="Symbol">)</a> <a id="33964" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="33966" class="Symbol">((</a><a id="33968" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="33970" class="String">&quot;n&quot;</a> <a id="33974" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="33976" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="33981" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="33983" class="String">&quot;n&quot;</a><a id="33986" class="Symbol">)</a> <a id="33988" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="33990" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="33992" class="String">&quot;z&quot;</a><a id="33995" class="Symbol">))</a> <a id="33998" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a>
     <a id="34005" href="../Lambda/#5652" class="InductiveConstructor">`zero</a>
   <a id="34014" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="34018" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="34022" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a> <a id="34029" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="34035" class="Symbol">(</a><a id="34036" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="34038" class="String">&quot;n&quot;</a> <a id="34042" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="34044" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="34049" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="34051" class="String">&quot;n&quot;</a><a id="34054" class="Symbol">)</a> <a id="34056" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="34058" class="Symbol">((</a><a id="34060" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="34062" class="String">&quot;n&quot;</a> <a id="34066" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="34068" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="34073" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="34075" class="String">&quot;n&quot;</a><a id="34078" class="Symbol">)</a> <a id="34080" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="34082" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="34087" class="Symbol">)</a>
   <a id="34092" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="34096" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="34101" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a> <a id="34105" class="Symbol">(</a><a id="34106" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="34110" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="34116" class="Symbol">)</a> <a id="34118" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="34124" class="Symbol">(</a><a id="34125" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="34127" class="String">&quot;n&quot;</a> <a id="34131" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="34133" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="34138" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="34140" class="String">&quot;n&quot;</a><a id="34143" class="Symbol">)</a> <a id="34145" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="34147" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="34152" href="../Lambda/#5652" class="InductiveConstructor">`zero</a>
   <a id="34161" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="34165" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="34169" class="Symbol">(</a><a id="34170" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="34176" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="34182" class="Symbol">)</a> <a id="34184" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="34190" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="34195" class="Symbol">(</a><a id="34196" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="34201" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="34206" class="Symbol">)</a>
   <a id="34211" href="../Lambda/#31695" class="InductiveConstructor Operator">∎</a><a id="34212" class="Symbol">)</a>
   <a id="34217" class="Symbol">(</a><a id="34218" href="../Properties/#30917" class="InductiveConstructor">done</a> <a id="34223" class="Symbol">(</a><a id="34224" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="34230" class="Symbol">(</a><a id="34231" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="34237" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="34243" class="Symbol">)))</a>
<a id="34247" class="Symbol">_</a> <a id="34249" class="Symbol">=</a> <a id="34251" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>The example above was generated by using <code>C-c C-n</code> to normalise the left-hand side of the equation and pasting in the result as the right-hand side of the equation. The example reduction of the previous chapter was derived from this result, reformatting and writing <code>twoᶜ</code> and <code>sucᶜ</code> in place of their expansions.</p>
Next, we show two plus two is four:
<pre class="Agda"><a id="34616" href="../Properties/#34616" class="Function">_</a> <a id="34618" class="Symbol">:</a> <a id="34620" href="../Properties/#31408" class="Function">eval</a> <a id="34625" class="Symbol">(</a><a id="34626" href="../Properties/#30718" class="InductiveConstructor">gas</a> <a id="34630" class="Number">100</a><a id="34633" class="Symbol">)</a> <a id="34635" href="../Lambda/#50455" class="Function">⊢2+2</a> <a id="34640" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a>
  <a id="34644" href="../Properties/#31224" class="InductiveConstructor">steps</a>
   <a id="34653" class="Symbol">((</a><a id="34655" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="34657" class="String">&quot;+&quot;</a> <a id="34661" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a>
     <a id="34668" class="Symbol">(</a><a id="34669" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="34671" class="String">&quot;m&quot;</a> <a id="34675" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
      <a id="34683" class="Symbol">(</a><a id="34684" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="34686" class="String">&quot;n&quot;</a> <a id="34690" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
       <a id="34699" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="34704" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="34706" class="String">&quot;m&quot;</a> <a id="34710" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="34717" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="34719" class="String">&quot;n&quot;</a> <a id="34723" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="34728" class="String">&quot;m&quot;</a> <a id="34732" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a> <a id="34734" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="34739" class="Symbol">(</a><a id="34740" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="34742" class="String">&quot;+&quot;</a> <a id="34746" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="34748" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="34750" class="String">&quot;m&quot;</a> <a id="34754" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="34756" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="34758" class="String">&quot;n&quot;</a><a id="34761" class="Symbol">)</a>
       <a id="34770" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="34771" class="Symbol">)))</a>
    <a id="34779" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="34781" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="34786" class="Symbol">(</a><a id="34787" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="34792" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="34797" class="Symbol">)</a>
    <a id="34803" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="34805" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="34810" class="Symbol">(</a><a id="34811" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="34816" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="34821" class="Symbol">)</a>
   <a id="34826" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="34830" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="34835" class="Symbol">(</a><a id="34836" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="34841" href="../Lambda/#28841" class="InductiveConstructor">β-μ</a><a id="34844" class="Symbol">)</a> <a id="34846" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="34852" class="Symbol">(</a><a id="34853" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="34855" class="String">&quot;m&quot;</a> <a id="34859" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
     <a id="34866" class="Symbol">(</a><a id="34867" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="34869" class="String">&quot;n&quot;</a> <a id="34873" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
      <a id="34881" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="34886" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="34888" class="String">&quot;m&quot;</a> <a id="34892" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="34899" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="34901" class="String">&quot;n&quot;</a> <a id="34905" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="34910" class="String">&quot;m&quot;</a> <a id="34914" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a>
      <a id="34922" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
      <a id="34933" class="Symbol">((</a><a id="34935" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="34937" class="String">&quot;+&quot;</a> <a id="34941" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a>
        <a id="34951" class="Symbol">(</a><a id="34952" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="34954" class="String">&quot;m&quot;</a> <a id="34958" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
         <a id="34969" class="Symbol">(</a><a id="34970" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="34972" class="String">&quot;n&quot;</a> <a id="34976" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
          <a id="34988" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="34993" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="34995" class="String">&quot;m&quot;</a> <a id="34999" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="35006" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35008" class="String">&quot;n&quot;</a> <a id="35012" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="35017" class="String">&quot;m&quot;</a> <a id="35021" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a> <a id="35023" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35028" class="Symbol">(</a><a id="35029" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35031" class="String">&quot;+&quot;</a> <a id="35035" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35037" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35039" class="String">&quot;m&quot;</a> <a id="35043" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35045" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35047" class="String">&quot;n&quot;</a><a id="35050" class="Symbol">)</a>
          <a id="35062" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="35063" class="Symbol">)))</a>
       <a id="35074" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35076" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35078" class="String">&quot;m&quot;</a>
       <a id="35089" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35091" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35093" class="String">&quot;n&quot;</a><a id="35096" class="Symbol">)</a>
      <a id="35104" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="35105" class="Symbol">))</a>
    <a id="35112" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35114" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35119" class="Symbol">(</a><a id="35120" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35125" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="35130" class="Symbol">)</a>
    <a id="35136" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35138" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35143" class="Symbol">(</a><a id="35144" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35149" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="35154" class="Symbol">)</a>
   <a id="35159" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="35163" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="35168" class="Symbol">(</a><a id="35169" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="35173" class="Symbol">(</a><a id="35174" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="35180" class="Symbol">(</a><a id="35181" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="35187" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="35193" class="Symbol">)))</a> <a id="35197" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="35203" class="Symbol">(</a><a id="35204" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="35206" class="String">&quot;n&quot;</a> <a id="35210" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
     <a id="35217" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="35222" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35227" class="Symbol">(</a><a id="35228" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35233" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="35238" class="Symbol">)</a> <a id="35240" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="35247" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35249" class="String">&quot;n&quot;</a> <a id="35253" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="35258" class="String">&quot;m&quot;</a> <a id="35262" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a>
     <a id="35269" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
     <a id="35279" class="Symbol">((</a><a id="35281" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="35283" class="String">&quot;+&quot;</a> <a id="35287" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a>
       <a id="35296" class="Symbol">(</a><a id="35297" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="35299" class="String">&quot;m&quot;</a> <a id="35303" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
        <a id="35313" class="Symbol">(</a><a id="35314" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="35316" class="String">&quot;n&quot;</a> <a id="35320" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
         <a id="35331" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="35336" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35338" class="String">&quot;m&quot;</a> <a id="35342" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="35349" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35351" class="String">&quot;n&quot;</a> <a id="35355" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="35360" class="String">&quot;m&quot;</a> <a id="35364" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a> <a id="35366" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35371" class="Symbol">(</a><a id="35372" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35374" class="String">&quot;+&quot;</a> <a id="35378" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35380" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35382" class="String">&quot;m&quot;</a> <a id="35386" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35388" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35390" class="String">&quot;n&quot;</a><a id="35393" class="Symbol">)</a>
         <a id="35404" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="35405" class="Symbol">)))</a>
      <a id="35415" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35417" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35419" class="String">&quot;m&quot;</a>
      <a id="35429" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35431" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35433" class="String">&quot;n&quot;</a><a id="35436" class="Symbol">)</a>
     <a id="35443" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="35444" class="Symbol">)</a>
    <a id="35450" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35452" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35457" class="Symbol">(</a><a id="35458" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35463" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="35468" class="Symbol">)</a>
   <a id="35473" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="35477" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="35481" class="Symbol">(</a><a id="35482" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="35488" class="Symbol">(</a><a id="35489" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="35495" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="35501" class="Symbol">))</a> <a id="35504" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="35510" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="35515" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35520" class="Symbol">(</a><a id="35521" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35526" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="35531" class="Symbol">)</a> <a id="35533" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="35540" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35545" class="Symbol">(</a><a id="35546" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35551" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="35556" class="Symbol">)</a> <a id="35558" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="35563" class="String">&quot;m&quot;</a> <a id="35567" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a>
    <a id="35573" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
    <a id="35582" class="Symbol">((</a><a id="35584" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="35586" class="String">&quot;+&quot;</a> <a id="35590" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a>
      <a id="35598" class="Symbol">(</a><a id="35599" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="35601" class="String">&quot;m&quot;</a> <a id="35605" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
       <a id="35614" class="Symbol">(</a><a id="35615" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="35617" class="String">&quot;n&quot;</a> <a id="35621" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
        <a id="35631" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="35636" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35638" class="String">&quot;m&quot;</a> <a id="35642" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="35649" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35651" class="String">&quot;n&quot;</a> <a id="35655" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="35660" class="String">&quot;m&quot;</a> <a id="35664" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a> <a id="35666" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35671" class="Symbol">(</a><a id="35672" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35674" class="String">&quot;+&quot;</a> <a id="35678" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35680" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35682" class="String">&quot;m&quot;</a> <a id="35686" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35688" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35690" class="String">&quot;n&quot;</a><a id="35693" class="Symbol">)</a>
        <a id="35703" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="35704" class="Symbol">)))</a>
     <a id="35713" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35715" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35717" class="String">&quot;m&quot;</a>
     <a id="35726" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35728" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35733" class="Symbol">(</a><a id="35734" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35739" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="35744" class="Symbol">))</a>
    <a id="35751" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a>
   <a id="35756" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="35760" href="../Lambda/#28690" class="InductiveConstructor">β-suc</a> <a id="35766" class="Symbol">(</a><a id="35767" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="35773" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="35779" class="Symbol">)</a> <a id="35781" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="35787" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
    <a id="35796" class="Symbol">((</a><a id="35798" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="35800" class="String">&quot;+&quot;</a> <a id="35804" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a>
      <a id="35812" class="Symbol">(</a><a id="35813" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="35815" class="String">&quot;m&quot;</a> <a id="35819" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
       <a id="35828" class="Symbol">(</a><a id="35829" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="35831" class="String">&quot;n&quot;</a> <a id="35835" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
        <a id="35845" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="35850" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35852" class="String">&quot;m&quot;</a> <a id="35856" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="35863" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35865" class="String">&quot;n&quot;</a> <a id="35869" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="35874" class="String">&quot;m&quot;</a> <a id="35878" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a> <a id="35880" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35885" class="Symbol">(</a><a id="35886" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35888" class="String">&quot;+&quot;</a> <a id="35892" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35894" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35896" class="String">&quot;m&quot;</a> <a id="35900" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35902" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="35904" class="String">&quot;n&quot;</a><a id="35907" class="Symbol">)</a>
        <a id="35917" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="35918" class="Symbol">)))</a>
     <a id="35927" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35929" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35934" href="../Lambda/#5652" class="InductiveConstructor">`zero</a>
     <a id="35945" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="35947" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35952" class="Symbol">(</a><a id="35953" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="35958" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="35963" class="Symbol">))</a>
   <a id="35969" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="35973" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="35979" class="Symbol">(</a><a id="35980" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="35985" class="Symbol">(</a><a id="35986" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="35991" href="../Lambda/#28841" class="InductiveConstructor">β-μ</a><a id="35994" class="Symbol">))</a> <a id="35997" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="36003" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
    <a id="36012" class="Symbol">((</a><a id="36014" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="36016" class="String">&quot;m&quot;</a> <a id="36020" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
      <a id="36028" class="Symbol">(</a><a id="36029" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="36031" class="String">&quot;n&quot;</a> <a id="36035" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
       <a id="36044" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="36049" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36051" class="String">&quot;m&quot;</a> <a id="36055" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="36062" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36064" class="String">&quot;n&quot;</a> <a id="36068" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="36073" class="String">&quot;m&quot;</a> <a id="36077" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a>
       <a id="36086" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
       <a id="36098" class="Symbol">((</a><a id="36100" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="36102" class="String">&quot;+&quot;</a> <a id="36106" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a>
         <a id="36117" class="Symbol">(</a><a id="36118" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="36120" class="String">&quot;m&quot;</a> <a id="36124" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
          <a id="36136" class="Symbol">(</a><a id="36137" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="36139" class="String">&quot;n&quot;</a> <a id="36143" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
           <a id="36156" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="36161" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36163" class="String">&quot;m&quot;</a> <a id="36167" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="36174" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36176" class="String">&quot;n&quot;</a> <a id="36180" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="36185" class="String">&quot;m&quot;</a> <a id="36189" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a> <a id="36191" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="36196" class="Symbol">(</a><a id="36197" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36199" class="String">&quot;+&quot;</a> <a id="36203" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36205" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36207" class="String">&quot;m&quot;</a> <a id="36211" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36213" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36215" class="String">&quot;n&quot;</a><a id="36218" class="Symbol">)</a>
           <a id="36231" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="36232" class="Symbol">)))</a>
        <a id="36244" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36246" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36248" class="String">&quot;m&quot;</a>
        <a id="36260" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36262" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36264" class="String">&quot;n&quot;</a><a id="36267" class="Symbol">)</a>
       <a id="36276" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="36277" class="Symbol">))</a>
     <a id="36285" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36287" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="36292" href="../Lambda/#5652" class="InductiveConstructor">`zero</a>
     <a id="36303" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36305" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="36310" class="Symbol">(</a><a id="36311" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="36316" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="36321" class="Symbol">))</a>
   <a id="36327" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="36331" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="36337" class="Symbol">(</a><a id="36338" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="36343" class="Symbol">(</a><a id="36344" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="36348" class="Symbol">(</a><a id="36349" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="36355" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="36361" class="Symbol">)))</a> <a id="36365" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="36371" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
    <a id="36380" class="Symbol">((</a><a id="36382" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="36384" class="String">&quot;n&quot;</a> <a id="36388" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
      <a id="36396" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="36401" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="36406" href="../Lambda/#5652" class="InductiveConstructor">`zero</a> <a id="36412" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="36419" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36421" class="String">&quot;n&quot;</a> <a id="36425" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="36430" class="String">&quot;m&quot;</a> <a id="36434" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a>
      <a id="36442" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
      <a id="36453" class="Symbol">((</a><a id="36455" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="36457" class="String">&quot;+&quot;</a> <a id="36461" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a>
        <a id="36471" class="Symbol">(</a><a id="36472" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="36474" class="String">&quot;m&quot;</a> <a id="36478" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
         <a id="36489" class="Symbol">(</a><a id="36490" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="36492" class="String">&quot;n&quot;</a> <a id="36496" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
          <a id="36508" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="36513" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36515" class="String">&quot;m&quot;</a> <a id="36519" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="36526" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36528" class="String">&quot;n&quot;</a> <a id="36532" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="36537" class="String">&quot;m&quot;</a> <a id="36541" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a> <a id="36543" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="36548" class="Symbol">(</a><a id="36549" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36551" class="String">&quot;+&quot;</a> <a id="36555" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36557" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36559" class="String">&quot;m&quot;</a> <a id="36563" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36565" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36567" class="String">&quot;n&quot;</a><a id="36570" class="Symbol">)</a>
          <a id="36582" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="36583" class="Symbol">)))</a>
       <a id="36594" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36596" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36598" class="String">&quot;m&quot;</a>
       <a id="36609" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36611" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36613" class="String">&quot;n&quot;</a><a id="36616" class="Symbol">)</a>
      <a id="36624" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="36625" class="Symbol">)</a>
     <a id="36632" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36634" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="36639" class="Symbol">(</a><a id="36640" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="36645" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="36650" class="Symbol">))</a>
   <a id="36656" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="36660" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="36666" class="Symbol">(</a><a id="36667" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="36671" class="Symbol">(</a><a id="36672" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="36678" class="Symbol">(</a><a id="36679" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="36685" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="36691" class="Symbol">)))</a> <a id="36695" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="36701" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
    <a id="36710" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="36715" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="36720" href="../Lambda/#5652" class="InductiveConstructor">`zero</a> <a id="36726" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="36733" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="36738" class="Symbol">(</a><a id="36739" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="36744" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="36749" class="Symbol">)</a> <a id="36751" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="36756" class="String">&quot;m&quot;</a> <a id="36760" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a>
    <a id="36766" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
    <a id="36775" class="Symbol">((</a><a id="36777" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="36779" class="String">&quot;+&quot;</a> <a id="36783" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a>
      <a id="36791" class="Symbol">(</a><a id="36792" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="36794" class="String">&quot;m&quot;</a> <a id="36798" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
       <a id="36807" class="Symbol">(</a><a id="36808" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="36810" class="String">&quot;n&quot;</a> <a id="36814" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
        <a id="36824" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="36829" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36831" class="String">&quot;m&quot;</a> <a id="36835" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="36842" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36844" class="String">&quot;n&quot;</a> <a id="36848" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="36853" class="String">&quot;m&quot;</a> <a id="36857" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a> <a id="36859" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="36864" class="Symbol">(</a><a id="36865" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36867" class="String">&quot;+&quot;</a> <a id="36871" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36873" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36875" class="String">&quot;m&quot;</a> <a id="36879" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36881" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36883" class="String">&quot;n&quot;</a><a id="36886" class="Symbol">)</a>
        <a id="36896" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="36897" class="Symbol">)))</a>
     <a id="36906" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36908" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="36910" class="String">&quot;m&quot;</a>
     <a id="36919" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="36921" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="36926" class="Symbol">(</a><a id="36927" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="36932" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="36937" class="Symbol">))</a>
    <a id="36944" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a>
   <a id="36949" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="36953" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="36959" class="Symbol">(</a><a id="36960" href="../Lambda/#28690" class="InductiveConstructor">β-suc</a> <a id="36966" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="36972" class="Symbol">)</a> <a id="36974" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="36980" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
    <a id="36989" class="Symbol">(</a><a id="36990" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
     <a id="37000" class="Symbol">((</a><a id="37002" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="37004" class="String">&quot;+&quot;</a> <a id="37008" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a>
       <a id="37017" class="Symbol">(</a><a id="37018" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="37020" class="String">&quot;m&quot;</a> <a id="37024" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
        <a id="37034" class="Symbol">(</a><a id="37035" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="37037" class="String">&quot;n&quot;</a> <a id="37041" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
         <a id="37052" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="37057" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37059" class="String">&quot;m&quot;</a> <a id="37063" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="37070" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37072" class="String">&quot;n&quot;</a> <a id="37076" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="37081" class="String">&quot;m&quot;</a> <a id="37085" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a> <a id="37087" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="37092" class="Symbol">(</a><a id="37093" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37095" class="String">&quot;+&quot;</a> <a id="37099" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37101" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37103" class="String">&quot;m&quot;</a> <a id="37107" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37109" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37111" class="String">&quot;n&quot;</a><a id="37114" class="Symbol">)</a>
         <a id="37125" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="37126" class="Symbol">)))</a>
      <a id="37136" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37138" href="../Lambda/#5652" class="InductiveConstructor">`zero</a>
      <a id="37150" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37152" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="37157" class="Symbol">(</a><a id="37158" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="37163" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="37168" class="Symbol">)))</a>
   <a id="37175" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="37179" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="37185" class="Symbol">(</a><a id="37186" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="37192" class="Symbol">(</a><a id="37193" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="37198" class="Symbol">(</a><a id="37199" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="37204" href="../Lambda/#28841" class="InductiveConstructor">β-μ</a><a id="37207" class="Symbol">)))</a> <a id="37211" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="37217" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
    <a id="37226" class="Symbol">(</a><a id="37227" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
     <a id="37237" class="Symbol">((</a><a id="37239" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="37241" class="String">&quot;m&quot;</a> <a id="37245" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
       <a id="37254" class="Symbol">(</a><a id="37255" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="37257" class="String">&quot;n&quot;</a> <a id="37261" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
        <a id="37271" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="37276" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37278" class="String">&quot;m&quot;</a> <a id="37282" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="37289" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37291" class="String">&quot;n&quot;</a> <a id="37295" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="37300" class="String">&quot;m&quot;</a> <a id="37304" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a>
        <a id="37314" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
        <a id="37327" class="Symbol">((</a><a id="37329" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="37331" class="String">&quot;+&quot;</a> <a id="37335" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a>
          <a id="37347" class="Symbol">(</a><a id="37348" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="37350" class="String">&quot;m&quot;</a> <a id="37354" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
           <a id="37367" class="Symbol">(</a><a id="37368" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="37370" class="String">&quot;n&quot;</a> <a id="37374" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
            <a id="37388" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="37393" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37395" class="String">&quot;m&quot;</a> <a id="37399" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="37406" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37408" class="String">&quot;n&quot;</a> <a id="37412" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="37417" class="String">&quot;m&quot;</a> <a id="37421" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a> <a id="37423" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="37428" class="Symbol">(</a><a id="37429" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37431" class="String">&quot;+&quot;</a> <a id="37435" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37437" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37439" class="String">&quot;m&quot;</a> <a id="37443" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37445" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37447" class="String">&quot;n&quot;</a><a id="37450" class="Symbol">)</a>
            <a id="37464" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="37465" class="Symbol">)))</a>
         <a id="37478" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37480" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37482" class="String">&quot;m&quot;</a>
         <a id="37495" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37497" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37499" class="String">&quot;n&quot;</a><a id="37502" class="Symbol">)</a>
        <a id="37512" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="37513" class="Symbol">))</a>
      <a id="37522" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37524" href="../Lambda/#5652" class="InductiveConstructor">`zero</a>
      <a id="37536" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37538" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="37543" class="Symbol">(</a><a id="37544" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="37549" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="37554" class="Symbol">)))</a>
   <a id="37561" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="37565" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="37571" class="Symbol">(</a><a id="37572" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="37578" class="Symbol">(</a><a id="37579" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="37584" class="Symbol">(</a><a id="37585" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="37589" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="37595" class="Symbol">)))</a> <a id="37599" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="37605" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
    <a id="37614" class="Symbol">(</a><a id="37615" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
     <a id="37625" class="Symbol">((</a><a id="37627" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="37629" class="String">&quot;n&quot;</a> <a id="37633" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
       <a id="37642" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="37647" href="../Lambda/#5652" class="InductiveConstructor">`zero</a> <a id="37653" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="37660" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37662" class="String">&quot;n&quot;</a> <a id="37666" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="37671" class="String">&quot;m&quot;</a> <a id="37675" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a>
       <a id="37684" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
       <a id="37696" class="Symbol">((</a><a id="37698" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="37700" class="String">&quot;+&quot;</a> <a id="37704" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a>
         <a id="37715" class="Symbol">(</a><a id="37716" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="37718" class="String">&quot;m&quot;</a> <a id="37722" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
          <a id="37734" class="Symbol">(</a><a id="37735" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="37737" class="String">&quot;n&quot;</a> <a id="37741" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
           <a id="37754" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="37759" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37761" class="String">&quot;m&quot;</a> <a id="37765" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="37772" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37774" class="String">&quot;n&quot;</a> <a id="37778" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="37783" class="String">&quot;m&quot;</a> <a id="37787" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a> <a id="37789" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="37794" class="Symbol">(</a><a id="37795" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37797" class="String">&quot;+&quot;</a> <a id="37801" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37803" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37805" class="String">&quot;m&quot;</a> <a id="37809" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37811" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37813" class="String">&quot;n&quot;</a><a id="37816" class="Symbol">)</a>
           <a id="37829" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="37830" class="Symbol">)))</a>
        <a id="37842" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37844" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37846" class="String">&quot;m&quot;</a>
        <a id="37858" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37860" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="37862" class="String">&quot;n&quot;</a><a id="37865" class="Symbol">)</a>
       <a id="37874" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="37875" class="Symbol">)</a>
      <a id="37883" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="37885" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="37890" class="Symbol">(</a><a id="37891" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="37896" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="37901" class="Symbol">)))</a>
   <a id="37908" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="37912" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="37918" class="Symbol">(</a><a id="37919" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="37925" class="Symbol">(</a><a id="37926" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="37930" class="Symbol">(</a><a id="37931" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="37937" class="Symbol">(</a><a id="37938" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="37944" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="37950" class="Symbol">))))</a> <a id="37955" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="37961" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
    <a id="37970" class="Symbol">(</a><a id="37971" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
     <a id="37981" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="37986" href="../Lambda/#5652" class="InductiveConstructor">`zero</a> <a id="37992" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="37999" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="38004" class="Symbol">(</a><a id="38005" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="38010" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="38015" class="Symbol">)</a> <a id="38017" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="38022" class="String">&quot;m&quot;</a> <a id="38026" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a>
     <a id="38033" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a>
     <a id="38043" class="Symbol">((</a><a id="38045" href="../Lambda/#5787" class="InductiveConstructor Operator">μ</a> <a id="38047" class="String">&quot;+&quot;</a> <a id="38051" href="../Lambda/#5787" class="InductiveConstructor Operator">⇒</a>
       <a id="38060" class="Symbol">(</a><a id="38061" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38063" class="String">&quot;m&quot;</a> <a id="38067" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
        <a id="38077" class="Symbol">(</a><a id="38078" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38080" class="String">&quot;n&quot;</a> <a id="38084" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
         <a id="38095" href="../Lambda/#5727" class="InductiveConstructor Operator">case</a> <a id="38100" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38102" class="String">&quot;m&quot;</a> <a id="38106" href="../Lambda/#5727" class="InductiveConstructor Operator">[zero⇒</a> <a id="38113" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38115" class="String">&quot;n&quot;</a> <a id="38119" href="../Lambda/#5727" class="InductiveConstructor Operator">|suc</a> <a id="38124" class="String">&quot;m&quot;</a> <a id="38128" href="../Lambda/#5727" class="InductiveConstructor Operator">⇒</a> <a id="38130" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="38135" class="Symbol">(</a><a id="38136" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38138" class="String">&quot;+&quot;</a> <a id="38142" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38144" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38146" class="String">&quot;m&quot;</a> <a id="38150" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38152" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38154" class="String">&quot;n&quot;</a><a id="38157" class="Symbol">)</a>
         <a id="38168" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="38169" class="Symbol">)))</a>
      <a id="38179" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38181" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38183" class="String">&quot;m&quot;</a>
      <a id="38193" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38195" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="38200" class="Symbol">(</a><a id="38201" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="38206" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="38211" class="Symbol">))</a>
     <a id="38219" href="../Lambda/#5727" class="InductiveConstructor Operator">]</a><a id="38220" class="Symbol">)</a>
   <a id="38225" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="38229" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="38235" class="Symbol">(</a><a id="38236" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="38242" href="../Lambda/#28577" class="InductiveConstructor">β-zero</a><a id="38248" class="Symbol">)</a> <a id="38250" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="38256" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="38261" class="Symbol">(</a><a id="38262" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="38267" class="Symbol">(</a><a id="38268" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="38273" class="Symbol">(</a><a id="38274" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="38279" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="38284" class="Symbol">)))</a>
   <a id="38291" href="../Lambda/#31695" class="InductiveConstructor Operator">∎</a><a id="38292" class="Symbol">)</a>
   <a id="38297" class="Symbol">(</a><a id="38298" href="../Properties/#30917" class="InductiveConstructor">done</a> <a id="38303" class="Symbol">(</a><a id="38304" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="38310" class="Symbol">(</a><a id="38311" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="38317" class="Symbol">(</a><a id="38318" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="38324" class="Symbol">(</a><a id="38325" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="38331" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="38337" class="Symbol">)))))</a>
<a id="38343" class="Symbol">_</a> <a id="38345" class="Symbol">=</a> <a id="38347" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>Again, the derivation in the previous chapter was derived by editing the above.</p>
Similarly, we can evaluate the corresponding term for Church numerals:
<pre class="Agda"><a id="38512" href="../Properties/#38512" class="Function">_</a> <a id="38514" class="Symbol">:</a> <a id="38516" href="../Properties/#31408" class="Function">eval</a> <a id="38521" class="Symbol">(</a><a id="38522" href="../Properties/#30718" class="InductiveConstructor">gas</a> <a id="38526" class="Number">100</a><a id="38529" class="Symbol">)</a> <a id="38531" href="../Lambda/#51657" class="Function">⊢2+2ᶜ</a> <a id="38537" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a>
  <a id="38541" href="../Properties/#31224" class="InductiveConstructor">steps</a>
   <a id="38550" class="Symbol">((</a><a id="38552" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38554" class="String">&quot;m&quot;</a> <a id="38558" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
     <a id="38565" class="Symbol">(</a><a id="38566" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38568" class="String">&quot;n&quot;</a> <a id="38572" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
      <a id="38580" class="Symbol">(</a><a id="38581" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38583" class="String">&quot;s&quot;</a> <a id="38587" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="38589" class="Symbol">(</a><a id="38590" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38592" class="String">&quot;z&quot;</a> <a id="38596" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="38598" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38600" class="String">&quot;m&quot;</a> <a id="38604" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38606" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38608" class="String">&quot;s&quot;</a> <a id="38612" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38614" class="Symbol">(</a><a id="38615" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38617" class="String">&quot;n&quot;</a> <a id="38621" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38623" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38625" class="String">&quot;s&quot;</a> <a id="38629" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38631" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38633" class="String">&quot;z&quot;</a><a id="38636" class="Symbol">)))))</a>
    <a id="38646" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38648" class="Symbol">(</a><a id="38649" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38651" class="String">&quot;s&quot;</a> <a id="38655" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="38657" class="Symbol">(</a><a id="38658" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38660" class="String">&quot;z&quot;</a> <a id="38664" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="38666" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38668" class="String">&quot;s&quot;</a> <a id="38672" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38674" class="Symbol">(</a><a id="38675" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38677" class="String">&quot;s&quot;</a> <a id="38681" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38683" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38685" class="String">&quot;z&quot;</a><a id="38688" class="Symbol">)))</a>
    <a id="38696" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38698" class="Symbol">(</a><a id="38699" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38701" class="String">&quot;s&quot;</a> <a id="38705" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="38707" class="Symbol">(</a><a id="38708" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38710" class="String">&quot;z&quot;</a> <a id="38714" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="38716" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38718" class="String">&quot;s&quot;</a> <a id="38722" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38724" class="Symbol">(</a><a id="38725" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38727" class="String">&quot;s&quot;</a> <a id="38731" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38733" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38735" class="String">&quot;z&quot;</a><a id="38738" class="Symbol">)))</a>
    <a id="38746" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38748" class="Symbol">(</a><a id="38749" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38751" class="String">&quot;n&quot;</a> <a id="38755" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="38757" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="38762" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38764" class="String">&quot;n&quot;</a><a id="38767" class="Symbol">)</a>
    <a id="38773" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38775" href="../Lambda/#5652" class="InductiveConstructor">`zero</a>
   <a id="38784" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="38788" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="38793" class="Symbol">(</a><a id="38794" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="38799" class="Symbol">(</a><a id="38800" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="38805" class="Symbol">(</a><a id="38806" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="38810" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a><a id="38813" class="Symbol">)))</a> <a id="38817" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="38823" class="Symbol">(</a><a id="38824" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38826" class="String">&quot;n&quot;</a> <a id="38830" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
     <a id="38837" class="Symbol">(</a><a id="38838" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38840" class="String">&quot;s&quot;</a> <a id="38844" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
      <a id="38852" class="Symbol">(</a><a id="38853" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38855" class="String">&quot;z&quot;</a> <a id="38859" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
       <a id="38868" class="Symbol">(</a><a id="38869" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38871" class="String">&quot;s&quot;</a> <a id="38875" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="38877" class="Symbol">(</a><a id="38878" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38880" class="String">&quot;z&quot;</a> <a id="38884" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="38886" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38888" class="String">&quot;s&quot;</a> <a id="38892" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38894" class="Symbol">(</a><a id="38895" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38897" class="String">&quot;s&quot;</a> <a id="38901" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38903" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38905" class="String">&quot;z&quot;</a><a id="38908" class="Symbol">)))</a> <a id="38912" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38914" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38916" class="String">&quot;s&quot;</a> <a id="38920" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a>
       <a id="38929" class="Symbol">(</a><a id="38930" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38932" class="String">&quot;n&quot;</a> <a id="38936" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38938" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38940" class="String">&quot;s&quot;</a> <a id="38944" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38946" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38948" class="String">&quot;z&quot;</a><a id="38951" class="Symbol">))))</a>
    <a id="38960" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38962" class="Symbol">(</a><a id="38963" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38965" class="String">&quot;s&quot;</a> <a id="38969" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="38971" class="Symbol">(</a><a id="38972" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="38974" class="String">&quot;z&quot;</a> <a id="38978" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="38980" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38982" class="String">&quot;s&quot;</a> <a id="38986" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38988" class="Symbol">(</a><a id="38989" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38991" class="String">&quot;s&quot;</a> <a id="38995" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="38997" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="38999" class="String">&quot;z&quot;</a><a id="39002" class="Symbol">)))</a>
    <a id="39010" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39012" class="Symbol">(</a><a id="39013" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39015" class="String">&quot;n&quot;</a> <a id="39019" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39021" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="39026" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39028" class="String">&quot;n&quot;</a><a id="39031" class="Symbol">)</a>
    <a id="39037" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39039" href="../Lambda/#5652" class="InductiveConstructor">`zero</a>
   <a id="39048" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="39052" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="39057" class="Symbol">(</a><a id="39058" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="39063" class="Symbol">(</a><a id="39064" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="39068" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a><a id="39071" class="Symbol">))</a> <a id="39074" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="39080" class="Symbol">(</a><a id="39081" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39083" class="String">&quot;s&quot;</a> <a id="39087" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
     <a id="39094" class="Symbol">(</a><a id="39095" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39097" class="String">&quot;z&quot;</a> <a id="39101" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
      <a id="39109" class="Symbol">(</a><a id="39110" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39112" class="String">&quot;s&quot;</a> <a id="39116" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39118" class="Symbol">(</a><a id="39119" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39121" class="String">&quot;z&quot;</a> <a id="39125" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39127" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39129" class="String">&quot;s&quot;</a> <a id="39133" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39135" class="Symbol">(</a><a id="39136" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39138" class="String">&quot;s&quot;</a> <a id="39142" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39144" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39146" class="String">&quot;z&quot;</a><a id="39149" class="Symbol">)))</a> <a id="39153" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39155" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39157" class="String">&quot;s&quot;</a> <a id="39161" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a>
      <a id="39169" class="Symbol">((</a><a id="39171" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39173" class="String">&quot;s&quot;</a> <a id="39177" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39179" class="Symbol">(</a><a id="39180" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39182" class="String">&quot;z&quot;</a> <a id="39186" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39188" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39190" class="String">&quot;s&quot;</a> <a id="39194" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39196" class="Symbol">(</a><a id="39197" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39199" class="String">&quot;s&quot;</a> <a id="39203" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39205" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39207" class="String">&quot;z&quot;</a><a id="39210" class="Symbol">)))</a> <a id="39214" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39216" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39218" class="String">&quot;s&quot;</a> <a id="39222" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39224" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39226" class="String">&quot;z&quot;</a><a id="39229" class="Symbol">)))</a>
    <a id="39237" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39239" class="Symbol">(</a><a id="39240" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39242" class="String">&quot;n&quot;</a> <a id="39246" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39248" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="39253" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39255" class="String">&quot;n&quot;</a><a id="39258" class="Symbol">)</a>
    <a id="39264" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39266" href="../Lambda/#5652" class="InductiveConstructor">`zero</a>
   <a id="39275" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="39279" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="39284" class="Symbol">(</a><a id="39285" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="39289" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a><a id="39292" class="Symbol">)</a> <a id="39294" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="39300" class="Symbol">(</a><a id="39301" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39303" class="String">&quot;z&quot;</a> <a id="39307" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a>
     <a id="39314" class="Symbol">(</a><a id="39315" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39317" class="String">&quot;s&quot;</a> <a id="39321" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39323" class="Symbol">(</a><a id="39324" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39326" class="String">&quot;z&quot;</a> <a id="39330" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39332" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39334" class="String">&quot;s&quot;</a> <a id="39338" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39340" class="Symbol">(</a><a id="39341" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39343" class="String">&quot;s&quot;</a> <a id="39347" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39349" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39351" class="String">&quot;z&quot;</a><a id="39354" class="Symbol">)))</a> <a id="39358" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39360" class="Symbol">(</a><a id="39361" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39363" class="String">&quot;n&quot;</a> <a id="39367" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39369" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="39374" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39376" class="String">&quot;n&quot;</a><a id="39379" class="Symbol">)</a>
     <a id="39386" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a>
     <a id="39393" class="Symbol">((</a><a id="39395" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39397" class="String">&quot;s&quot;</a> <a id="39401" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39403" class="Symbol">(</a><a id="39404" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39406" class="String">&quot;z&quot;</a> <a id="39410" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39412" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39414" class="String">&quot;s&quot;</a> <a id="39418" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39420" class="Symbol">(</a><a id="39421" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39423" class="String">&quot;s&quot;</a> <a id="39427" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39429" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39431" class="String">&quot;z&quot;</a><a id="39434" class="Symbol">)))</a> <a id="39438" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39440" class="Symbol">(</a><a id="39441" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39443" class="String">&quot;n&quot;</a> <a id="39447" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39449" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="39454" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39456" class="String">&quot;n&quot;</a><a id="39459" class="Symbol">)</a>
      <a id="39467" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39469" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39471" class="String">&quot;z&quot;</a><a id="39474" class="Symbol">))</a>
    <a id="39481" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39483" href="../Lambda/#5652" class="InductiveConstructor">`zero</a>
   <a id="39492" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="39496" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="39500" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a> <a id="39507" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="39513" class="Symbol">(</a><a id="39514" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39516" class="String">&quot;s&quot;</a> <a id="39520" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39522" class="Symbol">(</a><a id="39523" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39525" class="String">&quot;z&quot;</a> <a id="39529" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39531" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39533" class="String">&quot;s&quot;</a> <a id="39537" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39539" class="Symbol">(</a><a id="39540" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39542" class="String">&quot;s&quot;</a> <a id="39546" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39548" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39550" class="String">&quot;z&quot;</a><a id="39553" class="Symbol">)))</a> <a id="39557" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39559" class="Symbol">(</a><a id="39560" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39562" class="String">&quot;n&quot;</a> <a id="39566" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39568" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="39573" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39575" class="String">&quot;n&quot;</a><a id="39578" class="Symbol">)</a>
    <a id="39584" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a>
    <a id="39590" class="Symbol">((</a><a id="39592" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39594" class="String">&quot;s&quot;</a> <a id="39598" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39600" class="Symbol">(</a><a id="39601" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39603" class="String">&quot;z&quot;</a> <a id="39607" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39609" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39611" class="String">&quot;s&quot;</a> <a id="39615" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39617" class="Symbol">(</a><a id="39618" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39620" class="String">&quot;s&quot;</a> <a id="39624" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39626" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39628" class="String">&quot;z&quot;</a><a id="39631" class="Symbol">)))</a> <a id="39635" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39637" class="Symbol">(</a><a id="39638" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39640" class="String">&quot;n&quot;</a> <a id="39644" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39646" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="39651" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39653" class="String">&quot;n&quot;</a><a id="39656" class="Symbol">)</a>
     <a id="39663" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39665" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="39670" class="Symbol">)</a>
   <a id="39675" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="39679" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="39684" class="Symbol">(</a><a id="39685" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="39689" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a><a id="39692" class="Symbol">)</a> <a id="39694" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="39700" class="Symbol">(</a><a id="39701" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39703" class="String">&quot;z&quot;</a> <a id="39707" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39709" class="Symbol">(</a><a id="39710" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39712" class="String">&quot;n&quot;</a> <a id="39716" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39718" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="39723" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39725" class="String">&quot;n&quot;</a><a id="39728" class="Symbol">)</a> <a id="39730" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39732" class="Symbol">((</a><a id="39734" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39736" class="String">&quot;n&quot;</a> <a id="39740" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39742" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="39747" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39749" class="String">&quot;n&quot;</a><a id="39752" class="Symbol">)</a> <a id="39754" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39756" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39758" class="String">&quot;z&quot;</a><a id="39761" class="Symbol">))</a> <a id="39764" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a>
    <a id="39770" class="Symbol">((</a><a id="39772" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39774" class="String">&quot;s&quot;</a> <a id="39778" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39780" class="Symbol">(</a><a id="39781" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39783" class="String">&quot;z&quot;</a> <a id="39787" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39789" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39791" class="String">&quot;s&quot;</a> <a id="39795" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39797" class="Symbol">(</a><a id="39798" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39800" class="String">&quot;s&quot;</a> <a id="39804" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39806" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39808" class="String">&quot;z&quot;</a><a id="39811" class="Symbol">)))</a> <a id="39815" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39817" class="Symbol">(</a><a id="39818" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39820" class="String">&quot;n&quot;</a> <a id="39824" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39826" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="39831" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39833" class="String">&quot;n&quot;</a><a id="39836" class="Symbol">)</a>
     <a id="39843" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39845" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="39850" class="Symbol">)</a>
   <a id="39855" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="39859" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="39864" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a> <a id="39868" class="Symbol">(</a><a id="39869" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="39874" class="Symbol">(</a><a id="39875" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="39879" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a><a id="39882" class="Symbol">))</a> <a id="39885" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="39891" class="Symbol">(</a><a id="39892" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39894" class="String">&quot;z&quot;</a> <a id="39898" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39900" class="Symbol">(</a><a id="39901" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39903" class="String">&quot;n&quot;</a> <a id="39907" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39909" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="39914" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39916" class="String">&quot;n&quot;</a><a id="39919" class="Symbol">)</a> <a id="39921" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39923" class="Symbol">((</a><a id="39925" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39927" class="String">&quot;n&quot;</a> <a id="39931" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39933" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="39938" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39940" class="String">&quot;n&quot;</a><a id="39943" class="Symbol">)</a> <a id="39945" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39947" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39949" class="String">&quot;z&quot;</a><a id="39952" class="Symbol">))</a> <a id="39955" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a>
    <a id="39961" class="Symbol">((</a><a id="39963" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39965" class="String">&quot;z&quot;</a> <a id="39969" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39971" class="Symbol">(</a><a id="39972" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39974" class="String">&quot;n&quot;</a> <a id="39978" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="39980" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="39985" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="39987" class="String">&quot;n&quot;</a><a id="39990" class="Symbol">)</a> <a id="39992" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="39994" class="Symbol">((</a><a id="39996" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="39998" class="String">&quot;n&quot;</a> <a id="40002" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40004" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40009" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40011" class="String">&quot;n&quot;</a><a id="40014" class="Symbol">)</a> <a id="40016" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="40018" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40020" class="String">&quot;z&quot;</a><a id="40023" class="Symbol">))</a> <a id="40026" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a>
     <a id="40033" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="40038" class="Symbol">)</a>
   <a id="40043" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="40047" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="40052" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a> <a id="40056" class="Symbol">(</a><a id="40057" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="40061" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="40067" class="Symbol">)</a> <a id="40069" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="40075" class="Symbol">(</a><a id="40076" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40078" class="String">&quot;z&quot;</a> <a id="40082" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40084" class="Symbol">(</a><a id="40085" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40087" class="String">&quot;n&quot;</a> <a id="40091" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40093" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40098" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40100" class="String">&quot;n&quot;</a><a id="40103" class="Symbol">)</a> <a id="40105" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="40107" class="Symbol">((</a><a id="40109" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40111" class="String">&quot;n&quot;</a> <a id="40115" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40117" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40122" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40124" class="String">&quot;n&quot;</a><a id="40127" class="Symbol">)</a> <a id="40129" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="40131" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40133" class="String">&quot;z&quot;</a><a id="40136" class="Symbol">))</a> <a id="40139" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a>
    <a id="40145" class="Symbol">((</a><a id="40147" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40149" class="String">&quot;n&quot;</a> <a id="40153" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40155" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40160" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40162" class="String">&quot;n&quot;</a><a id="40165" class="Symbol">)</a> <a id="40167" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="40169" class="Symbol">((</a><a id="40171" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40173" class="String">&quot;n&quot;</a> <a id="40177" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40179" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40184" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40186" class="String">&quot;n&quot;</a><a id="40189" class="Symbol">)</a> <a id="40191" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="40193" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="40198" class="Symbol">))</a>
   <a id="40204" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="40208" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="40213" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a> <a id="40217" class="Symbol">(</a><a id="40218" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="40223" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a> <a id="40227" class="Symbol">(</a><a id="40228" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="40232" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="40238" class="Symbol">))</a> <a id="40241" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="40247" class="Symbol">(</a><a id="40248" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40250" class="String">&quot;z&quot;</a> <a id="40254" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40256" class="Symbol">(</a><a id="40257" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40259" class="String">&quot;n&quot;</a> <a id="40263" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40265" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40270" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40272" class="String">&quot;n&quot;</a><a id="40275" class="Symbol">)</a> <a id="40277" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="40279" class="Symbol">((</a><a id="40281" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40283" class="String">&quot;n&quot;</a> <a id="40287" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40289" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40294" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40296" class="String">&quot;n&quot;</a><a id="40299" class="Symbol">)</a> <a id="40301" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="40303" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40305" class="String">&quot;z&quot;</a><a id="40308" class="Symbol">))</a> <a id="40311" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a>
    <a id="40317" class="Symbol">((</a><a id="40319" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40321" class="String">&quot;n&quot;</a> <a id="40325" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40327" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40332" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40334" class="String">&quot;n&quot;</a><a id="40337" class="Symbol">)</a> <a id="40339" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="40341" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40346" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="40351" class="Symbol">)</a>
   <a id="40356" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="40360" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="40365" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a> <a id="40369" class="Symbol">(</a><a id="40370" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="40374" class="Symbol">(</a><a id="40375" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="40381" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="40387" class="Symbol">))</a> <a id="40390" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="40396" class="Symbol">(</a><a id="40397" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40399" class="String">&quot;z&quot;</a> <a id="40403" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40405" class="Symbol">(</a><a id="40406" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40408" class="String">&quot;n&quot;</a> <a id="40412" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40414" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40419" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40421" class="String">&quot;n&quot;</a><a id="40424" class="Symbol">)</a> <a id="40426" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="40428" class="Symbol">((</a><a id="40430" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40432" class="String">&quot;n&quot;</a> <a id="40436" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40438" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40443" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40445" class="String">&quot;n&quot;</a><a id="40448" class="Symbol">)</a> <a id="40450" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="40452" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40454" class="String">&quot;z&quot;</a><a id="40457" class="Symbol">))</a> <a id="40460" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a>
    <a id="40466" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40471" class="Symbol">(</a><a id="40472" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40477" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="40482" class="Symbol">)</a>
   <a id="40487" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="40491" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="40495" class="Symbol">(</a><a id="40496" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="40502" class="Symbol">(</a><a id="40503" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="40509" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="40515" class="Symbol">))</a> <a id="40518" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="40524" class="Symbol">(</a><a id="40525" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40527" class="String">&quot;n&quot;</a> <a id="40531" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40533" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40538" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40540" class="String">&quot;n&quot;</a><a id="40543" class="Symbol">)</a> <a id="40545" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="40547" class="Symbol">((</a><a id="40549" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40551" class="String">&quot;n&quot;</a> <a id="40555" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40557" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40562" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40564" class="String">&quot;n&quot;</a><a id="40567" class="Symbol">)</a> <a id="40569" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="40571" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40576" class="Symbol">(</a><a id="40577" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40582" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="40587" class="Symbol">))</a>
   <a id="40593" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="40597" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="40602" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a> <a id="40606" class="Symbol">(</a><a id="40607" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="40611" class="Symbol">(</a><a id="40612" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="40618" class="Symbol">(</a><a id="40619" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="40625" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="40631" class="Symbol">)))</a> <a id="40635" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="40641" class="Symbol">(</a><a id="40642" href="../Lambda/#5558" class="InductiveConstructor Operator">ƛ</a> <a id="40644" class="String">&quot;n&quot;</a> <a id="40648" href="../Lambda/#5558" class="InductiveConstructor Operator">⇒</a> <a id="40650" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40655" href="../Lambda/#5519" class="InductiveConstructor Operator">`</a> <a id="40657" class="String">&quot;n&quot;</a><a id="40660" class="Symbol">)</a> <a id="40662" href="../Lambda/#5604" class="InductiveConstructor Operator">·</a> <a id="40664" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40669" class="Symbol">(</a><a id="40670" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40675" class="Symbol">(</a><a id="40676" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40681" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="40686" class="Symbol">))</a>
   <a id="40692" href="../Lambda/#31736" class="InductiveConstructor Operator">—→⟨</a> <a id="40696" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="40700" class="Symbol">(</a><a id="40701" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="40707" class="Symbol">(</a><a id="40708" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="40714" class="Symbol">(</a><a id="40715" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="40721" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="40727" class="Symbol">)))</a> <a id="40731" href="../Lambda/#31736" class="InductiveConstructor Operator">⟩</a>
    <a id="40737" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40742" class="Symbol">(</a><a id="40743" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40748" class="Symbol">(</a><a id="40749" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40754" class="Symbol">(</a><a id="40755" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc</a> <a id="40760" href="../Lambda/#5652" class="InductiveConstructor">`zero</a><a id="40765" class="Symbol">)))</a>
   <a id="40772" href="../Lambda/#31695" class="InductiveConstructor Operator">∎</a><a id="40773" class="Symbol">)</a>
   <a id="40778" class="Symbol">(</a><a id="40779" href="../Properties/#30917" class="InductiveConstructor">done</a> <a id="40784" class="Symbol">(</a><a id="40785" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="40791" class="Symbol">(</a><a id="40792" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="40798" class="Symbol">(</a><a id="40799" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="40805" class="Symbol">(</a><a id="40806" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="40812" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a><a id="40818" class="Symbol">)))))</a>
<a id="40824" class="Symbol">_</a> <a id="40826" class="Symbol">=</a> <a id="40828" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>And again, the example in the previous section was derived by editing the above.</p>
<h4 id="exercise-mul-eval-recommended">Exercise <code>mul-eval</code> (recommended)</h4>
<p>Using the evaluator, confirm that two times two is four.</p>
<pre class="Agda"><a id="41021" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-progress-preservation-practice">Exercise: <code>progress-preservation</code> (practice)</h4>
<p>Without peeking at their statements above, write down the progress and preservation theorems for the simply typed lambda-calculus.</p>
<pre class="Agda"><a id="41237" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-subject_expansion-practice">Exercise <code>subject_expansion</code> (practice)</h4>
<p>We say that <code>M</code> <em>reduces</em> to <code>N</code> if <code>M —→ N</code>, but we can also describe the same situation by saying that <code>N</code> <em>expands</em> to <code>M</code>. The preservation property is sometimes called <em>subject reduction</em>. Its opposite is <em>subject expansion</em>, which holds if <code>M —→ N</code> and <code>∅ ⊢ N ⦂ A</code> imply <code>∅ ⊢ M ⦂ A</code>. Find two counter-examples to subject expansion, one with case expressions and one not involving case expressions.</p>
<pre class="Agda"><a id="41721" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="well-typed-terms-dont-get-stuck">Well-typed terms don’t get stuck</h2>
A term is <em>normal</em> if it cannot reduce:
<pre class="Agda"><a id="Normal"></a><a id="41831" href="../Properties/#41831" class="Function">Normal</a> <a id="41838" class="Symbol">:</a> <a id="41840" href="../Lambda/#5500" class="Datatype">Term</a> <a id="41845" class="Symbol">→</a> <a id="41847" class="PrimitiveType">Set</a>
<a id="41851" href="../Properties/#41831" class="Function">Normal</a> <a id="41858" href="../Properties/#41858" class="Bound">M</a>  <a id="41861" class="Symbol">=</a>  <a id="41864" class="Symbol">∀</a> <a id="41866" class="Symbol">{</a><a id="41867" href="../Properties/#41867" class="Bound">N</a><a id="41868" class="Symbol">}</a> <a id="41870" class="Symbol">→</a> <a id="41872" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="41874" class="Symbol">(</a><a id="41875" href="../Properties/#41858" class="Bound">M</a> <a id="41877" href="../Lambda/#27997" class="Datatype Operator">—→</a> <a id="41880" href="../Properties/#41867" class="Bound">N</a><a id="41881" class="Symbol">)</a>
</pre>
A term is <em>stuck</em> if it is normal yet not a value:
<pre class="Agda"><a id="Stuck"></a><a id="41943" href="../Properties/#41943" class="Function">Stuck</a> <a id="41949" class="Symbol">:</a> <a id="41951" href="../Lambda/#5500" class="Datatype">Term</a> <a id="41956" class="Symbol">→</a> <a id="41958" class="PrimitiveType">Set</a>
<a id="41962" href="../Properties/#41943" class="Function">Stuck</a> <a id="41968" href="../Properties/#41968" class="Bound">M</a>  <a id="41971" class="Symbol">=</a>  <a id="41974" href="../Properties/#41831" class="Function">Normal</a> <a id="41981" href="../Properties/#41968" class="Bound">M</a> <a id="41983" href="https://agda.github.io/agda-stdlib/v1.3/Data.Product.html#1167" class="Function Operator">×</a> <a id="41985" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="41987" href="../Lambda/#16914" class="Datatype">Value</a> <a id="41993" href="../Properties/#41968" class="Bound">M</a>
</pre>
Using progress, it is easy to show that no well-typed term is stuck:
<pre class="Agda"><a id="42073" class="Keyword">postulate</a>
  <a id="unstuck"></a><a id="42085" href="../Properties/#42085" class="Postulate">unstuck</a> <a id="42093" class="Symbol">:</a> <a id="42095" class="Symbol">∀</a> <a id="42097" class="Symbol">{</a><a id="42098" href="../Properties/#42098" class="Bound">M</a> <a id="42100" href="../Properties/#42100" class="Bound">A</a><a id="42101" class="Symbol">}</a>
    <a id="42107" class="Symbol">→</a> <a id="42109" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="42111" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="42113" href="../Properties/#42098" class="Bound">M</a> <a id="42115" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="42117" href="../Properties/#42100" class="Bound">A</a>
      <a id="42125" class="Comment">-----------</a>
    <a id="42141" class="Symbol">→</a> <a id="42143" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="42145" class="Symbol">(</a><a id="42146" href="../Properties/#41943" class="Function">Stuck</a> <a id="42152" href="../Properties/#42098" class="Bound">M</a><a id="42153" class="Symbol">)</a>
</pre>
Using preservation, it is easy to show that after any number of steps, a well-typed term remains well typed:
<pre class="Agda"><a id="42273" class="Keyword">postulate</a>
  <a id="preserves"></a><a id="42285" href="../Properties/#42285" class="Postulate">preserves</a> <a id="42295" class="Symbol">:</a> <a id="42297" class="Symbol">∀</a> <a id="42299" class="Symbol">{</a><a id="42300" href="../Properties/#42300" class="Bound">M</a> <a id="42302" href="../Properties/#42302" class="Bound">N</a> <a id="42304" href="../Properties/#42304" class="Bound">A</a><a id="42305" class="Symbol">}</a>
    <a id="42311" class="Symbol">→</a> <a id="42313" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="42315" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="42317" href="../Properties/#42300" class="Bound">M</a> <a id="42319" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="42321" href="../Properties/#42304" class="Bound">A</a>
    <a id="42327" class="Symbol">→</a> <a id="42329" href="../Properties/#42300" class="Bound">M</a> <a id="42331" href="../Lambda/#31662" class="Datatype Operator">—↠</a> <a id="42334" href="../Properties/#42302" class="Bound">N</a>
      <a id="42342" class="Comment">---------</a>
    <a id="42356" class="Symbol">→</a> <a id="42358" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="42360" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="42362" href="../Properties/#42302" class="Bound">N</a> <a id="42364" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="42366" href="../Properties/#42304" class="Bound">A</a>
</pre>
An easy consequence is that starting from a well-typed term, taking any number of reduction steps leads to a term that is not stuck:
<pre class="Agda"><a id="42510" class="Keyword">postulate</a>
  <a id="wttdgs"></a><a id="42522" href="../Properties/#42522" class="Postulate">wttdgs</a> <a id="42529" class="Symbol">:</a> <a id="42531" class="Symbol">∀</a> <a id="42533" class="Symbol">{</a><a id="42534" href="../Properties/#42534" class="Bound">M</a> <a id="42536" href="../Properties/#42536" class="Bound">N</a> <a id="42538" href="../Properties/#42538" class="Bound">A</a><a id="42539" class="Symbol">}</a>
    <a id="42545" class="Symbol">→</a> <a id="42547" href="../Lambda/#42153" class="InductiveConstructor">∅</a> <a id="42549" href="../Lambda/#46028" class="Datatype Operator">⊢</a> <a id="42551" href="../Properties/#42534" class="Bound">M</a> <a id="42553" href="../Lambda/#46028" class="Datatype Operator">⦂</a> <a id="42555" href="../Properties/#42538" class="Bound">A</a>
    <a id="42561" class="Symbol">→</a> <a id="42563" href="../Properties/#42534" class="Bound">M</a> <a id="42565" href="../Lambda/#31662" class="Datatype Operator">—↠</a> <a id="42568" href="../Properties/#42536" class="Bound">N</a>
      <a id="42576" class="Comment">-----------</a>
    <a id="42592" class="Symbol">→</a> <a id="42594" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="42596" class="Symbol">(</a><a id="42597" href="../Properties/#41943" class="Function">Stuck</a> <a id="42603" href="../Properties/#42536" class="Bound">N</a><a id="42604" class="Symbol">)</a>
</pre>
<p>Felleisen and Wright, who introduced proofs via progress and preservation, summarised this result with the slogan <em>well-typed terms don’t get stuck</em>. (They were referring to earlier work by Robin Milner, who used denotational rather than operational semantics. He introduced <code>wrong</code> as the denotation of a term with a type error, and showed <em>well-typed terms don’t go wrong</em>.)</p>
<h4 id="exercise-stuck-practice">Exercise <code>stuck</code> (practice)</h4>
<p>Give an example of an ill-typed term that does get stuck.</p>
<pre class="Agda"><a id="43086" class="Comment">-- Your code goes here</a>
</pre>
<h4 id="exercise-unstuck-recommended">Exercise <code>unstuck</code> (recommended)</h4>
<p>Provide proofs of the three postulates, <code>unstuck</code>, <code>preserves</code>, and <code>wttdgs</code> above.</p>
<pre class="Agda"><a id="43242" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="reduction-is-deterministic">Reduction is deterministic</h2>
<p>When we introduced reduction, we claimed it was deterministic. For completeness, we present a formal proof here.</p>
Our proof will need a variant of congruence to deal with functions of four arguments (to deal with <code>case_[zero⇒_|suc_⇒_]</code>). It is exactly analogous to <code>cong</code> and <code>cong₂</code> as defined previously:
<pre class="Agda"><a id="cong₄"></a><a id="43613" href="../Properties/#43613" class="Function">cong₄</a> <a id="43619" class="Symbol">:</a> <a id="43621" class="Symbol">∀</a> <a id="43623" class="Symbol">{</a><a id="43624" href="../Properties/#43624" class="Bound">A</a> <a id="43626" href="../Properties/#43626" class="Bound">B</a> <a id="43628" href="../Properties/#43628" class="Bound">C</a> <a id="43630" href="../Properties/#43630" class="Bound">D</a> <a id="43632" href="../Properties/#43632" class="Bound">E</a> <a id="43634" class="Symbol">:</a> <a id="43636" class="PrimitiveType">Set</a><a id="43639" class="Symbol">}</a> <a id="43641" class="Symbol">(</a><a id="43642" href="../Properties/#43642" class="Bound">f</a> <a id="43644" class="Symbol">:</a> <a id="43646" href="../Properties/#43624" class="Bound">A</a> <a id="43648" class="Symbol">→</a> <a id="43650" href="../Properties/#43626" class="Bound">B</a> <a id="43652" class="Symbol">→</a> <a id="43654" href="../Properties/#43628" class="Bound">C</a> <a id="43656" class="Symbol">→</a> <a id="43658" href="../Properties/#43630" class="Bound">D</a> <a id="43660" class="Symbol">→</a> <a id="43662" href="../Properties/#43632" class="Bound">E</a><a id="43663" class="Symbol">)</a>
  <a id="43667" class="Symbol">{</a><a id="43668" href="../Properties/#43668" class="Bound">s</a> <a id="43670" href="../Properties/#43670" class="Bound">w</a> <a id="43672" class="Symbol">:</a> <a id="43674" href="../Properties/#43624" class="Bound">A</a><a id="43675" class="Symbol">}</a> <a id="43677" class="Symbol">{</a><a id="43678" href="../Properties/#43678" class="Bound">t</a> <a id="43680" href="../Properties/#43680" class="Bound">x</a> <a id="43682" class="Symbol">:</a> <a id="43684" href="../Properties/#43626" class="Bound">B</a><a id="43685" class="Symbol">}</a> <a id="43687" class="Symbol">{</a><a id="43688" href="../Properties/#43688" class="Bound">u</a> <a id="43690" href="../Properties/#43690" class="Bound">y</a> <a id="43692" class="Symbol">:</a> <a id="43694" href="../Properties/#43628" class="Bound">C</a><a id="43695" class="Symbol">}</a> <a id="43697" class="Symbol">{</a><a id="43698" href="../Properties/#43698" class="Bound">v</a> <a id="43700" href="../Properties/#43700" class="Bound">z</a> <a id="43702" class="Symbol">:</a> <a id="43704" href="../Properties/#43630" class="Bound">D</a><a id="43705" class="Symbol">}</a>
  <a id="43709" class="Symbol">→</a> <a id="43711" href="../Properties/#43668" class="Bound">s</a> <a id="43713" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="43715" href="../Properties/#43670" class="Bound">w</a> <a id="43717" class="Symbol">→</a> <a id="43719" href="../Properties/#43678" class="Bound">t</a> <a id="43721" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="43723" href="../Properties/#43680" class="Bound">x</a> <a id="43725" class="Symbol">→</a> <a id="43727" href="../Properties/#43688" class="Bound">u</a> <a id="43729" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="43731" href="../Properties/#43690" class="Bound">y</a> <a id="43733" class="Symbol">→</a> <a id="43735" href="../Properties/#43698" class="Bound">v</a> <a id="43737" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="43739" href="../Properties/#43700" class="Bound">z</a> <a id="43741" class="Symbol">→</a> <a id="43743" href="../Properties/#43642" class="Bound">f</a> <a id="43745" href="../Properties/#43668" class="Bound">s</a> <a id="43747" href="../Properties/#43678" class="Bound">t</a> <a id="43749" href="../Properties/#43688" class="Bound">u</a> <a id="43751" href="../Properties/#43698" class="Bound">v</a> <a id="43753" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="43755" href="../Properties/#43642" class="Bound">f</a> <a id="43757" href="../Properties/#43670" class="Bound">w</a> <a id="43759" href="../Properties/#43680" class="Bound">x</a> <a id="43761" href="../Properties/#43690" class="Bound">y</a> <a id="43763" href="../Properties/#43700" class="Bound">z</a>
<a id="43765" href="../Properties/#43613" class="Function">cong₄</a> <a id="43771" href="../Properties/#43771" class="Bound">f</a> <a id="43773" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="43778" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="43783" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="43788" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="43793" class="Symbol">=</a> <a id="43795" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
It is now straightforward to show that reduction is deterministic:
<pre class="Agda"><a id="det"></a><a id="43876" href="../Properties/#43876" class="Function">det</a> <a id="43880" class="Symbol">:</a> <a id="43882" class="Symbol">∀</a> <a id="43884" class="Symbol">{</a><a id="43885" href="../Properties/#43885" class="Bound">M</a> <a id="43887" href="../Properties/#43887" class="Bound">M′</a> <a id="43890" href="../Properties/#43890" class="Bound">M″</a><a id="43892" class="Symbol">}</a>
  <a id="43896" class="Symbol">→</a> <a id="43898" class="Symbol">(</a><a id="43899" href="../Properties/#43885" class="Bound">M</a> <a id="43901" href="../Lambda/#27997" class="Datatype Operator">—→</a> <a id="43904" href="../Properties/#43887" class="Bound">M′</a><a id="43906" class="Symbol">)</a>
  <a id="43910" class="Symbol">→</a> <a id="43912" class="Symbol">(</a><a id="43913" href="../Properties/#43885" class="Bound">M</a> <a id="43915" href="../Lambda/#27997" class="Datatype Operator">—→</a> <a id="43918" href="../Properties/#43890" class="Bound">M″</a><a id="43920" class="Symbol">)</a>
    <a id="43926" class="Comment">--------</a>
  <a id="43937" class="Symbol">→</a> <a id="43939" href="../Properties/#43887" class="Bound">M′</a> <a id="43942" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="43944" href="../Properties/#43890" class="Bound">M″</a>
<a id="43947" href="../Properties/#43876" class="Function">det</a> <a id="43951" class="Symbol">(</a><a id="43952" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="43957" href="../Properties/#43957" class="Bound">L—→L′</a><a id="43962" class="Symbol">)</a>   <a id="43966" class="Symbol">(</a><a id="43967" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="43972" href="../Properties/#43972" class="Bound">L—→L″</a><a id="43977" class="Symbol">)</a>     <a id="43983" class="Symbol">=</a>  <a id="43986" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html#1524" class="Function">cong₂</a> <a id="43992" href="../Lambda/#5604" class="InductiveConstructor Operator">_·_</a> <a id="43996" class="Symbol">(</a><a id="43997" href="../Properties/#43876" class="Function">det</a> <a id="44001" href="../Properties/#43957" class="Bound">L—→L′</a> <a id="44007" href="../Properties/#43972" class="Bound">L—→L″</a><a id="44012" class="Symbol">)</a> <a id="44014" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="44019" href="../Properties/#43876" class="Function">det</a> <a id="44023" class="Symbol">(</a><a id="44024" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="44029" href="../Properties/#44029" class="Bound">L—→L′</a><a id="44034" class="Symbol">)</a>   <a id="44038" class="Symbol">(</a><a id="44039" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="44044" href="../Properties/#44044" class="Bound">VL</a> <a id="44047" href="../Properties/#44047" class="Bound">M—→M″</a><a id="44052" class="Symbol">)</a>  <a id="44055" class="Symbol">=</a>  <a id="44058" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="44065" class="Symbol">(</a><a id="44066" href="../Properties/#3521" class="Function">V¬—→</a> <a id="44071" href="../Properties/#44044" class="Bound">VL</a> <a id="44074" href="../Properties/#44029" class="Bound">L—→L′</a><a id="44079" class="Symbol">)</a>
<a id="44081" href="../Properties/#43876" class="Function">det</a> <a id="44085" class="Symbol">(</a><a id="44086" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="44091" href="../Properties/#44091" class="Bound">L—→L′</a><a id="44096" class="Symbol">)</a>   <a id="44100" class="Symbol">(</a><a id="44101" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="44105" class="Symbol">_)</a>          <a id="44117" class="Symbol">=</a>  <a id="44120" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="44127" class="Symbol">(</a><a id="44128" href="../Properties/#3521" class="Function">V¬—→</a> <a id="44133" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a> <a id="44137" href="../Properties/#44091" class="Bound">L—→L′</a><a id="44142" class="Symbol">)</a>
<a id="44144" href="../Properties/#43876" class="Function">det</a> <a id="44148" class="Symbol">(</a><a id="44149" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="44154" href="../Properties/#44154" class="Bound">VL</a> <a id="44157" class="Symbol">_)</a>    <a id="44163" class="Symbol">(</a><a id="44164" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="44169" href="../Properties/#44169" class="Bound">L—→L″</a><a id="44174" class="Symbol">)</a>     <a id="44180" class="Symbol">=</a>  <a id="44183" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="44190" class="Symbol">(</a><a id="44191" href="../Properties/#3521" class="Function">V¬—→</a> <a id="44196" href="../Properties/#44154" class="Bound">VL</a> <a id="44199" href="../Properties/#44169" class="Bound">L—→L″</a><a id="44204" class="Symbol">)</a>
<a id="44206" href="../Properties/#43876" class="Function">det</a> <a id="44210" class="Symbol">(</a><a id="44211" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="44216" class="Symbol">_</a> <a id="44218" href="../Properties/#44218" class="Bound">M—→M′</a><a id="44223" class="Symbol">)</a> <a id="44225" class="Symbol">(</a><a id="44226" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="44231" class="Symbol">_</a> <a id="44233" href="../Properties/#44233" class="Bound">M—→M″</a><a id="44238" class="Symbol">)</a>   <a id="44242" class="Symbol">=</a>  <a id="44245" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.html#1524" class="Function">cong₂</a> <a id="44251" href="../Lambda/#5604" class="InductiveConstructor Operator">_·_</a> <a id="44255" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="44260" class="Symbol">(</a><a id="44261" href="../Properties/#43876" class="Function">det</a> <a id="44265" href="../Properties/#44218" class="Bound">M—→M′</a> <a id="44271" href="../Properties/#44233" class="Bound">M—→M″</a><a id="44276" class="Symbol">)</a>
<a id="44278" href="../Properties/#43876" class="Function">det</a> <a id="44282" class="Symbol">(</a><a id="44283" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="44288" class="Symbol">_</a> <a id="44290" href="../Properties/#44290" class="Bound">M—→M′</a><a id="44295" class="Symbol">)</a> <a id="44297" class="Symbol">(</a><a id="44298" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="44302" href="../Properties/#44302" class="Bound">VM</a><a id="44304" class="Symbol">)</a>         <a id="44314" class="Symbol">=</a>  <a id="44317" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="44324" class="Symbol">(</a><a id="44325" href="../Properties/#3521" class="Function">V¬—→</a> <a id="44330" href="../Properties/#44302" class="Bound">VM</a> <a id="44333" href="../Properties/#44290" class="Bound">M—→M′</a><a id="44338" class="Symbol">)</a>
<a id="44340" href="../Properties/#43876" class="Function">det</a> <a id="44344" class="Symbol">(</a><a id="44345" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="44349" class="Symbol">_)</a>        <a id="44359" class="Symbol">(</a><a id="44360" href="../Lambda/#28031" class="InductiveConstructor">ξ-·₁</a> <a id="44365" href="../Properties/#44365" class="Bound">L—→L″</a><a id="44370" class="Symbol">)</a>     <a id="44376" class="Symbol">=</a>  <a id="44379" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="44386" class="Symbol">(</a><a id="44387" href="../Properties/#3521" class="Function">V¬—→</a> <a id="44392" href="../Lambda/#16942" class="InductiveConstructor">V-ƛ</a> <a id="44396" href="../Properties/#44365" class="Bound">L—→L″</a><a id="44401" class="Symbol">)</a>
<a id="44403" href="../Properties/#43876" class="Function">det</a> <a id="44407" class="Symbol">(</a><a id="44408" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="44412" href="../Properties/#44412" class="Bound">VM</a><a id="44414" class="Symbol">)</a>       <a id="44422" class="Symbol">(</a><a id="44423" href="../Lambda/#28112" class="InductiveConstructor">ξ-·₂</a> <a id="44428" class="Symbol">_</a> <a id="44430" href="../Properties/#44430" class="Bound">M—→M″</a><a id="44435" class="Symbol">)</a>   <a id="44439" class="Symbol">=</a>  <a id="44442" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="44449" class="Symbol">(</a><a id="44450" href="../Properties/#3521" class="Function">V¬—→</a> <a id="44455" href="../Properties/#44412" class="Bound">VM</a> <a id="44458" href="../Properties/#44430" class="Bound">M—→M″</a><a id="44463" class="Symbol">)</a>
<a id="44465" href="../Properties/#43876" class="Function">det</a> <a id="44469" class="Symbol">(</a><a id="44470" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="44474" class="Symbol">_)</a>        <a id="44484" class="Symbol">(</a><a id="44485" href="../Lambda/#28207" class="InductiveConstructor">β-ƛ</a> <a id="44489" class="Symbol">_)</a>          <a id="44501" class="Symbol">=</a>  <a id="44504" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="44509" href="../Properties/#43876" class="Function">det</a> <a id="44513" class="Symbol">(</a><a id="44514" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="44520" href="../Properties/#44520" class="Bound">M—→M′</a><a id="44525" class="Symbol">)</a>  <a id="44528" class="Symbol">(</a><a id="44529" href="../Lambda/#28313" class="InductiveConstructor">ξ-suc</a> <a id="44535" href="../Properties/#44535" class="Bound">M—→M″</a><a id="44540" class="Symbol">)</a>    <a id="44545" class="Symbol">=</a>  <a id="44548" href="https://agda.github.io/agda-stdlib/v1.3/Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="44553" href="../Lambda/#5686" class="InductiveConstructor Operator">`suc_</a> <a id="44559" class="Symbol">(</a><a id="44560" href="../Properties/#43876" class="Function">det</a> <a id="44564" href="../Properties/#44520" class="Bound">M—→M′</a> <a id="44570" href="../Properties/#44535" class="Bound">M—→M″</a><a id="44575" class="Symbol">)</a>
<a id="44577" href="../Properties/#43876" class="Function">det</a> <a id="44581" class="Symbol">(</a><a id="44582" href="../Lambda/#28396" class="InductiveConstructor">ξ-case</a> <a id="44589" href="../Properties/#44589" class="Bound">L—→L′</a><a id="44594" class="Symbol">)</a> <a id="44596" class="Symbol">(</a><a id="44597" href="../Lambda/#28396" class="InductiveConstructor">ξ-case</a> <a id="44604" href="../Properties/#44604" class="Bound">L—→L″</a><a id="44609" class="Symbol">)</a>   <a id="44613" class="Symbol">=</a>  <a id="44616" href="../Properties/#43613" class="Function">cong₄</a> <a id="44622" href="../Lambda/#5727" class="InductiveConstructor Operator">case_[zero⇒_|suc_⇒_]</a>
                                         <a id="44684" class="Symbol">(</a><a id="44685" href="../Properties/#43876" class="Function">det</a> <a id="44689" href="../Properties/#44589" class="Bound">L—→L′</a> <a id="44695" href="../Properties/#44604" class="Bound">L—→L″</a><a id="44700" class="Symbol">)</a> <a id="44702" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="44707" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="44712" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="44717" href="../Properties/#43876" class="Function">det</a> <a id="44721" class="Symbol">(</a><a id="44722" href="../Lambda/#28396" class="InductiveConstructor">ξ-case</a> <a id="44729" href="../Properties/#44729" class="Bound">L—→L′</a><a id="44734" class="Symbol">)</a> <a id="44736" href="../Lambda/#28577" class="InductiveConstructor">β-zero</a>           <a id="44753" class="Symbol">=</a>  <a id="44756" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="44763" class="Symbol">(</a><a id="44764" href="../Properties/#3521" class="Function">V¬—→</a> <a id="44769" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a> <a id="44776" href="../Properties/#44729" class="Bound">L—→L′</a><a id="44781" class="Symbol">)</a>
<a id="44783" href="../Properties/#43876" class="Function">det</a> <a id="44787" class="Symbol">(</a><a id="44788" href="../Lambda/#28396" class="InductiveConstructor">ξ-case</a> <a id="44795" href="../Properties/#44795" class="Bound">L—→L′</a><a id="44800" class="Symbol">)</a> <a id="44802" class="Symbol">(</a><a id="44803" href="../Lambda/#28690" class="InductiveConstructor">β-suc</a> <a id="44809" href="../Properties/#44809" class="Bound">VL</a><a id="44811" class="Symbol">)</a>       <a id="44819" class="Symbol">=</a>  <a id="44822" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="44829" class="Symbol">(</a><a id="44830" href="../Properties/#3521" class="Function">V¬—→</a> <a id="44835" class="Symbol">(</a><a id="44836" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="44842" href="../Properties/#44809" class="Bound">VL</a><a id="44844" class="Symbol">)</a> <a id="44846" href="../Properties/#44795" class="Bound">L—→L′</a><a id="44851" class="Symbol">)</a>
<a id="44853" href="../Properties/#43876" class="Function">det</a> <a id="44857" href="../Lambda/#28577" class="InductiveConstructor">β-zero</a>         <a id="44872" class="Symbol">(</a><a id="44873" href="../Lambda/#28396" class="InductiveConstructor">ξ-case</a> <a id="44880" href="../Properties/#44880" class="Bound">M—→M″</a><a id="44885" class="Symbol">)</a>   <a id="44889" class="Symbol">=</a>  <a id="44892" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="44899" class="Symbol">(</a><a id="44900" href="../Properties/#3521" class="Function">V¬—→</a> <a id="44905" href="../Lambda/#17003" class="InductiveConstructor">V-zero</a> <a id="44912" href="../Properties/#44880" class="Bound">M—→M″</a><a id="44917" class="Symbol">)</a>
<a id="44919" href="../Properties/#43876" class="Function">det</a> <a id="44923" href="../Lambda/#28577" class="InductiveConstructor">β-zero</a>         <a id="44938" href="../Lambda/#28577" class="InductiveConstructor">β-zero</a>           <a id="44955" class="Symbol">=</a>  <a id="44958" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="44963" href="../Properties/#43876" class="Function">det</a> <a id="44967" class="Symbol">(</a><a id="44968" href="../Lambda/#28690" class="InductiveConstructor">β-suc</a> <a id="44974" href="../Properties/#44974" class="Bound">VL</a><a id="44976" class="Symbol">)</a>     <a id="44982" class="Symbol">(</a><a id="44983" href="../Lambda/#28396" class="InductiveConstructor">ξ-case</a> <a id="44990" href="../Properties/#44990" class="Bound">L—→L″</a><a id="44995" class="Symbol">)</a>   <a id="44999" class="Symbol">=</a>  <a id="45002" href="https://agda.github.io/agda-stdlib/v1.3/Data.Empty.html#628" class="Function">⊥-elim</a> <a id="45009" class="Symbol">(</a><a id="45010" href="../Properties/#3521" class="Function">V¬—→</a> <a id="45015" class="Symbol">(</a><a id="45016" href="../Lambda/#17051" class="InductiveConstructor">V-suc</a> <a id="45022" href="../Properties/#44974" class="Bound">VL</a><a id="45024" class="Symbol">)</a> <a id="45026" href="../Properties/#44990" class="Bound">L—→L″</a><a id="45031" class="Symbol">)</a>
<a id="45033" href="../Properties/#43876" class="Function">det</a> <a id="45037" class="Symbol">(</a><a id="45038" href="../Lambda/#28690" class="InductiveConstructor">β-suc</a> <a id="45044" class="Symbol">_)</a>      <a id="45052" class="Symbol">(</a><a id="45053" href="../Lambda/#28690" class="InductiveConstructor">β-suc</a> <a id="45059" class="Symbol">_)</a>        <a id="45069" class="Symbol">=</a>  <a id="45072" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="45077" href="../Properties/#43876" class="Function">det</a> <a id="45081" href="../Lambda/#28841" class="InductiveConstructor">β-μ</a>            <a id="45096" href="../Lambda/#28841" class="InductiveConstructor">β-μ</a>              <a id="45113" class="Symbol">=</a>  <a id="45116" href="https://agda.github.io/agda-stdlib/v1.3/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>The proof is by induction over possible reductions. We consider three typical cases:</p>
<ul>
<li><p>Two instances of <code>ξ-·₁</code>:</p>
<pre><code>L —→ L′                 L —→ L″
--------------- ξ-·₁    --------------- ξ-·₁
L · M —→ L′ · M         L · M —→ L″ · M</code></pre>
<p>By induction we have <code>L′ ≡ L″</code>, and hence by congruence <code>L′ · M ≡ L″ · M</code>.</p></li>
<li><p>An instance of <code>ξ-·₁</code> and an instance of <code>ξ-·₂</code>:</p>
<pre><code>                        Value L
L —→ L′                 M —→ M″
--------------- ξ-·₁    --------------- ξ-·₂
L · M —→ L′ · M         L · M —→ L · M″</code></pre>
<p>The rule on the left requires <code>L</code> to reduce, but the rule on the right requires <code>L</code> to be a value. This is a contradiction since values do not reduce. If the value constraint was removed from <code>ξ-·₂</code>, or from one of the other reduction rules, then determinism would no longer hold.</p></li>
<li><p>Two instances of <code>β-ƛ</code>:</p>
<pre><code>Value V                              Value V
----------------------------- β-ƛ    ----------------------------- β-ƛ
(ƛ x ⇒ N) · V —→ N [ x := V ]        (ƛ x ⇒ N) · V —→ N [ x := V ]</code></pre>
<p>Since the left-hand sides are identical, the right-hand sides are also identical. The formal proof simply invokes <code>refl</code>.</p></li>
</ul>
<p>Five of the 18 lines in the above proof are redundant, e.g., the case when one rule is <code>ξ-·₁</code> and the other is <code>ξ-·₂</code> is considered twice, once with <code>ξ-·₁</code> first and <code>ξ-·₂</code> second, and the other time with the two swapped. What we might like to do is delete the redundant lines and add</p>
<pre><code>det M—→M′ M—→M″ = sym (det M—→M″ M—→M′)</code></pre>
<p>to the bottom of the proof. But this does not work: the termination checker complains, because the arguments have merely switched order and neither is smaller.</p>
<h4 id="quiz">Quiz</h4>
<p>Suppose we add a new term <code>zap</code> with the following reduction rule</p>
<pre><code>-------- β-zap
M —→ zap</code></pre>
<p>and the following typing rule:</p>
<pre><code>----------- ⊢zap
Γ ⊢ zap ⦂ A</code></pre>
<p>Which of the following properties remain true in the presence of these rules? For each property, write either “remains true” or “becomes false.” If a property becomes false, give a counterexample:</p>
<ul>
<li><p>Determinism of <code>step</code></p></li>
<li><p>Progress</p></li>
<li><p>Preservation</p></li>
</ul>
<h4 id="quiz-1">Quiz</h4>
<p>Suppose instead that we add a new term <code>foo</code> with the following reduction rules:</p>
<pre><code>------------------ β-foo₁
(λ x ⇒ ` x) —→ foo

----------- β-foo₂
foo —→ zero</code></pre>
<p>Which of the following properties remain true in the presence of this rule? For each one, write either “remains true” or else “becomes false.” If a property becomes false, give a counterexample:</p>
<ul>
<li><p>Determinism of <code>step</code></p></li>
<li><p>Progress</p></li>
<li><p>Preservation</p></li>
</ul>
<h4 id="quiz-2">Quiz</h4>
<p>Suppose instead that we remove the rule <code>ξ·₁</code> from the step relation. Which of the following properties remain true in the absence of this rule? For each one, write either “remains true” or else “becomes false.” If a property becomes false, give a counterexample:</p>
<ul>
<li><p>Determinism of <code>step</code></p></li>
<li><p>Progress</p></li>
<li><p>Preservation</p></li>
</ul>
<h4 id="quiz-3">Quiz</h4>
<p>We can enumerate all the computable function from naturals to naturals, by writing out all programs of type <code>`ℕ ⇒ `ℕ</code> in lexical order. Write <code>fᵢ</code> for the <code>i</code>’th function in this list.</p>
<p>Say we add a typing rule that applies the above enumeration to interpret a natural as a function from naturals to naturals:</p>
<pre><code>Γ ⊢ L ⦂ `ℕ
Γ ⊢ M ⦂ `ℕ
-------------- _·ℕ_
Γ ⊢ L · M ⦂ `ℕ</code></pre>
<p>And that we add the corresponding reduction rule:</p>
<pre><code>fᵢ(m) —→ n
---------- δ
i · m —→ n</code></pre>
<p>Which of the following properties remain true in the presence of this rule? For each one, write either “remains true” or else “becomes false.” If a property becomes false, give a counterexample:</p>
<ul>
<li><p>Determinism of <code>step</code></p></li>
<li><p>Progress</p></li>
<li><p>Preservation</p></li>
</ul>
<p>Are all properties preserved in this case? Are there any other alterations we would wish to make to the system?</p>
<h2 id="unicode">Unicode</h2>
<p>This chapter uses the following unicode:</p>
<pre><code>ƛ  U+019B  LATIN SMALL LETTER LAMBDA WITH STROKE (\Gl-)
Δ  U+0394  GREEK CAPITAL LETTER DELTA (\GD or \Delta)
β  U+03B2  GREEK SMALL LETTER BETA (\Gb or \beta)
δ  U+03B4  GREEK SMALL LETTER DELTA (\Gd or \delta)
μ  U+03BC  GREEK SMALL LETTER MU (\Gm or \mu)
ξ  U+03BE  GREEK SMALL LETTER XI (\Gx or \xi)
ρ  U+03B4  GREEK SMALL LETTER RHO (\Gr or \rho)
ᵢ  U+1D62  LATIN SUBSCRIPT SMALL LETTER I (\_i)
ᶜ  U+1D9C  MODIFIER LETTER SMALL C (\^c)
–  U+2013  EM DASH (\em)
₄  U+2084  SUBSCRIPT FOUR (\_4)
↠  U+21A0  RIGHTWARDS TWO HEADED ARROW (\rr-)
⇒  U+21D2  RIGHTWARDS DOUBLE ARROW (\=&gt;)
∅  U+2205  EMPTY SET (\0)
∋  U+220B  CONTAINS AS MEMBER (\ni)
≟  U+225F  QUESTIONED EQUAL TO (\?=)
⊢  U+22A2  RIGHT TACK (\vdash or \|-)
⦂  U+2982  Z NOTATION TYPE COLON (\:)</code></pre>
    </div>
    <nav class="pager">
    <ul class="pagination">
        
        <li><a class="pagelink" href="../Lambda/">上一章</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part2/Properties.lagda.md">源文件</a></li>
        <li class="separator">&bullet;</li>
        
        
        <li><a class="pagelink" href="../DeBruijn/">下一章</a></li>
        <li class="separator">&bullet;</li>
        
    </ul>
</nav>

</article>

            </div>
        </main>
        <footer class="site-footer h-card">
    <data class="u-url" href="../"></data>
    <div class="wrapper">
        <h2 class="footer-heading">编程语言基础：Agda 语言描述</h2>
        
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Philip Wadler</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wadler" title="wadler"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wadler</a></li>
    
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Wen Kokke</li>
                    <li>
                        
                        <a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;wenkokke</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/wenkokke" title="wenkokke"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;wenkokke</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        <div class="footer-col-wrapper">
            <div class="footer-col footer-col-1">
                <ul class="contact-list">
                    <li class="p-name">Jeremy G. Siek</li>
                    <li>
                        
                        <a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a>
                        
                    </li>
                </ul>
            </div>
            <div class="footer-col footer-col-2">
                <ul class="social-media-list">
    
    <li><a rel="me" href="https://github.com/jsiek" title="jsiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#github"></use></svg>&nbsp;jsiek</a></li>
    
    
    <li><a rel="me" href="https://twitter.com/jeremysiek" title="jeremysiek"><svg class="svg-icon grey"><use xlink:href="/public/minima-social-icons.svg#twitter"></use></svg>&nbsp;jeremysiek</a></li>
    
</ul>

            </div>
            <div class="footer-col footer-col-3">
                
            </div>
        </div>
        
        
        This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
    </div>
</footer>

    </body>
</html>
