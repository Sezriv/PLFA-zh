<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Connectives: 合取、析取与蕴涵 | 编程语言基础：Agda 语言描述
</title><!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Connectives: 合取、析取与蕴涵" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="编程语言基础：Agda 语言描述" />
<meta property="og:description" content="编程语言基础：Agda 语言描述" />
<link rel="canonical" href="https://agda-zh.github.io/PLFA-zh/Connectives/" />
<meta property="og:url" content="https://agda-zh.github.io/PLFA-zh/Connectives/" />
<meta property="og:site_name" content="编程语言基础：Agda 语言描述" />
<script type="application/ld+json">
{"description":"编程语言基础：Agda 语言描述","@type":"WebPage","url":"https://agda-zh.github.io/PLFA-zh/Connectives/","headline":"Connectives: 合取、析取与蕴涵","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/PLFA-zh/assets/main.css"></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/PLFA-zh/">编程语言基础：Agda 语言描述
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/PLFA-zh/">主页</a>
                <a class="page-link" href="/PLFA-zh/Announcements/">公告</a>
                <a class="page-link" href="/PLFA-zh/GettingStarted/">使用说明</a>
                <a class="page-link" href="/PLFA-zh/Citing/">引用</a>
                <a class="page-link" href="https://plfa.github.io/">English</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
      <h1 class="post-title">Connectives: 合取、析取与蕴涵</h1>
  </header>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Isomorphism/">上一章</a>
    
    
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Connectives.lagda.md">源代码</a>
    
    
    &bullet;
    
    
    <a alt="Next chapter" href="/PLFA-zh/Negation/">下一章</a>
    
</p>


  <div class="post-content">
    <pre class="Agda"><a id="188" class="Keyword">module</a> <a id="195" href="/PLFA-zh/Connectives/" class="Module">plfa.part1.Connectives</a> <a id="218" class="Keyword">where</a>
</pre>
<!-- The ⊥ ⊎ A ≅ A exercise requires a (inj₁ ()) pattern,
     which the reader will not have seen. Restore this
     exercise, and possibly also associativity? Take the
     exercises from the final sections on distributivity
     and exponentials? -->

<!-- This chapter introduces the basic logical connectives, by observing a
correspondence between connectives of logic and data types, a
principle known as _Propositions as Types_: -->

<p>本章节介绍基础的逻辑运算符。我们使用逻辑运算符与数据类型之间的对应关系，即<em>命题即类型</em>原理（Propositions as Types）。</p>

<!--   * _conjunction_ is _product_,
  * _disjunction_ is _sum_,
  * _true_ is _unit type_,
  * _false_ is _empty type_,
  * _implication_ is _function space_. -->

<ul>
  <li><em>合取</em>（Conjunction）即是<em>积</em>（Product）</li>
  <li><em>析取</em>（Disjunction）即是<em>和</em>（Sum）</li>
  <li><em>真</em>（True）即是<em>单元类型</em>（Unit Type）</li>
  <li><em>假</em>（False）即是<em>空类型</em>（Empty Type）</li>
  <li><em>蕴涵</em>（Implication）即是<em>函数空间</em>（Function Space）</li>
</ul>

<!-- ## Imports -->

<h2 id="导入">导入</h2>

<pre class="Agda"><a id="1146" class="Keyword">import</a> <a id="1153" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1191" class="Symbol">as</a> <a id="1194" class="Module">Eq</a>
<a id="1197" class="Keyword">open</a> <a id="1202" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="1205" class="Keyword">using</a> <a id="1211" class="Symbol">(</a><a id="1212" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="1215" class="Symbol">;</a> <a id="1217" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="1221" class="Symbol">)</a>
<a id="1223" class="Keyword">open</a> <a id="1228" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2499" class="Module">Eq.≡-Reasoning</a>
<a id="1243" class="Keyword">open</a> <a id="1248" class="Keyword">import</a> <a id="1255" href="https://agda.github.io/agda-stdlib/v1.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="1264" class="Keyword">using</a> <a id="1270" class="Symbol">(</a><a id="1271" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="1272" class="Symbol">)</a>
<a id="1274" class="Keyword">open</a> <a id="1279" class="Keyword">import</a> <a id="1286" href="https://agda.github.io/agda-stdlib/v1.1/Function.html" class="Module">Function</a> <a id="1295" class="Keyword">using</a> <a id="1301" class="Symbol">(</a><a id="1302" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">_∘_</a><a id="1305" class="Symbol">)</a>
<a id="1307" class="Keyword">open</a> <a id="1312" class="Keyword">import</a> <a id="1319" href="/PLFA-zh/Isomorphism/" class="Module">plfa.part1.Isomorphism</a> <a id="1342" class="Keyword">using</a> <a id="1348" class="Symbol">(</a><a id="1349" href="plfa.part1.Isomorphism.html#5849" class="Record Operator">_≃_</a><a id="1352" class="Symbol">;</a> <a id="1354" href="plfa.part1.Isomorphism.html#11925" class="Record Operator">_≲_</a><a id="1357" class="Symbol">;</a> <a id="1359" href="plfa.part1.Isomorphism.html#3764" class="Postulate">extensionality</a><a id="1373" class="Symbol">)</a>
<a id="1375" class="Keyword">open</a> <a id="1380" href="/PLFA-zh/Isomorphism/#10993" class="Module">plfa.part1.Isomorphism.≃-Reasoning</a>
</pre>

<!-- ## Conjunction is product -->

<h2 id="合取即是积">合取即是积</h2>

<!-- Given two propositions `A` and `B`, the conjunction `A × B` holds
if both `A` holds and `B` holds.  We formalise this idea by
declaring a suitable inductive type: -->

<p>给定两个命题 <code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code>，其合取 <code class="language-plaintext highlighter-rouge">A × B</code> 成立当 <code class="language-plaintext highlighter-rouge">A</code> 成立和 <code class="language-plaintext highlighter-rouge">B</code> 成立。我们将这样的概念形式化，使用如下的归纳类型：</p>

<pre class="Agda"><a id="1733" class="Keyword">data</a> <a id="_×_"></a><a id="1738" href="/PLFA-zh/Connectives/#1738" class="Datatype Operator">_×_</a> <a id="1742" class="Symbol">(</a><a id="1743" href="plfa.part1.Connectives.html#1743" class="Bound">A</a> <a id="1745" href="plfa.part1.Connectives.html#1745" class="Bound">B</a> <a id="1747" class="Symbol">:</a> <a id="1749" class="PrimitiveType">Set</a><a id="1752" class="Symbol">)</a> <a id="1754" class="Symbol">:</a> <a id="1756" class="PrimitiveType">Set</a> <a id="1760" class="Keyword">where</a>

  <a id="_×_.⟨_,_⟩"></a><a id="1769" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨_,_⟩</a> <a id="1775" class="Symbol">:</a>
      <a id="1783" href="/PLFA-zh/Connectives/#1743" class="Bound">A</a>
    <a id="1789" class="Symbol">→</a> <a id="1791" href="/PLFA-zh/Connectives/#1745" class="Bound">B</a>
      <a id="1799" class="Comment">-----</a>
    <a id="1809" class="Symbol">→</a> <a id="1811" href="/PLFA-zh/Connectives/#1743" class="Bound">A</a> <a id="1813" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="1815" href="plfa.part1.Connectives.html#1745" class="Bound">B</a>
</pre>
<!-- Evidence that `A × B` holds is of the form `⟨ M , N ⟩`, where `M`
provides evidence that `A` holds and `N` provides evidence that `B`
holds. -->

<p><code class="language-plaintext highlighter-rouge">A × B</code> 成立的证明由 <code class="language-plaintext highlighter-rouge">⟨ M , N ⟩</code> 的形式表现，其中 <code class="language-plaintext highlighter-rouge">M</code> 是 <code class="language-plaintext highlighter-rouge">A</code> 成立的证明，
<code class="language-plaintext highlighter-rouge">N</code> 是 <code class="language-plaintext highlighter-rouge">B</code> 成立的证明。</p>

<!-- Given evidence that `A × B` holds, we can conclude that either
`A` holds or `B` holds: -->

<p>给定 <code class="language-plaintext highlighter-rouge">A × B</code> 成立的证明，我们可以得出 <code class="language-plaintext highlighter-rouge">A</code> 成立或者 <code class="language-plaintext highlighter-rouge">B</code> 成立。</p>

<pre class="Agda"><a id="proj₁"></a><a id="2203" href="/PLFA-zh/Connectives/#2203" class="Function">proj₁</a> <a id="2209" class="Symbol">:</a> <a id="2211" class="Symbol">∀</a> <a id="2213" class="Symbol">{</a><a id="2214" href="plfa.part1.Connectives.html#2214" class="Bound">A</a> <a id="2216" href="plfa.part1.Connectives.html#2216" class="Bound">B</a> <a id="2218" class="Symbol">:</a> <a id="2220" class="PrimitiveType">Set</a><a id="2223" class="Symbol">}</a>
  <a id="2227" class="Symbol">→</a> <a id="2229" href="/PLFA-zh/Connectives/#2214" class="Bound">A</a> <a id="2231" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="2233" href="plfa.part1.Connectives.html#2216" class="Bound">B</a>
    <a id="2239" class="Comment">-----</a>
  <a id="2247" class="Symbol">→</a> <a id="2249" href="/PLFA-zh/Connectives/#2214" class="Bound">A</a>
<a id="2251" href="/PLFA-zh/Connectives/#2203" class="Function">proj₁</a> <a id="2257" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="2259" href="plfa.part1.Connectives.html#2259" class="Bound">x</a> <a id="2261" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="2263" href="plfa.part1.Connectives.html#2263" class="Bound">y</a> <a id="2265" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="2267" class="Symbol">=</a> <a id="2269" href="plfa.part1.Connectives.html#2259" class="Bound">x</a>

<a id="proj₂"></a><a id="2272" href="/PLFA-zh/Connectives/#2272" class="Function">proj₂</a> <a id="2278" class="Symbol">:</a> <a id="2280" class="Symbol">∀</a> <a id="2282" class="Symbol">{</a><a id="2283" href="plfa.part1.Connectives.html#2283" class="Bound">A</a> <a id="2285" href="plfa.part1.Connectives.html#2285" class="Bound">B</a> <a id="2287" class="Symbol">:</a> <a id="2289" class="PrimitiveType">Set</a><a id="2292" class="Symbol">}</a>
  <a id="2296" class="Symbol">→</a> <a id="2298" href="/PLFA-zh/Connectives/#2283" class="Bound">A</a> <a id="2300" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="2302" href="plfa.part1.Connectives.html#2285" class="Bound">B</a>
    <a id="2308" class="Comment">-----</a>
  <a id="2316" class="Symbol">→</a> <a id="2318" href="/PLFA-zh/Connectives/#2285" class="Bound">B</a>
<a id="2320" href="/PLFA-zh/Connectives/#2272" class="Function">proj₂</a> <a id="2326" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="2328" href="plfa.part1.Connectives.html#2328" class="Bound">x</a> <a id="2330" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="2332" href="plfa.part1.Connectives.html#2332" class="Bound">y</a> <a id="2334" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="2336" class="Symbol">=</a> <a id="2338" href="plfa.part1.Connectives.html#2332" class="Bound">y</a>
</pre>
<!-- If `L` provides evidence that `A × B` holds, then `proj₁ L` provides evidence
that `A` holds, and `proj₂ L` provides evidence that `B` holds. -->

<p>如果 <code class="language-plaintext highlighter-rouge">L</code> 是 <code class="language-plaintext highlighter-rouge">A × B</code> 成立的证据, 那么 <code class="language-plaintext highlighter-rouge">proj₁ L</code> 是 <code class="language-plaintext highlighter-rouge">A</code> 成立的证据，
<code class="language-plaintext highlighter-rouge">proj₂ L</code> 是 <code class="language-plaintext highlighter-rouge">B</code> 成立的证据。</p>

<!-- Equivalently, we could also declare conjunction as a record type: -->

<p>等价地，我们亦可以将合取定义为一个记录类型：</p>

<pre class="Agda"><a id="2691" class="Keyword">record</a> <a id="_×′_"></a><a id="2698" href="/PLFA-zh/Connectives/#2698" class="Record Operator">_×′_</a> <a id="2703" class="Symbol">(</a><a id="2704" href="plfa.part1.Connectives.html#2704" class="Bound">A</a> <a id="2706" href="plfa.part1.Connectives.html#2706" class="Bound">B</a> <a id="2708" class="Symbol">:</a> <a id="2710" class="PrimitiveType">Set</a><a id="2713" class="Symbol">)</a> <a id="2715" class="Symbol">:</a> <a id="2717" class="PrimitiveType">Set</a> <a id="2721" class="Keyword">where</a>
  <a id="2729" class="Keyword">field</a>
    <a id="_×′_.proj₁′"></a><a id="2739" href="/PLFA-zh/Connectives/#2739" class="Field">proj₁′</a> <a id="2746" class="Symbol">:</a> <a id="2748" href="plfa.part1.Connectives.html#2704" class="Bound">A</a>
    <a id="_×′_.proj₂′"></a><a id="2754" href="/PLFA-zh/Connectives/#2754" class="Field">proj₂′</a> <a id="2761" class="Symbol">:</a> <a id="2763" href="plfa.part1.Connectives.html#2706" class="Bound">B</a>
<a id="2765" class="Keyword">open</a> <a id="2770" href="/PLFA-zh/Connectives/#2698" class="Module Operator">_×′_</a>
</pre>
<!-- Here record construction -->

<p>在这里，记录的构造</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>record
  { proj₁′ = M
  ; proj₂′ = N
  }
</code></pre></div></div>

<!-- corresponds to the term -->

<p>对应</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⟨ M , N ⟩
</code></pre></div></div>

<!-- where `M` is a term of type `A` and `N` is a term of type `B`. -->

<p>其中 <code class="language-plaintext highlighter-rouge">M</code> 是 <code class="language-plaintext highlighter-rouge">A</code> 类型的项，<code class="language-plaintext highlighter-rouge">N</code> 是 <code class="language-plaintext highlighter-rouge">B</code> 类型的项。</p>

<!-- When `⟨_,_⟩` appears in a term on the right-hand side of an equation
we refer to it as a _constructor_, and when it appears in a pattern on
the left-hand side of an equation we refer to it as a _destructor_.
We may also refer to `proj₁` and `proj₂` as destructors, since they
play a similar role. -->

<p>当 <code class="language-plaintext highlighter-rouge">⟨_,_⟩</code> 在等式右手边的项中出现的时候，我们将其称作<em>构造子</em>（Constructor），当它出现在等式左边时，我们将其称作<em>析构器</em>（Destructor）。我们亦可将 <code class="language-plaintext highlighter-rouge">proj₁</code> 和 <code class="language-plaintext highlighter-rouge">proj₂</code>
称作析构器，因为它们起到相似的效果。</p>

<!-- Other terminology refers to `⟨_,_⟩` as _introducing_ a conjunction, and
to `proj₁` and `proj₂` as _eliminating_ a conjunction; indeed, the
former is sometimes given the name `×-I` and the latter two the names
`×-E₁` and `×-E₂`.  As we read the rules from top to bottom,
introduction and elimination do what they say on the tin: the first
_introduces_ a formula for the connective, which appears in the
conclusion but not in the hypotheses; the second _eliminates_ a
formula for the connective, which appears in a hypothesis but not in
the conclusion. An introduction rule describes under what conditions
we say the connective holds---how to _define_ the connective. An
elimination rule describes what we may conclude when the connective
holds---how to _use_ the connective. -->

<p>其他的术语将 <code class="language-plaintext highlighter-rouge">⟨_,_⟩</code> 称作<em>引入</em>（Introduce）合取，将 <code class="language-plaintext highlighter-rouge">proj₁</code> 和 <code class="language-plaintext highlighter-rouge">proj₂</code> 称作<em>消去</em>（Eliminate）合取。前者亦记作 <code class="language-plaintext highlighter-rouge">×-I</code>，后者 <code class="language-plaintext highlighter-rouge">×-E₁</code> 和 <code class="language-plaintext highlighter-rouge">×-E₂</code>。如果我们从上到下来阅读这些规则，引入和消去正如其名字所说的那样：第一条<em>引入</em>一个运算符，所以运算符出现在结论中，而不是假设中；第二条<em>消去</em>一个带有运算符的式子，而运算符出现在假设中，而不是结论中。引入规则描述了运算符在什么情况下成立——即怎么样<em>定义</em>一个运算符。消去规则描述了运算符成立时，可以得出什么样的结论——即怎么样<em>使用</em>一个运算符。</p>

<!-- (The paragraph above was adopted from "Propositions as Types", Philip Wadler,
_Communications of the ACM_, December 2015.) -->

<p>（上面一段内容由此处改编得来：<em>Propositions as Types</em>，作者：Philip Wadler，发表于 《ACM 通讯》，2015 年 9 月）</p>

<!-- In this case, applying each destructor and reassembling the results with the
constructor is the identity over products: -->

<p>在这样的情况下，先使用析构器，再使用构造子将结果重组，得到还是原来的积。</p>

<pre class="Agda"><a id="η-×"></a><a id="4997" href="/PLFA-zh/Connectives/#4997" class="Function">η-×</a> <a id="5001" class="Symbol">:</a> <a id="5003" class="Symbol">∀</a> <a id="5005" class="Symbol">{</a><a id="5006" href="plfa.part1.Connectives.html#5006" class="Bound">A</a> <a id="5008" href="plfa.part1.Connectives.html#5008" class="Bound">B</a> <a id="5010" class="Symbol">:</a> <a id="5012" class="PrimitiveType">Set</a><a id="5015" class="Symbol">}</a> <a id="5017" class="Symbol">(</a><a id="5018" href="plfa.part1.Connectives.html#5018" class="Bound">w</a> <a id="5020" class="Symbol">:</a> <a id="5022" href="plfa.part1.Connectives.html#5006" class="Bound">A</a> <a id="5024" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="5026" href="plfa.part1.Connectives.html#5008" class="Bound">B</a><a id="5027" class="Symbol">)</a> <a id="5029" class="Symbol">→</a> <a id="5031" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="5033" href="plfa.part1.Connectives.html#2203" class="Function">proj₁</a> <a id="5039" href="plfa.part1.Connectives.html#5018" class="Bound">w</a> <a id="5041" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="5043" href="plfa.part1.Connectives.html#2272" class="Function">proj₂</a> <a id="5049" href="plfa.part1.Connectives.html#5018" class="Bound">w</a> <a id="5051" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="5053" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="5055" href="plfa.part1.Connectives.html#5018" class="Bound">w</a>
<a id="5057" href="/PLFA-zh/Connectives/#4997" class="Function">η-×</a> <a id="5061" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="5063" href="plfa.part1.Connectives.html#5063" class="Bound">x</a> <a id="5065" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="5067" href="plfa.part1.Connectives.html#5067" class="Bound">y</a> <a id="5069" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="5071" class="Symbol">=</a> <a id="5073" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<!-- The pattern matching on the left-hand side is essential, since
replacing `w` by `⟨ x , y ⟩` allows both sides of the
propositional equality to simplify to the same term. -->

<p>左手边的模式匹配是必要的。用 <code class="language-plaintext highlighter-rouge">⟨ x , y ⟩</code> 来替换 <code class="language-plaintext highlighter-rouge">w</code> 让等式的两边可以化简成相同的项。</p>

<!-- We set the precedence of conjunction so that it binds less
tightly than anything save disjunction: -->

<p>我们设置合取的优先级，使它与除了析取之外结合的都不紧密：</p>

<pre class="Agda"><a id="5475" class="Keyword">infixr</a> <a id="5482" class="Number">2</a> <a id="5484" href="/PLFA-zh/Connectives/#1738" class="Datatype Operator">_×_</a>
</pre>
<!-- Thus, `m ≤ n × n ≤ p` parses as `(m ≤ n) × (n ≤ p)`. -->

<p>因此，<code class="language-plaintext highlighter-rouge">m ≤ n × n ≤ p</code> 解析为 <code class="language-plaintext highlighter-rouge">(m ≤ n) × (n ≤ p)</code>。</p>

<!-- Given two types `A` and `B`, we refer to `A × B` as the
_product_ of `A` and `B`.  In set theory, it is also sometimes
called the _Cartesian product_, and in computing it corresponds
to a _record_ type. Among other reasons for
calling it the product, note that if type `A` has `m`
distinct members, and type `B` has `n` distinct members,
then the type `A × B` has `m * n` distinct members.
For instance, consider a type `Bool` with two members, and
a type `Tri` with three members: -->

<p>给定两个类型 <code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code>，我们将 <code class="language-plaintext highlighter-rouge">A × B</code> 称为 <code class="language-plaintext highlighter-rouge">A</code> 与 <code class="language-plaintext highlighter-rouge">B</code> 的<em>积</em>。在集合论中它也被称作<em>笛卡尔积</em>（Cartesian Product），在计算机科学中它对应<em>记录</em>类型。如果类型 <code class="language-plaintext highlighter-rouge">A</code> 有 <code class="language-plaintext highlighter-rouge">m</code> 个不同的成员，类型 <code class="language-plaintext highlighter-rouge">B</code> 有 <code class="language-plaintext highlighter-rouge">n</code> 个不同的成员，那么类型 <code class="language-plaintext highlighter-rouge">A × B</code> 有 <code class="language-plaintext highlighter-rouge">m * n</code> 个不同的成员。这也是它被称为积的原因之一。例如，考虑有两个成员的 <code class="language-plaintext highlighter-rouge">Bool</code> 类型，和有三个成员的 <code class="language-plaintext highlighter-rouge">Tri</code> 类型：</p>

<pre class="Agda"><a id="6344" class="Keyword">data</a> <a id="Bool"></a><a id="6349" href="/PLFA-zh/Connectives/#6349" class="Datatype">Bool</a> <a id="6354" class="Symbol">:</a> <a id="6356" class="PrimitiveType">Set</a> <a id="6360" class="Keyword">where</a>
  <a id="Bool.true"></a><a id="6368" href="/PLFA-zh/Connectives/#6368" class="InductiveConstructor">true</a>  <a id="6374" class="Symbol">:</a> <a id="6376" href="plfa.part1.Connectives.html#6349" class="Datatype">Bool</a>
  <a id="Bool.false"></a><a id="6383" href="/PLFA-zh/Connectives/#6383" class="InductiveConstructor">false</a> <a id="6389" class="Symbol">:</a> <a id="6391" href="plfa.part1.Connectives.html#6349" class="Datatype">Bool</a>

<a id="6397" class="Keyword">data</a> <a id="Tri"></a><a id="6402" href="/PLFA-zh/Connectives/#6402" class="Datatype">Tri</a> <a id="6406" class="Symbol">:</a> <a id="6408" class="PrimitiveType">Set</a> <a id="6412" class="Keyword">where</a>
  <a id="Tri.aa"></a><a id="6420" href="/PLFA-zh/Connectives/#6420" class="InductiveConstructor">aa</a> <a id="6423" class="Symbol">:</a> <a id="6425" href="plfa.part1.Connectives.html#6402" class="Datatype">Tri</a>
  <a id="Tri.bb"></a><a id="6431" href="/PLFA-zh/Connectives/#6431" class="InductiveConstructor">bb</a> <a id="6434" class="Symbol">:</a> <a id="6436" href="plfa.part1.Connectives.html#6402" class="Datatype">Tri</a>
  <a id="Tri.cc"></a><a id="6442" href="/PLFA-zh/Connectives/#6442" class="InductiveConstructor">cc</a> <a id="6445" class="Symbol">:</a> <a id="6447" href="plfa.part1.Connectives.html#6402" class="Datatype">Tri</a>
</pre>
<!-- Then the type `Bool × Tri` has six members: -->

<p>那么，<code class="language-plaintext highlighter-rouge">Bool × Tri</code> 类型有如下的六个成员：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⟨ true  , aa ⟩    ⟨ true  , bb ⟩    ⟨ true ,  cc ⟩
⟨ false , aa ⟩    ⟨ false , bb ⟩    ⟨ false , cc ⟩
</code></pre></div></div>

<!-- For example, the following function enumerates all
possible arguments of type `Bool × Tri`: -->

<p>下面的函数枚举了所有类型为 <code class="language-plaintext highlighter-rouge">Bool × Tri</code> 的参数：</p>

<pre class="Agda"><a id="×-count"></a><a id="6805" href="/PLFA-zh/Connectives/#6805" class="Function">×-count</a> <a id="6813" class="Symbol">:</a> <a id="6815" href="plfa.part1.Connectives.html#6349" class="Datatype">Bool</a> <a id="6820" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="6822" href="plfa.part1.Connectives.html#6402" class="Datatype">Tri</a> <a id="6826" class="Symbol">→</a> <a id="6828" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="6830" href="/PLFA-zh/Connectives/#6805" class="Function">×-count</a> <a id="6838" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="6840" href="plfa.part1.Connectives.html#6368" class="InductiveConstructor">true</a>  <a id="6846" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="6848" href="plfa.part1.Connectives.html#6420" class="InductiveConstructor">aa</a> <a id="6851" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a>  <a id="6854" class="Symbol">=</a>  <a id="6857" class="Number">1</a>
<a id="6859" href="/PLFA-zh/Connectives/#6805" class="Function">×-count</a> <a id="6867" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="6869" href="plfa.part1.Connectives.html#6368" class="InductiveConstructor">true</a>  <a id="6875" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="6877" href="plfa.part1.Connectives.html#6431" class="InductiveConstructor">bb</a> <a id="6880" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a>  <a id="6883" class="Symbol">=</a>  <a id="6886" class="Number">2</a>
<a id="6888" href="/PLFA-zh/Connectives/#6805" class="Function">×-count</a> <a id="6896" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="6898" href="plfa.part1.Connectives.html#6368" class="InductiveConstructor">true</a>  <a id="6904" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="6906" href="plfa.part1.Connectives.html#6442" class="InductiveConstructor">cc</a> <a id="6909" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a>  <a id="6912" class="Symbol">=</a>  <a id="6915" class="Number">3</a>
<a id="6917" href="/PLFA-zh/Connectives/#6805" class="Function">×-count</a> <a id="6925" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="6927" href="plfa.part1.Connectives.html#6383" class="InductiveConstructor">false</a> <a id="6933" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="6935" href="plfa.part1.Connectives.html#6420" class="InductiveConstructor">aa</a> <a id="6938" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a>  <a id="6941" class="Symbol">=</a>  <a id="6944" class="Number">4</a>
<a id="6946" href="/PLFA-zh/Connectives/#6805" class="Function">×-count</a> <a id="6954" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="6956" href="plfa.part1.Connectives.html#6383" class="InductiveConstructor">false</a> <a id="6962" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="6964" href="plfa.part1.Connectives.html#6431" class="InductiveConstructor">bb</a> <a id="6967" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a>  <a id="6970" class="Symbol">=</a>  <a id="6973" class="Number">5</a>
<a id="6975" href="/PLFA-zh/Connectives/#6805" class="Function">×-count</a> <a id="6983" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="6985" href="plfa.part1.Connectives.html#6383" class="InductiveConstructor">false</a> <a id="6991" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="6993" href="plfa.part1.Connectives.html#6442" class="InductiveConstructor">cc</a> <a id="6996" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a>  <a id="6999" class="Symbol">=</a>  <a id="7002" class="Number">6</a>
</pre>
<!-- Product on types also shares a property with product on numbers in
that there is a sense in which it is commutative and associative.  In
particular, product is commutative and associative _up to
isomorphism_. -->

<p>类型上的积与数的积有相似的性质——它们满足交换律和结合律。更确切地说，积在<em>在同构意义下</em>满足交换律和结合率。</p>

<!-- For commutativity, the `to` function swaps a pair, taking `⟨ x , y ⟩` to
`⟨ y , x ⟩`, and the `from` function does the same (up to renaming).
Instantiating the patterns correctly in `from∘to` and `to∘from` is essential.
Replacing the definition of `from∘to` by `λ w → refl` will not work;
and similarly for `to∘from`: -->

<p>对于交换律，<code class="language-plaintext highlighter-rouge">to</code> 函数将有序对交换，将 <code class="language-plaintext highlighter-rouge">⟨ x , y ⟩</code> 变为 <code class="language-plaintext highlighter-rouge">⟨ y , x ⟩</code>，<code class="language-plaintext highlighter-rouge">from</code>
函数亦是如此（忽略命名）。在 <code class="language-plaintext highlighter-rouge">from∘to</code> 和 <code class="language-plaintext highlighter-rouge">to∘from</code> 中正确地实例化要匹配的模式是很重要的。使用 <code class="language-plaintext highlighter-rouge">λ w → refl</code> 作为 <code class="language-plaintext highlighter-rouge">from∘to</code> 的定义是不可行的，<code class="language-plaintext highlighter-rouge">to∘from</code> 同理。</p>

<pre class="Agda"><a id="×-comm"></a><a id="7801" href="/PLFA-zh/Connectives/#7801" class="Function">×-comm</a> <a id="7808" class="Symbol">:</a> <a id="7810" class="Symbol">∀</a> <a id="7812" class="Symbol">{</a><a id="7813" href="plfa.part1.Connectives.html#7813" class="Bound">A</a> <a id="7815" href="plfa.part1.Connectives.html#7815" class="Bound">B</a> <a id="7817" class="Symbol">:</a> <a id="7819" class="PrimitiveType">Set</a><a id="7822" class="Symbol">}</a> <a id="7824" class="Symbol">→</a> <a id="7826" href="plfa.part1.Connectives.html#7813" class="Bound">A</a> <a id="7828" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="7830" href="plfa.part1.Connectives.html#7815" class="Bound">B</a> <a id="7832" href="/PLFA-zh/Isomorphism/#5849" class="Record Operator">≃</a> <a id="7834" href="plfa.part1.Connectives.html#7815" class="Bound">B</a> <a id="7836" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="7838" href="plfa.part1.Connectives.html#7813" class="Bound">A</a>
<a id="7840" href="/PLFA-zh/Connectives/#7801" class="Function">×-comm</a> <a id="7847" class="Symbol">=</a>
  <a id="7851" class="Keyword">record</a>
    <a id="7862" class="Symbol">{</a> <a id="7864" href="/PLFA-zh/Isomorphism/#5889" class="Field">to</a>       <a id="7873" class="Symbol">=</a>  <a id="7876" class="Symbol">λ{</a> <a id="7879" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="7881" href="plfa.part1.Connectives.html#7881" class="Bound">x</a> <a id="7883" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="7885" href="plfa.part1.Connectives.html#7885" class="Bound">y</a> <a id="7887" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="7889" class="Symbol">→</a> <a id="7891" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="7893" href="plfa.part1.Connectives.html#7885" class="Bound">y</a> <a id="7895" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="7897" href="plfa.part1.Connectives.html#7881" class="Bound">x</a> <a id="7899" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="7901" class="Symbol">}</a>
    <a id="7907" class="Symbol">;</a> <a id="7909" href="/PLFA-zh/Isomorphism/#5906" class="Field">from</a>     <a id="7918" class="Symbol">=</a>  <a id="7921" class="Symbol">λ{</a> <a id="7924" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="7926" href="plfa.part1.Connectives.html#7926" class="Bound">y</a> <a id="7928" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="7930" href="plfa.part1.Connectives.html#7930" class="Bound">x</a> <a id="7932" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="7934" class="Symbol">→</a> <a id="7936" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="7938" href="plfa.part1.Connectives.html#7930" class="Bound">x</a> <a id="7940" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="7942" href="plfa.part1.Connectives.html#7926" class="Bound">y</a> <a id="7944" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="7946" class="Symbol">}</a>
    <a id="7952" class="Symbol">;</a> <a id="7954" href="/PLFA-zh/Isomorphism/#5923" class="Field">from∘to</a>  <a id="7963" class="Symbol">=</a>  <a id="7966" class="Symbol">λ{</a> <a id="7969" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="7971" href="plfa.part1.Connectives.html#7971" class="Bound">x</a> <a id="7973" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="7975" href="plfa.part1.Connectives.html#7975" class="Bound">y</a> <a id="7977" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="7979" class="Symbol">→</a> <a id="7981" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="7986" class="Symbol">}</a>
    <a id="7992" class="Symbol">;</a> <a id="7994" href="/PLFA-zh/Isomorphism/#5965" class="Field">to∘from</a>  <a id="8003" class="Symbol">=</a>  <a id="8006" class="Symbol">λ{</a> <a id="8009" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="8011" href="plfa.part1.Connectives.html#8011" class="Bound">y</a> <a id="8013" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="8015" href="plfa.part1.Connectives.html#8015" class="Bound">x</a> <a id="8017" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="8019" class="Symbol">→</a> <a id="8021" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="8026" class="Symbol">}</a>
    <a id="8032" class="Symbol">}</a>
</pre>
<!-- Being _commutative_ is different from being _commutative up to
isomorphism_.  Compare the two statements: -->

<p>满足<em>交换律</em>和<em>在同构意义下满足交换律</em>是不一样的。比较下列两个命题：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m * n ≡ n * m
A × B ≃ B × A
</code></pre></div></div>

<!-- In the first case, we might have that `m` is `2` and `n` is `3`, and
both `m * n` and `n * m` are equal to `6`.  In the second case, we
might have that `A` is `Bool` and `B` is `Tri`, and `Bool × Tri` is
_not_ the same as `Tri × Bool`.  But there is an isomorphism between
the two types.  For instance, `⟨ true , aa ⟩`, which is a member of the
former, corresponds to `⟨ aa , true ⟩`, which is a member of the latter. -->

<p>在第一个情况下，我们可能有 <code class="language-plaintext highlighter-rouge">m</code> 是 <code class="language-plaintext highlighter-rouge">2</code>、<code class="language-plaintext highlighter-rouge">n</code> 是 <code class="language-plaintext highlighter-rouge">3</code>，那么 <code class="language-plaintext highlighter-rouge">m * n</code> 和 <code class="language-plaintext highlighter-rouge">n * m</code> 都是 <code class="language-plaintext highlighter-rouge">6</code>。在第二个情况下，我们可能有 <code class="language-plaintext highlighter-rouge">A</code> 是 <code class="language-plaintext highlighter-rouge">Bool</code> 和 <code class="language-plaintext highlighter-rouge">B</code> 是 <code class="language-plaintext highlighter-rouge">Tri</code>，但是 <code class="language-plaintext highlighter-rouge">Bool × Tri</code> 和
<code class="language-plaintext highlighter-rouge">Tri × Bool</code> <em>不是</em>一样的。但是存在一个两者之间的同构。例如：<code class="language-plaintext highlighter-rouge">⟨ true , aa ⟩</code> 是前者的成员，其对应后者的成员 <code class="language-plaintext highlighter-rouge">⟨ aa , true ⟩</code>。</p>

<!-- For associativity, the `to` function reassociates two uses of pairing,
taking `⟨ ⟨ x , y ⟩ , z ⟩` to `⟨ x , ⟨ y , z ⟩ ⟩`, and the `from` function does
the inverse.  Again, the evidence of left and right inverse requires
matching against a suitable pattern to enable simplification: -->

<p>对于结合律来说，<code class="language-plaintext highlighter-rouge">to</code> 函数将两个有序对进行重组：将 <code class="language-plaintext highlighter-rouge">⟨ ⟨ x , y ⟩ , z ⟩</code> 转换为 <code class="language-plaintext highlighter-rouge">⟨ x , ⟨ y , z ⟩ ⟩</code>，
<code class="language-plaintext highlighter-rouge">from</code> 函数则为其逆。同样，左逆和右逆的证明需要在一个合适的模式来匹配，从而可以直接化简：</p>

<pre class="Agda"><a id="×-assoc"></a><a id="9312" href="/PLFA-zh/Connectives/#9312" class="Function">×-assoc</a> <a id="9320" class="Symbol">:</a> <a id="9322" class="Symbol">∀</a> <a id="9324" class="Symbol">{</a><a id="9325" href="plfa.part1.Connectives.html#9325" class="Bound">A</a> <a id="9327" href="plfa.part1.Connectives.html#9327" class="Bound">B</a> <a id="9329" href="plfa.part1.Connectives.html#9329" class="Bound">C</a> <a id="9331" class="Symbol">:</a> <a id="9333" class="PrimitiveType">Set</a><a id="9336" class="Symbol">}</a> <a id="9338" class="Symbol">→</a> <a id="9340" class="Symbol">(</a><a id="9341" href="plfa.part1.Connectives.html#9325" class="Bound">A</a> <a id="9343" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="9345" href="plfa.part1.Connectives.html#9327" class="Bound">B</a><a id="9346" class="Symbol">)</a> <a id="9348" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="9350" href="plfa.part1.Connectives.html#9329" class="Bound">C</a> <a id="9352" href="/PLFA-zh/Isomorphism/#5849" class="Record Operator">≃</a> <a id="9354" href="plfa.part1.Connectives.html#9325" class="Bound">A</a> <a id="9356" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="9358" class="Symbol">(</a><a id="9359" href="plfa.part1.Connectives.html#9327" class="Bound">B</a> <a id="9361" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="9363" href="plfa.part1.Connectives.html#9329" class="Bound">C</a><a id="9364" class="Symbol">)</a>
<a id="9366" href="/PLFA-zh/Connectives/#9312" class="Function">×-assoc</a> <a id="9374" class="Symbol">=</a>
  <a id="9378" class="Keyword">record</a>
    <a id="9389" class="Symbol">{</a> <a id="9391" href="/PLFA-zh/Isomorphism/#5889" class="Field">to</a>      <a id="9399" class="Symbol">=</a> <a id="9401" class="Symbol">λ{</a> <a id="9404" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="9406" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="9408" href="plfa.part1.Connectives.html#9408" class="Bound">x</a> <a id="9410" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="9412" href="plfa.part1.Connectives.html#9412" class="Bound">y</a> <a id="9414" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="9416" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="9418" href="plfa.part1.Connectives.html#9418" class="Bound">z</a> <a id="9420" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="9422" class="Symbol">→</a> <a id="9424" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="9426" href="plfa.part1.Connectives.html#9408" class="Bound">x</a> <a id="9428" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="9430" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="9432" href="plfa.part1.Connectives.html#9412" class="Bound">y</a> <a id="9434" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="9436" href="plfa.part1.Connectives.html#9418" class="Bound">z</a> <a id="9438" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="9440" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="9442" class="Symbol">}</a>
    <a id="9448" class="Symbol">;</a> <a id="9450" href="/PLFA-zh/Isomorphism/#5906" class="Field">from</a>    <a id="9458" class="Symbol">=</a> <a id="9460" class="Symbol">λ{</a> <a id="9463" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="9465" href="plfa.part1.Connectives.html#9465" class="Bound">x</a> <a id="9467" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="9469" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="9471" href="plfa.part1.Connectives.html#9471" class="Bound">y</a> <a id="9473" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="9475" href="plfa.part1.Connectives.html#9475" class="Bound">z</a> <a id="9477" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="9479" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="9481" class="Symbol">→</a> <a id="9483" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="9485" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="9487" href="plfa.part1.Connectives.html#9465" class="Bound">x</a> <a id="9489" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="9491" href="plfa.part1.Connectives.html#9471" class="Bound">y</a> <a id="9493" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="9495" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="9497" href="plfa.part1.Connectives.html#9475" class="Bound">z</a> <a id="9499" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="9501" class="Symbol">}</a>
    <a id="9507" class="Symbol">;</a> <a id="9509" href="/PLFA-zh/Isomorphism/#5923" class="Field">from∘to</a> <a id="9517" class="Symbol">=</a> <a id="9519" class="Symbol">λ{</a> <a id="9522" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="9524" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="9526" href="plfa.part1.Connectives.html#9526" class="Bound">x</a> <a id="9528" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="9530" href="plfa.part1.Connectives.html#9530" class="Bound">y</a> <a id="9532" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="9534" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="9536" href="plfa.part1.Connectives.html#9536" class="Bound">z</a> <a id="9538" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="9540" class="Symbol">→</a> <a id="9542" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="9547" class="Symbol">}</a>
    <a id="9553" class="Symbol">;</a> <a id="9555" href="/PLFA-zh/Isomorphism/#5965" class="Field">to∘from</a> <a id="9563" class="Symbol">=</a> <a id="9565" class="Symbol">λ{</a> <a id="9568" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="9570" href="plfa.part1.Connectives.html#9570" class="Bound">x</a> <a id="9572" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="9574" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="9576" href="plfa.part1.Connectives.html#9576" class="Bound">y</a> <a id="9578" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="9580" href="plfa.part1.Connectives.html#9580" class="Bound">z</a> <a id="9582" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="9584" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="9586" class="Symbol">→</a> <a id="9588" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="9593" class="Symbol">}</a>
    <a id="9599" class="Symbol">}</a>
</pre>
<!-- Being _associative_ is not the same as being _associative
up to isomorphism_.  Compare the two statements: -->

<p>满足<em>结合律</em>和<em>在同构意义下满足结合律</em>是不一样的。比较下列两个命题：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(m * n) * p ≡ m * (n * p)
(A × B) × C ≃ A × (B × C)
</code></pre></div></div>

<!-- For example, the type `(ℕ × Bool) × Tri` is _not_ the same as `ℕ ×
(Bool × Tri)`. But there is an isomorphism between the two types. For
instance `⟨ ⟨ 1 , true ⟩ , aa ⟩`, which is a member of the former,
corresponds to `⟨ 1 , ⟨ true , aa ⟩ ⟩`, which is a member of the latter. -->

<p>举个例子，<code class="language-plaintext highlighter-rouge">(ℕ × Bool) × Tri</code> 与 <code class="language-plaintext highlighter-rouge">ℕ × (Bool × Tri)</code> <em>不同</em>，但是两个类型之间存在同构。例如 <code class="language-plaintext highlighter-rouge">⟨ ⟨ 1 , true ⟩ , aa ⟩</code>，一个前者的成员，与 <code class="language-plaintext highlighter-rouge">⟨ 1 , ⟨ true , aa ⟩ ⟩</code>，一个后者的成员，相对应。</p>

<!-- #### Exercise `⇔≃×` (recommended) -->

<h4 id="练习--推荐">练习 <code class="language-plaintext highlighter-rouge">⇔≃×</code> （推荐）</h4>

<!-- Show that `A ⇔ B` as defined [earlier](/PLFA-zh/Isomorphism/#iff)
is isomorphic to `(A → B) × (B → A)`. -->

<p>证明<a href="/PLFA-zh/Isomorphism/#iff">之前</a>定义的 <code class="language-plaintext highlighter-rouge">A ⇔ B</code> 与 <code class="language-plaintext highlighter-rouge">(A → B) × (B → A)</code> 同构。</p>

<!-- <pre class="Agda"><a id="10567" class="Comment">-- Your code goes here</a>
</pre>{:/}

<pre class="Agda"><a id="10604" class="Comment">-- 请将代码写在此处。</a>
</pre>
{::comment}
## Truth is unit -->

<h2 id="真即是单元类型">真即是单元类型</h2>

<!-- Truth `⊤` always holds. We formalise this idea by
declaring a suitable inductive type: -->

<p>恒真 <code class="language-plaintext highlighter-rouge">⊤</code> 恒成立。我们将这个概念用合适的归纳类型来形式化：</p>

<pre class="Agda"><a id="10811" class="Keyword">data</a> <a id="⊤"></a><a id="10816" href="/PLFA-zh/Connectives/#10816" class="Datatype">⊤</a> <a id="10818" class="Symbol">:</a> <a id="10820" class="PrimitiveType">Set</a> <a id="10824" class="Keyword">where</a>

  <a id="⊤.tt"></a><a id="10833" href="/PLFA-zh/Connectives/#10833" class="InductiveConstructor">tt</a> <a id="10836" class="Symbol">:</a>
    <a id="10842" class="Comment">--</a>
    <a id="10849" href="/PLFA-zh/Connectives/#10816" class="Datatype">⊤</a>
</pre>
<!-- Evidence that `⊤` holds is of the form `tt`. -->

<p><code class="language-plaintext highlighter-rouge">⊤</code> 成立的证明由 <code class="language-plaintext highlighter-rouge">tt</code> 的形式构成。</p>

<!-- There is an introduction rule, but no elimination rule.
Given evidence that `⊤` holds, there is nothing more of interest we
can conclude.  Since truth always holds, knowing that it holds tells
us nothing new. -->

<p>恒真有引入规则，但没有消去规则。给定一个 <code class="language-plaintext highlighter-rouge">⊤</code> 成立的证明，我们不能得出任何有趣的结论。因为恒真恒成立，知道恒真成立不会给我们带来新的知识。</p>

<!-- The nullary case of `η-×` is `η-⊤`, which asserts that any
value of type `⊤` must be equal to `tt`: -->

<p><code class="language-plaintext highlighter-rouge">η-×</code> 的 零元形式是 <code class="language-plaintext highlighter-rouge">η-⊤</code>，其断言了任何 <code class="language-plaintext highlighter-rouge">⊤</code> 类型的值一定等于 <code class="language-plaintext highlighter-rouge">tt</code>：</p>

<pre class="Agda"><a id="η-⊤"></a><a id="11413" href="/PLFA-zh/Connectives/#11413" class="Function">η-⊤</a> <a id="11417" class="Symbol">:</a> <a id="11419" class="Symbol">∀</a> <a id="11421" class="Symbol">(</a><a id="11422" href="plfa.part1.Connectives.html#11422" class="Bound">w</a> <a id="11424" class="Symbol">:</a> <a id="11426" href="plfa.part1.Connectives.html#10816" class="Datatype">⊤</a><a id="11427" class="Symbol">)</a> <a id="11429" class="Symbol">→</a> <a id="11431" href="plfa.part1.Connectives.html#10833" class="InductiveConstructor">tt</a> <a id="11434" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="11436" href="plfa.part1.Connectives.html#11422" class="Bound">w</a>
<a id="11438" href="/PLFA-zh/Connectives/#11413" class="Function">η-⊤</a> <a id="11442" href="plfa.part1.Connectives.html#10833" class="InductiveConstructor">tt</a> <a id="11445" class="Symbol">=</a> <a id="11447" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<!-- The pattern matching on the left-hand side is essential.  Replacing
`w` by `tt` allows both sides of the propositional equality to
simplify to the same term. -->

<p>左手边的模式匹配是必要的。将 <code class="language-plaintext highlighter-rouge">w</code> 替换为 <code class="language-plaintext highlighter-rouge">tt</code> 让等式两边可以化简为相同的值。</p>

<!-- We refer to `⊤` as the _unit_ type. And, indeed,
type `⊤` has exactly one member, `tt`.  For example, the following
function enumerates all possible arguments of type `⊤`:

我们将 `⊤` 称为*单元*类型（Unit Type）。实际上，`⊤` 类型只有一个成员 `tt`。例如，下面的函数枚举了所有 `⊤` 类型的参数：
 -->
<pre class="Agda"><a id="⊤-count"></a><a id="11949" href="/PLFA-zh/Connectives/#11949" class="Function">⊤-count</a> <a id="11957" class="Symbol">:</a> <a id="11959" href="plfa.part1.Connectives.html#10816" class="Datatype">⊤</a> <a id="11961" class="Symbol">→</a> <a id="11963" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="11965" href="/PLFA-zh/Connectives/#11949" class="Function">⊤-count</a> <a id="11973" href="plfa.part1.Connectives.html#10833" class="InductiveConstructor">tt</a> <a id="11976" class="Symbol">=</a> <a id="11978" class="Number">1</a>
</pre>
<!-- For numbers, one is the identity of multiplication. Correspondingly,
unit is the identity of product _up to isomorphism_.  For left
identity, the `to` function takes `⟨ tt , x ⟩` to `x`, and the `from`
function does the inverse.  The evidence of left inverse requires
matching against a suitable pattern to enable simplification: -->

<p>对于数来说，1 是乘法的幺元。对应地，单元是积的幺元（<em>在同构意义下</em>）。对于左幺元来说，
<code class="language-plaintext highlighter-rouge">to</code> 函数将 <code class="language-plaintext highlighter-rouge">⟨ tt , x ⟩</code> 转换成 <code class="language-plaintext highlighter-rouge">x</code>， <code class="language-plaintext highlighter-rouge">from</code> 函数则是其反函数。左逆的证明需要匹配一个合适的模式来化简：</p>

<pre class="Agda"><a id="⊤-identityˡ"></a><a id="12453" href="/PLFA-zh/Connectives/#12453" class="Function">⊤-identityˡ</a> <a id="12465" class="Symbol">:</a> <a id="12467" class="Symbol">∀</a> <a id="12469" class="Symbol">{</a><a id="12470" href="plfa.part1.Connectives.html#12470" class="Bound">A</a> <a id="12472" class="Symbol">:</a> <a id="12474" class="PrimitiveType">Set</a><a id="12477" class="Symbol">}</a> <a id="12479" class="Symbol">→</a> <a id="12481" href="plfa.part1.Connectives.html#10816" class="Datatype">⊤</a> <a id="12483" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="12485" href="plfa.part1.Connectives.html#12470" class="Bound">A</a> <a id="12487" href="/PLFA-zh/Isomorphism/#5849" class="Record Operator">≃</a> <a id="12489" href="plfa.part1.Connectives.html#12470" class="Bound">A</a>
<a id="12491" href="/PLFA-zh/Connectives/#12453" class="Function">⊤-identityˡ</a> <a id="12503" class="Symbol">=</a>
  <a id="12507" class="Keyword">record</a>
    <a id="12518" class="Symbol">{</a> <a id="12520" href="/PLFA-zh/Isomorphism/#5889" class="Field">to</a>      <a id="12528" class="Symbol">=</a> <a id="12530" class="Symbol">λ{</a> <a id="12533" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="12535" href="plfa.part1.Connectives.html#10833" class="InductiveConstructor">tt</a> <a id="12538" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="12540" href="plfa.part1.Connectives.html#12540" class="Bound">x</a> <a id="12542" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="12544" class="Symbol">→</a> <a id="12546" href="plfa.part1.Connectives.html#12540" class="Bound">x</a> <a id="12548" class="Symbol">}</a>
    <a id="12554" class="Symbol">;</a> <a id="12556" href="/PLFA-zh/Isomorphism/#5906" class="Field">from</a>    <a id="12564" class="Symbol">=</a> <a id="12566" class="Symbol">λ{</a> <a id="12569" href="/PLFA-zh/Connectives/#12569" class="Bound">x</a> <a id="12571" class="Symbol">→</a> <a id="12573" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="12575" href="plfa.part1.Connectives.html#10833" class="InductiveConstructor">tt</a> <a id="12578" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="12580" href="plfa.part1.Connectives.html#12569" class="Bound">x</a> <a id="12582" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="12584" class="Symbol">}</a>
    <a id="12590" class="Symbol">;</a> <a id="12592" href="/PLFA-zh/Isomorphism/#5923" class="Field">from∘to</a> <a id="12600" class="Symbol">=</a> <a id="12602" class="Symbol">λ{</a> <a id="12605" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="12607" href="plfa.part1.Connectives.html#10833" class="InductiveConstructor">tt</a> <a id="12610" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="12612" href="plfa.part1.Connectives.html#12612" class="Bound">x</a> <a id="12614" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="12616" class="Symbol">→</a> <a id="12618" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="12623" class="Symbol">}</a>
    <a id="12629" class="Symbol">;</a> <a id="12631" href="/PLFA-zh/Isomorphism/#5965" class="Field">to∘from</a> <a id="12639" class="Symbol">=</a> <a id="12641" class="Symbol">λ{</a> <a id="12644" href="/PLFA-zh/Connectives/#12644" class="Bound">x</a> <a id="12646" class="Symbol">→</a> <a id="12648" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="12653" class="Symbol">}</a>
    <a id="12659" class="Symbol">}</a>
</pre>
<!-- Having an _identity_ is different from having an identity
_up to isomorphism_.  Compare the two statements: -->

<p><em>幺元</em>和<em>在同构意义下的幺元</em>是不一样的。比较下列两个命题：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 * m ≡ m
⊤ × A ≃ A
</code></pre></div></div>

<!-- In the first case, we might have that `m` is `2`, and both
`1 * m` and `m` are equal to `2`.  In the second
case, we might have that `A` is `Bool`, and `⊤ × Bool` is _not_ the
same as `Bool`.  But there is an isomorphism between the two types.
For instance, `⟨ tt , true ⟩`, which is a member of the former,
corresponds to `true`, which is a member of the latter. -->

<p>在第一种情况下，我们可能有 <code class="language-plaintext highlighter-rouge">m</code> 是 <code class="language-plaintext highlighter-rouge">2</code>，那么 <code class="language-plaintext highlighter-rouge">1 * m</code> 和 <code class="language-plaintext highlighter-rouge">m</code> 都为 <code class="language-plaintext highlighter-rouge">2</code>。在第二种情况下，我们可能有 <code class="language-plaintext highlighter-rouge">A</code> 是 <code class="language-plaintext highlighter-rouge">Bool</code>，但是 <code class="language-plaintext highlighter-rouge">⊤ × Bool</code> 和 <code class="language-plaintext highlighter-rouge">Bool</code> 是不同的。例如：<code class="language-plaintext highlighter-rouge">⟨ tt , true ⟩</code> 是前者的成员，其对应后者的成员 <code class="language-plaintext highlighter-rouge">true</code>。</p>

<!-- Right identity follows from commutativity of product and left identity: -->

<p>右幺元可以由积的交换律得来：</p>

<pre class="Agda"><a id="⊤-identityʳ"></a><a id="13495" href="/PLFA-zh/Connectives/#13495" class="Function">⊤-identityʳ</a> <a id="13507" class="Symbol">:</a> <a id="13509" class="Symbol">∀</a> <a id="13511" class="Symbol">{</a><a id="13512" href="plfa.part1.Connectives.html#13512" class="Bound">A</a> <a id="13514" class="Symbol">:</a> <a id="13516" class="PrimitiveType">Set</a><a id="13519" class="Symbol">}</a> <a id="13521" class="Symbol">→</a> <a id="13523" class="Symbol">(</a><a id="13524" href="plfa.part1.Connectives.html#13512" class="Bound">A</a> <a id="13526" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="13528" href="plfa.part1.Connectives.html#10816" class="Datatype">⊤</a><a id="13529" class="Symbol">)</a> <a id="13531" href="/PLFA-zh/Isomorphism/#5849" class="Record Operator">≃</a> <a id="13533" href="plfa.part1.Connectives.html#13512" class="Bound">A</a>
<a id="13535" href="/PLFA-zh/Connectives/#13495" class="Function">⊤-identityʳ</a> <a id="13547" class="Symbol">{</a><a id="13548" href="plfa.part1.Connectives.html#13548" class="Bound">A</a><a id="13549" class="Symbol">}</a> <a id="13551" class="Symbol">=</a>
  <a id="13555" href="/PLFA-zh/Isomorphism/#11069" class="Function Operator">≃-begin</a>
    <a id="13567" class="Symbol">(</a><a id="13568" href="/PLFA-zh/Connectives/#13548" class="Bound">A</a> <a id="13570" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="13572" href="plfa.part1.Connectives.html#10816" class="Datatype">⊤</a><a id="13573" class="Symbol">)</a>
  <a id="13577" href="/PLFA-zh/Isomorphism/#11153" class="Function Operator">≃⟨</a> <a id="13580" href="/PLFA-zh/Connectives/#7801" class="Function">×-comm</a> <a id="13587" href="plfa.part1.Isomorphism.html#11153" class="Function Operator">⟩</a>
    <a id="13593" class="Symbol">(</a><a id="13594" href="/PLFA-zh/Connectives/#10816" class="Datatype">⊤</a> <a id="13596" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="13598" href="plfa.part1.Connectives.html#13548" class="Bound">A</a><a id="13599" class="Symbol">)</a>
  <a id="13603" href="/PLFA-zh/Isomorphism/#11153" class="Function Operator">≃⟨</a> <a id="13606" href="/PLFA-zh/Connectives/#12453" class="Function">⊤-identityˡ</a> <a id="13618" href="plfa.part1.Isomorphism.html#11153" class="Function Operator">⟩</a>
    <a id="13624" href="/PLFA-zh/Connectives/#13548" class="Bound">A</a>
  <a id="13628" href="/PLFA-zh/Isomorphism/#11272" class="Function Operator">≃-∎</a>
</pre>
<!-- Here we have used a chain of isomorphisms, analogous to that used for
equality. -->

<p>我们在此使用了同构链，与等式链相似。</p>

<!-- ## Disjunction is sum -->

<h2 id="析取即是和">析取即是和</h2>

<!-- Given two propositions `A` and `B`, the disjunction `A ⊎ B` holds
if either `A` holds or `B` holds.  We formalise this idea by
declaring a suitable inductive type: -->

<p>给定两个命题 <code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code>，析取 <code class="language-plaintext highlighter-rouge">A ⊎ B</code> 在 <code class="language-plaintext highlighter-rouge">A</code> 成立或者 <code class="language-plaintext highlighter-rouge">B</code> 成立时成立。我们将这个概念用合适的归纳类型来形式化：</p>

<pre class="Agda"><a id="14063" class="Keyword">data</a> <a id="_⊎_"></a><a id="14068" href="/PLFA-zh/Connectives/#14068" class="Datatype Operator">_⊎_</a> <a id="14072" class="Symbol">(</a><a id="14073" href="plfa.part1.Connectives.html#14073" class="Bound">A</a> <a id="14075" href="plfa.part1.Connectives.html#14075" class="Bound">B</a> <a id="14077" class="Symbol">:</a> <a id="14079" class="PrimitiveType">Set</a><a id="14082" class="Symbol">)</a> <a id="14084" class="Symbol">:</a> <a id="14086" class="PrimitiveType">Set</a> <a id="14090" class="Keyword">where</a>

  <a id="_⊎_.inj₁"></a><a id="14099" href="/PLFA-zh/Connectives/#14099" class="InductiveConstructor">inj₁</a> <a id="14104" class="Symbol">:</a>
      <a id="14112" href="/PLFA-zh/Connectives/#14073" class="Bound">A</a>
      <a id="14120" class="Comment">-----</a>
    <a id="14130" class="Symbol">→</a> <a id="14132" href="/PLFA-zh/Connectives/#14073" class="Bound">A</a> <a id="14134" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="14136" href="plfa.part1.Connectives.html#14075" class="Bound">B</a>

  <a id="_⊎_.inj₂"></a><a id="14141" href="/PLFA-zh/Connectives/#14141" class="InductiveConstructor">inj₂</a> <a id="14146" class="Symbol">:</a>
      <a id="14154" href="/PLFA-zh/Connectives/#14075" class="Bound">B</a>
      <a id="14162" class="Comment">-----</a>
    <a id="14172" class="Symbol">→</a> <a id="14174" href="/PLFA-zh/Connectives/#14073" class="Bound">A</a> <a id="14176" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="14178" href="plfa.part1.Connectives.html#14075" class="Bound">B</a>
</pre>
<!-- Evidence that `A ⊎ B` holds is either of the form `inj₁ M`, where `M`
provides evidence that `A` holds, or `inj₂ N`, where `N` provides
evidence that `B` holds. -->

<p><code class="language-plaintext highlighter-rouge">A ⊎ B</code> 成立的证明有两个形式： <code class="language-plaintext highlighter-rouge">inj₁ M</code>，其中 <code class="language-plaintext highlighter-rouge">M</code> 是 <code class="language-plaintext highlighter-rouge">A</code> 成立的证明，或者
<code class="language-plaintext highlighter-rouge">inj₂ N</code>，其中 <code class="language-plaintext highlighter-rouge">N</code> 是 <code class="language-plaintext highlighter-rouge">B</code> 成立的证明。</p>

<!-- Given evidence that `A → C` and `B → C` both hold, then given
evidence that `A ⊎ B` holds we can conclude that `C` holds: -->

<p>给定 <code class="language-plaintext highlighter-rouge">A → C</code> 和 <code class="language-plaintext highlighter-rouge">B → C</code> 成立的证明，那么给定一个 <code class="language-plaintext highlighter-rouge">A ⊎ B</code> 的证明，我们可以得出 <code class="language-plaintext highlighter-rouge">C</code> 成立：</p>

<pre class="Agda"><a id="case-⊎"></a><a id="14651" href="/PLFA-zh/Connectives/#14651" class="Function">case-⊎</a> <a id="14658" class="Symbol">:</a> <a id="14660" class="Symbol">∀</a> <a id="14662" class="Symbol">{</a><a id="14663" href="plfa.part1.Connectives.html#14663" class="Bound">A</a> <a id="14665" href="plfa.part1.Connectives.html#14665" class="Bound">B</a> <a id="14667" href="plfa.part1.Connectives.html#14667" class="Bound">C</a> <a id="14669" class="Symbol">:</a> <a id="14671" class="PrimitiveType">Set</a><a id="14674" class="Symbol">}</a>
  <a id="14678" class="Symbol">→</a> <a id="14680" class="Symbol">(</a><a id="14681" href="/PLFA-zh/Connectives/#14663" class="Bound">A</a> <a id="14683" class="Symbol">→</a> <a id="14685" href="plfa.part1.Connectives.html#14667" class="Bound">C</a><a id="14686" class="Symbol">)</a>
  <a id="14690" class="Symbol">→</a> <a id="14692" class="Symbol">(</a><a id="14693" href="/PLFA-zh/Connectives/#14665" class="Bound">B</a> <a id="14695" class="Symbol">→</a> <a id="14697" href="plfa.part1.Connectives.html#14667" class="Bound">C</a><a id="14698" class="Symbol">)</a>
  <a id="14702" class="Symbol">→</a> <a id="14704" href="/PLFA-zh/Connectives/#14663" class="Bound">A</a> <a id="14706" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="14708" href="plfa.part1.Connectives.html#14665" class="Bound">B</a>
    <a id="14714" class="Comment">-----------</a>
  <a id="14728" class="Symbol">→</a> <a id="14730" href="/PLFA-zh/Connectives/#14667" class="Bound">C</a>
<a id="14732" href="/PLFA-zh/Connectives/#14651" class="Function">case-⊎</a> <a id="14739" href="plfa.part1.Connectives.html#14739" class="Bound">f</a> <a id="14741" href="plfa.part1.Connectives.html#14741" class="Bound">g</a> <a id="14743" class="Symbol">(</a><a id="14744" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="14749" href="plfa.part1.Connectives.html#14749" class="Bound">x</a><a id="14750" class="Symbol">)</a> <a id="14752" class="Symbol">=</a> <a id="14754" href="plfa.part1.Connectives.html#14739" class="Bound">f</a> <a id="14756" href="plfa.part1.Connectives.html#14749" class="Bound">x</a>
<a id="14758" href="/PLFA-zh/Connectives/#14651" class="Function">case-⊎</a> <a id="14765" href="plfa.part1.Connectives.html#14765" class="Bound">f</a> <a id="14767" href="plfa.part1.Connectives.html#14767" class="Bound">g</a> <a id="14769" class="Symbol">(</a><a id="14770" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="14775" href="plfa.part1.Connectives.html#14775" class="Bound">y</a><a id="14776" class="Symbol">)</a> <a id="14778" class="Symbol">=</a> <a id="14780" href="plfa.part1.Connectives.html#14767" class="Bound">g</a> <a id="14782" href="plfa.part1.Connectives.html#14775" class="Bound">y</a>
</pre>
<!-- Pattern matching against `inj₁` and `inj₂` is typical of how we exploit
evidence that a disjunction holds. -->

<p>对 <code class="language-plaintext highlighter-rouge">inj₁</code> 和 <code class="language-plaintext highlighter-rouge">inj₂</code> 进行模式匹配，是我们使用析取成立的证明的常见方法。</p>

<!-- When `inj₁` and `inj₂` appear on the right-hand side of an equation we
refer to them as _constructors_, and when they appear on the
left-hand side we refer to them as _destructors_.  We also refer to
`case-⊎` as a destructor, since it plays a similar role.  Other
terminology refers to `inj₁` and `inj₂` as _introducing_ a
disjunction, and to `case-⊎` as _eliminating_ a disjunction; indeed
the former are sometimes given the names `⊎-I₁` and `⊎-I₂` and the
latter the name `⊎-E`. -->

<p>当 <code class="language-plaintext highlighter-rouge">inj₁</code> 和 <code class="language-plaintext highlighter-rouge">inj₂</code> 在等式右手边出现的时候，我们将其称作<em>构造子</em>，当它出现在等式左边时，我们将其称作<em>析构器</em>。我们亦可将 <code class="language-plaintext highlighter-rouge">case-⊎</code>
称作析构器，因为它们起到相似的效果。其他术语将 <code class="language-plaintext highlighter-rouge">inj₁</code> 和 <code class="language-plaintext highlighter-rouge">inj₂</code> 称为<em>引入</em>析取，将 <code class="language-plaintext highlighter-rouge">case-⊎</code> 称为<em>消去</em>析取。前者亦被称为 <code class="language-plaintext highlighter-rouge">⊎-I₁</code> 和 <code class="language-plaintext highlighter-rouge">⊎-I₂</code>，后者 <code class="language-plaintext highlighter-rouge">⊎-E</code>。</p>

<!-- Applying the destructor to each of the constructors is the identity: -->

<p>对每个构造子使用析构器得到的是原来的值：</p>

<pre class="Agda"><a id="η-⊎"></a><a id="15756" href="/PLFA-zh/Connectives/#15756" class="Function">η-⊎</a> <a id="15760" class="Symbol">:</a> <a id="15762" class="Symbol">∀</a> <a id="15764" class="Symbol">{</a><a id="15765" href="plfa.part1.Connectives.html#15765" class="Bound">A</a> <a id="15767" href="plfa.part1.Connectives.html#15767" class="Bound">B</a> <a id="15769" class="Symbol">:</a> <a id="15771" class="PrimitiveType">Set</a><a id="15774" class="Symbol">}</a> <a id="15776" class="Symbol">(</a><a id="15777" href="plfa.part1.Connectives.html#15777" class="Bound">w</a> <a id="15779" class="Symbol">:</a> <a id="15781" href="plfa.part1.Connectives.html#15765" class="Bound">A</a> <a id="15783" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="15785" href="plfa.part1.Connectives.html#15767" class="Bound">B</a><a id="15786" class="Symbol">)</a> <a id="15788" class="Symbol">→</a> <a id="15790" href="plfa.part1.Connectives.html#14651" class="Function">case-⊎</a> <a id="15797" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="15802" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="15807" href="plfa.part1.Connectives.html#15777" class="Bound">w</a> <a id="15809" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="15811" href="plfa.part1.Connectives.html#15777" class="Bound">w</a>
<a id="15813" href="/PLFA-zh/Connectives/#15756" class="Function">η-⊎</a> <a id="15817" class="Symbol">(</a><a id="15818" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="15823" href="plfa.part1.Connectives.html#15823" class="Bound">x</a><a id="15824" class="Symbol">)</a> <a id="15826" class="Symbol">=</a> <a id="15828" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="15833" href="/PLFA-zh/Connectives/#15756" class="Function">η-⊎</a> <a id="15837" class="Symbol">(</a><a id="15838" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="15843" href="plfa.part1.Connectives.html#15843" class="Bound">y</a><a id="15844" class="Symbol">)</a> <a id="15846" class="Symbol">=</a> <a id="15848" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<!-- More generally, we can also throw in an arbitrary function from a disjunction: -->

<p>更普遍地来说，我们亦可对于析取使用一个任意的函数：</p>

<pre class="Agda"><a id="uniq-⊎"></a><a id="15986" href="/PLFA-zh/Connectives/#15986" class="Function">uniq-⊎</a> <a id="15993" class="Symbol">:</a> <a id="15995" class="Symbol">∀</a> <a id="15997" class="Symbol">{</a><a id="15998" href="plfa.part1.Connectives.html#15998" class="Bound">A</a> <a id="16000" href="plfa.part1.Connectives.html#16000" class="Bound">B</a> <a id="16002" href="plfa.part1.Connectives.html#16002" class="Bound">C</a> <a id="16004" class="Symbol">:</a> <a id="16006" class="PrimitiveType">Set</a><a id="16009" class="Symbol">}</a> <a id="16011" class="Symbol">(</a><a id="16012" href="plfa.part1.Connectives.html#16012" class="Bound">h</a> <a id="16014" class="Symbol">:</a> <a id="16016" href="plfa.part1.Connectives.html#15998" class="Bound">A</a> <a id="16018" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="16020" href="plfa.part1.Connectives.html#16000" class="Bound">B</a> <a id="16022" class="Symbol">→</a> <a id="16024" href="plfa.part1.Connectives.html#16002" class="Bound">C</a><a id="16025" class="Symbol">)</a> <a id="16027" class="Symbol">(</a><a id="16028" href="plfa.part1.Connectives.html#16028" class="Bound">w</a> <a id="16030" class="Symbol">:</a> <a id="16032" href="plfa.part1.Connectives.html#15998" class="Bound">A</a> <a id="16034" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="16036" href="plfa.part1.Connectives.html#16000" class="Bound">B</a><a id="16037" class="Symbol">)</a> <a id="16039" class="Symbol">→</a>
  <a id="16043" href="/PLFA-zh/Connectives/#14651" class="Function">case-⊎</a> <a id="16050" class="Symbol">(</a><a id="16051" href="plfa.part1.Connectives.html#16012" class="Bound">h</a> <a id="16053" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="16055" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a><a id="16059" class="Symbol">)</a> <a id="16061" class="Symbol">(</a><a id="16062" href="plfa.part1.Connectives.html#16012" class="Bound">h</a> <a id="16064" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="16066" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a><a id="16070" class="Symbol">)</a> <a id="16072" href="plfa.part1.Connectives.html#16028" class="Bound">w</a> <a id="16074" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="16076" href="plfa.part1.Connectives.html#16012" class="Bound">h</a> <a id="16078" href="plfa.part1.Connectives.html#16028" class="Bound">w</a>
<a id="16080" href="/PLFA-zh/Connectives/#15986" class="Function">uniq-⊎</a> <a id="16087" href="plfa.part1.Connectives.html#16087" class="Bound">h</a> <a id="16089" class="Symbol">(</a><a id="16090" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="16095" href="plfa.part1.Connectives.html#16095" class="Bound">x</a><a id="16096" class="Symbol">)</a> <a id="16098" class="Symbol">=</a> <a id="16100" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="16105" href="/PLFA-zh/Connectives/#15986" class="Function">uniq-⊎</a> <a id="16112" href="plfa.part1.Connectives.html#16112" class="Bound">h</a> <a id="16114" class="Symbol">(</a><a id="16115" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="16120" href="plfa.part1.Connectives.html#16120" class="Bound">y</a><a id="16121" class="Symbol">)</a> <a id="16123" class="Symbol">=</a> <a id="16125" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<!-- The pattern matching on the left-hand side is essential.  Replacing
`w` by `inj₁ x` allows both sides of the propositional equality to
simplify to the same term, and similarly for `inj₂ y`. -->

<p>左手边的模式匹配是必要的。用 <code class="language-plaintext highlighter-rouge">inj₁ x</code> 来替换 <code class="language-plaintext highlighter-rouge">w</code> 让等式的两边可以化简成相同的项，
<code class="language-plaintext highlighter-rouge">inj₂ y</code> 同理。</p>

<!-- We set the precedence of disjunction so that it binds less tightly
than any other declared operator: -->

<p>我们设置析取的优先级，使它与任何已经定义的运算符都结合的不紧密：</p>

<pre class="Agda"><a id="16563" class="Keyword">infixr</a> <a id="16570" class="Number">1</a> <a id="16572" href="/PLFA-zh/Connectives/#14068" class="Datatype Operator">_⊎_</a>
</pre>
<!-- Thus, `A × C ⊎ B × C` parses as `(A × C) ⊎ (B × C)`. -->

<p>因此 <code class="language-plaintext highlighter-rouge">A × C ⊎ B × C</code> 解析为 <code class="language-plaintext highlighter-rouge">(A × C) ⊎ (B × C)</code>。</p>

<!-- Given two types `A` and `B`, we refer to `A ⊎ B` as the
_sum_ of `A` and `B`.  In set theory, it is also sometimes
called the _disjoint union_, and in computing it corresponds
to a _variant record_ type. Among other reasons for
calling it the sum, note that if type `A` has `m`
distinct members, and type `B` has `n` distinct members,
then the type `A ⊎ B` has `m + n` distinct members.
For instance, consider a type `Bool` with two members, and
a type `Tri` with three members, as defined earlier.
Then the type `Bool ⊎ Tri` has five
members: -->

<p>给定两个类型 <code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code>，我们将 <code class="language-plaintext highlighter-rouge">A ⊎ B</code> 称为 <code class="language-plaintext highlighter-rouge">A</code> 与 <code class="language-plaintext highlighter-rouge">B</code> 的<em>和</em>。在集合论中它也被称作<em>不交并</em>（Disjoint Union），在计算机科学中它对应<em>变体记录</em>类型。如果类型 <code class="language-plaintext highlighter-rouge">A</code> 有 <code class="language-plaintext highlighter-rouge">m</code> 个不同的成员，类型 <code class="language-plaintext highlighter-rouge">B</code> 有 <code class="language-plaintext highlighter-rouge">n</code> 个不同的成员，那么类型 <code class="language-plaintext highlighter-rouge">A ⊎ B</code> 有 <code class="language-plaintext highlighter-rouge">m + n</code> 个不同的成员。这也是它被称为和的原因之一。例如，考虑有两个成员的 <code class="language-plaintext highlighter-rouge">Bool</code> 类型，和有三个成员的 <code class="language-plaintext highlighter-rouge">Tri</code> 类型，如之前的定义。那么，<code class="language-plaintext highlighter-rouge">Bool ⊎ Tri</code> 类型有如下的五个成员：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inj₁ true     inj₂ aa
inj₁ false    inj₂ bb
              inj₂ cc
</code></pre></div></div>

<!-- For example, the following function enumerates all
possible arguments of type `Bool ⊎ Tri`: -->

<p>下面的函数枚举了所有类型为 <code class="language-plaintext highlighter-rouge">Bool ⊎ Tri</code> 的参数：</p>

<pre class="Agda"><a id="⊎-count"></a><a id="17749" href="/PLFA-zh/Connectives/#17749" class="Function">⊎-count</a> <a id="17757" class="Symbol">:</a> <a id="17759" href="plfa.part1.Connectives.html#6349" class="Datatype">Bool</a> <a id="17764" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="17766" href="plfa.part1.Connectives.html#6402" class="Datatype">Tri</a> <a id="17770" class="Symbol">→</a> <a id="17772" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="17774" href="/PLFA-zh/Connectives/#17749" class="Function">⊎-count</a> <a id="17782" class="Symbol">(</a><a id="17783" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="17788" href="plfa.part1.Connectives.html#6368" class="InductiveConstructor">true</a><a id="17792" class="Symbol">)</a>   <a id="17796" class="Symbol">=</a>  <a id="17799" class="Number">1</a>
<a id="17801" href="/PLFA-zh/Connectives/#17749" class="Function">⊎-count</a> <a id="17809" class="Symbol">(</a><a id="17810" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="17815" href="plfa.part1.Connectives.html#6383" class="InductiveConstructor">false</a><a id="17820" class="Symbol">)</a>  <a id="17823" class="Symbol">=</a>  <a id="17826" class="Number">2</a>
<a id="17828" href="/PLFA-zh/Connectives/#17749" class="Function">⊎-count</a> <a id="17836" class="Symbol">(</a><a id="17837" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="17842" href="plfa.part1.Connectives.html#6420" class="InductiveConstructor">aa</a><a id="17844" class="Symbol">)</a>     <a id="17850" class="Symbol">=</a>  <a id="17853" class="Number">3</a>
<a id="17855" href="/PLFA-zh/Connectives/#17749" class="Function">⊎-count</a> <a id="17863" class="Symbol">(</a><a id="17864" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="17869" href="plfa.part1.Connectives.html#6431" class="InductiveConstructor">bb</a><a id="17871" class="Symbol">)</a>     <a id="17877" class="Symbol">=</a>  <a id="17880" class="Number">4</a>
<a id="17882" href="/PLFA-zh/Connectives/#17749" class="Function">⊎-count</a> <a id="17890" class="Symbol">(</a><a id="17891" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="17896" href="plfa.part1.Connectives.html#6442" class="InductiveConstructor">cc</a><a id="17898" class="Symbol">)</a>     <a id="17904" class="Symbol">=</a>  <a id="17907" class="Number">5</a>
</pre>
<!-- Sum on types also shares a property with sum on numbers in that it is
commutative and associative _up to isomorphism_. -->

<p>类型上的和与数的和有相似的性质——它们满足交换律和结合律。更确切地说，和在<em>在同构意义下</em>是交换和结合的。</p>

<!-- #### Exercise `⊎-comm` (recommended) -->

<h4 id="练习--comm-推荐">练习 <code class="language-plaintext highlighter-rouge">⊎-comm</code> （推荐）</h4>

<!-- Show sum is commutative up to isomorphism. -->

<p>证明和类型在同构意义下满足交换律。</p>

<!-- <pre class="Agda"><a id="18281" class="Comment">-- Your code goes here</a>
</pre>{:/}

<pre class="Agda"><a id="18318" class="Comment">-- 请将代码写在此处。</a>
</pre>
{::comment}
#### Exercise `⊎-assoc` (practice) -->

<h4 id="练习--assoc实践">练习 <code class="language-plaintext highlighter-rouge">⊎-assoc</code>（实践）</h4>

<!-- Show sum is associative up to isomorphism. -->

<p>证明和类型在同构意义下满足结合律。</p>

<!-- <pre class="Agda"><a id="18508" class="Comment">-- Your code goes here</a>
</pre>{:/}

<pre class="Agda"><a id="18545" class="Comment">-- 请将代码写在此处。</a>
</pre>
{::comment}
## False is empty -->

<h2 id="假即是空类型">假即是空类型</h2>

<!-- False `⊥` never holds.  We formalise this idea by declaring
a suitable inductive type: -->

<p>恒假 <code class="language-plaintext highlighter-rouge">⊥</code> 从不成立。我们将这个概念用合适的归纳类型来形式化：</p>

<!-- FIXME: the code block is removed to make Agda not recognise this as code.
data ⊥ : Set where
  -- no clauses! -->

<pre class="Agda"><a id="18881" class="Keyword">data</a> <a id="⊥"></a><a id="18886" href="/PLFA-zh/Connectives/#18886" class="Datatype">⊥</a> <a id="18888" class="Symbol">:</a> <a id="18890" class="PrimitiveType">Set</a> <a id="18894" class="Keyword">where</a>
  <a id="18902" class="Comment">-- 没有语句！</a>
</pre>
<!-- There is no possible evidence that `⊥` holds. -->

<p>没有 <code class="language-plaintext highlighter-rouge">⊥</code> 成立的证明。</p>

<!-- Dual to `⊤`, for `⊥` there is no introduction rule but an elimination rule.
Since false never holds, knowing that it holds tells us we are in a
paradoxical situation.  Given evidence that `⊥` holds, we might
conclude anything!  This is a basic principle of logic, known in
medieval times by the Latin phrase _ex falso_, and known to children
through phrases such as "if pigs had wings, then I'd be the Queen of
Sheba".  We formalise it as follows: -->

<p>与 <code class="language-plaintext highlighter-rouge">⊤</code> 相对偶，<code class="language-plaintext highlighter-rouge">⊥</code> 没有引入规则，但是有消去规则。因为恒假从不成立，如果它一旦成立，我们就进入了矛盾之中。给定 <code class="language-plaintext highlighter-rouge">⊥</code> 成立的证明，我们可以得出任何结论！这是逻辑学的基本原理，又由中世纪的拉丁文词组 <em>ex falso</em> 为名。小孩子也由诸如
“如果猪有翅膀，那我就是示巴女王”的词组中知晓。我们如下将它形式化：</p>

<pre class="Agda"><a id="⊥-elim"></a><a id="19629" href="/PLFA-zh/Connectives/#19629" class="Function">⊥-elim</a> <a id="19636" class="Symbol">:</a> <a id="19638" class="Symbol">∀</a> <a id="19640" class="Symbol">{</a><a id="19641" href="plfa.part1.Connectives.html#19641" class="Bound">A</a> <a id="19643" class="Symbol">:</a> <a id="19645" class="PrimitiveType">Set</a><a id="19648" class="Symbol">}</a>
  <a id="19652" class="Symbol">→</a> <a id="19654" href="/PLFA-zh/Connectives/#18886" class="Datatype">⊥</a>
    <a id="19660" class="Comment">--</a>
  <a id="19665" class="Symbol">→</a> <a id="19667" href="/PLFA-zh/Connectives/#19641" class="Bound">A</a>
<a id="19669" href="/PLFA-zh/Connectives/#19629" class="Function">⊥-elim</a> <a id="19676" class="Symbol">()</a>
</pre>
<!-- This is our first use of the _absurd pattern_ `()`.
Here since `⊥` is a type with no members, we indicate that it is
_never_ possible to match against a value of this type by using
the pattern `()`. -->

<p>这是我们第一次使用<em>荒谬模式</em>（Absurd Pattern） <code class="language-plaintext highlighter-rouge">()</code>。在这里，因为 <code class="language-plaintext highlighter-rouge">⊥</code>
是一个没有成员的类型，我们用 <code class="language-plaintext highlighter-rouge">()</code> 模式来指明这里不可能匹配任何这个类型的值。</p>

<!-- The nullary case of `case-⊎` is `⊥-elim`.  By analogy,
we might have called it `case-⊥`, but chose to stick with the name
in the standard library. -->

<p><code class="language-plaintext highlighter-rouge">case-⊎</code> 的零元形式是 <code class="language-plaintext highlighter-rouge">⊥-elim</code>。类比的来说，它应该叫做 <code class="language-plaintext highlighter-rouge">case-⊥</code>，但是我们在此使用标准库中使用的名字。</p>

<!-- The nullary case of `uniq-⊎` is `uniq-⊥`, which asserts that `⊥-elim`
is equal to any arbitrary function from `⊥`: -->

<p><code class="language-plaintext highlighter-rouge">uniq-⊎</code> 的零元形式是 <code class="language-plaintext highlighter-rouge">uniq-⊥</code>，其断言了 <code class="language-plaintext highlighter-rouge">⊥-elim</code> 和任何取 <code class="language-plaintext highlighter-rouge">⊥</code> 的函数是等价的。</p>

<pre class="Agda"><a id="uniq-⊥"></a><a id="20419" href="/PLFA-zh/Connectives/#20419" class="Function">uniq-⊥</a> <a id="20426" class="Symbol">:</a> <a id="20428" class="Symbol">∀</a> <a id="20430" class="Symbol">{</a><a id="20431" href="plfa.part1.Connectives.html#20431" class="Bound">C</a> <a id="20433" class="Symbol">:</a> <a id="20435" class="PrimitiveType">Set</a><a id="20438" class="Symbol">}</a> <a id="20440" class="Symbol">(</a><a id="20441" href="plfa.part1.Connectives.html#20441" class="Bound">h</a> <a id="20443" class="Symbol">:</a> <a id="20445" href="plfa.part1.Connectives.html#18886" class="Datatype">⊥</a> <a id="20447" class="Symbol">→</a> <a id="20449" href="plfa.part1.Connectives.html#20431" class="Bound">C</a><a id="20450" class="Symbol">)</a> <a id="20452" class="Symbol">(</a><a id="20453" href="plfa.part1.Connectives.html#20453" class="Bound">w</a> <a id="20455" class="Symbol">:</a> <a id="20457" href="plfa.part1.Connectives.html#18886" class="Datatype">⊥</a><a id="20458" class="Symbol">)</a> <a id="20460" class="Symbol">→</a> <a id="20462" href="plfa.part1.Connectives.html#19629" class="Function">⊥-elim</a> <a id="20469" href="plfa.part1.Connectives.html#20453" class="Bound">w</a> <a id="20471" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="20473" href="plfa.part1.Connectives.html#20441" class="Bound">h</a> <a id="20475" href="plfa.part1.Connectives.html#20453" class="Bound">w</a>
<a id="20477" href="/PLFA-zh/Connectives/#20419" class="Function">uniq-⊥</a> <a id="20484" href="plfa.part1.Connectives.html#20484" class="Bound">h</a> <a id="20486" class="Symbol">()</a>
</pre>
<!-- Using the absurd pattern asserts there are no possible values for `w`,
so the equation holds trivially. -->

<p>使用荒谬模式断言了 <code class="language-plaintext highlighter-rouge">w</code> 没有任何可能的值，因此等式显然成立。</p>

<!-- We refer to `⊥` as the _empty_ type. And, indeed,
type `⊥` has no members. For example, the following function
enumerates all possible arguments of type `⊥`:

我们将 `⊥` 成为*空*类型（Empty Type）。实际上，`⊥` 类型没有成员。例如，下面的函数枚举了所有 `⊥` 类型的参数：
 -->
<pre class="Agda"><a id="⊥-count"></a><a id="20900" href="/PLFA-zh/Connectives/#20900" class="Function">⊥-count</a> <a id="20908" class="Symbol">:</a> <a id="20910" href="plfa.part1.Connectives.html#18886" class="Datatype">⊥</a> <a id="20912" class="Symbol">→</a> <a id="20914" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="20916" href="/PLFA-zh/Connectives/#20900" class="Function">⊥-count</a> <a id="20924" class="Symbol">()</a>
</pre>
<!-- Here again the absurd pattern `()` indicates that no value can match
type `⊥`. -->

<p>同样，荒谬模式告诉我们没有值可以来匹配类型 <code class="language-plaintext highlighter-rouge">⊥</code>。</p>

<!-- For numbers, zero is the identity of addition. Correspondingly, empty
is the identity of sums _up to isomorphism_. -->

<p>对于数来说，0 是加法的幺元。对应地，空是和的幺元（<em>在同构意义下</em>）。</p>

<!-- #### Exercise `⊥-identityˡ` (recommended) -->

<h4 id="练习--identityˡ-推荐">练习 <code class="language-plaintext highlighter-rouge">⊥-identityˡ</code> （推荐）</h4>

<!-- Show empty is the left identity of sums up to isomorphism. -->

<p>证明空在同构意义下是和的左幺元。</p>

<!-- <pre class="Agda"><a id="21427" class="Comment">-- Your code goes here</a>
</pre>{:/}

<pre class="Agda"><a id="21464" class="Comment">-- 请将代码写在此处。</a>
</pre>
#### Exercise `⊥-identityʳ` (practice)

#### 练习 `⊥-identityʳ`（实践）

{::comment}
Show empty is the right identity of sums up to isomorphism. -->

<p>证明空在同构意义下是和的右幺元。</p>

<!-- <pre class="Agda"><a id="21661" class="Comment">-- Your code goes here</a>
</pre>{:/}

<pre class="Agda"><a id="21698" class="Comment">-- 请将代码写在此处。</a>
</pre>
{::comment}
## Implication is function {#implication} -->

<h2 id="implication">蕴涵即是函数</h2>

<!-- Given two propositions `A` and `B`, the implication `A → B` holds if
whenever `A` holds then `B` must also hold.  We formalise implication using
the function type, which has appeared throughout this book. -->

<p>给定两个命题 <code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code>，其蕴涵 <code class="language-plaintext highlighter-rouge">A → B</code> 在任何 <code class="language-plaintext highlighter-rouge">A</code> 成立的时候，<code class="language-plaintext highlighter-rouge">B</code> 也成立时成立。我们用函数类型来形式化蕴涵，如本书中通篇出现的那样。</p>

<!-- Evidence that `A → B` holds is of the form -->

<p><code class="language-plaintext highlighter-rouge">A → B</code> 成立的证据由下面的形式组成：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>λ (x : A) → N
</code></pre></div></div>

<!-- where `N` is a term of type `B` containing as a free variable `x` of type `A`.
Given a term `L` providing evidence that `A → B` holds, and a term `M`
providing evidence that `A` holds, the term `L M` provides evidence that
`B` holds.  In other words, evidence that `A → B` holds is a function that
converts evidence that `A` holds into evidence that `B` holds. -->

<p>其中 <code class="language-plaintext highlighter-rouge">N</code> 是一个类型为 <code class="language-plaintext highlighter-rouge">B</code> 的项，其包括了一个类型为 <code class="language-plaintext highlighter-rouge">A</code> 的自由变量 <code class="language-plaintext highlighter-rouge">x</code>。给定一个 <code class="language-plaintext highlighter-rouge">A → B</code> 成立的证明 <code class="language-plaintext highlighter-rouge">L</code>，和一个 <code class="language-plaintext highlighter-rouge">A</code> 成立的证明 <code class="language-plaintext highlighter-rouge">M</code>，那么 <code class="language-plaintext highlighter-rouge">L M</code> 是 <code class="language-plaintext highlighter-rouge">B</code> 成立的证明。也就是说，<code class="language-plaintext highlighter-rouge">A → B</code> 成立的证明是一个函数，将 <code class="language-plaintext highlighter-rouge">A</code> 成立的证明转换成 <code class="language-plaintext highlighter-rouge">B</code> 成立的证明。</p>

<!-- Put another way, if we know that `A → B` and `A` both hold,
then we may conclude that `B` holds: -->

<p>换句话说，如果知道 <code class="language-plaintext highlighter-rouge">A → B</code> 和 <code class="language-plaintext highlighter-rouge">A</code> 同时成立，那么我们可以推出 <code class="language-plaintext highlighter-rouge">B</code> 成立：</p>

<pre class="Agda"><a id="→-elim"></a><a id="22918" href="/PLFA-zh/Connectives/#22918" class="Function">→-elim</a> <a id="22925" class="Symbol">:</a> <a id="22927" class="Symbol">∀</a> <a id="22929" class="Symbol">{</a><a id="22930" href="plfa.part1.Connectives.html#22930" class="Bound">A</a> <a id="22932" href="plfa.part1.Connectives.html#22932" class="Bound">B</a> <a id="22934" class="Symbol">:</a> <a id="22936" class="PrimitiveType">Set</a><a id="22939" class="Symbol">}</a>
  <a id="22943" class="Symbol">→</a> <a id="22945" class="Symbol">(</a><a id="22946" href="/PLFA-zh/Connectives/#22930" class="Bound">A</a> <a id="22948" class="Symbol">→</a> <a id="22950" href="plfa.part1.Connectives.html#22932" class="Bound">B</a><a id="22951" class="Symbol">)</a>
  <a id="22955" class="Symbol">→</a> <a id="22957" href="/PLFA-zh/Connectives/#22930" class="Bound">A</a>
    <a id="22963" class="Comment">-------</a>
  <a id="22973" class="Symbol">→</a> <a id="22975" href="/PLFA-zh/Connectives/#22932" class="Bound">B</a>
<a id="22977" href="/PLFA-zh/Connectives/#22918" class="Function">→-elim</a> <a id="22984" href="plfa.part1.Connectives.html#22984" class="Bound">L</a> <a id="22986" href="plfa.part1.Connectives.html#22986" class="Bound">M</a> <a id="22988" class="Symbol">=</a> <a id="22990" href="plfa.part1.Connectives.html#22984" class="Bound">L</a> <a id="22992" href="plfa.part1.Connectives.html#22986" class="Bound">M</a>
</pre>
<!-- In medieval times, this rule was known by the name _modus ponens_.
It corresponds to function application. -->

<p>在中世纪，这条规则被叫做 <em>modus ponens</em>，它与函数应用相对应。</p>

<!-- Defining a function, with a named definition or a lambda abstraction,
is referred to as _introducing_ a function,
while applying a function is referred to as _eliminating_ the function. -->

<p>定义一个函数，不管是带名字的定义或是使用 Lambda 抽象，被称为<em>引入</em>一个函数，使用一个函数被称为<em>消去</em>一个函数。</p>

<!-- Elimination followed by introduction is the identity: -->

<p>引入后接着消去，得到的还是原来的值：</p>

<pre class="Agda"><a id="η-→"></a><a id="23528" href="/PLFA-zh/Connectives/#23528" class="Function">η-→</a> <a id="23532" class="Symbol">:</a> <a id="23534" class="Symbol">∀</a> <a id="23536" class="Symbol">{</a><a id="23537" href="plfa.part1.Connectives.html#23537" class="Bound">A</a> <a id="23539" href="plfa.part1.Connectives.html#23539" class="Bound">B</a> <a id="23541" class="Symbol">:</a> <a id="23543" class="PrimitiveType">Set</a><a id="23546" class="Symbol">}</a> <a id="23548" class="Symbol">(</a><a id="23549" href="plfa.part1.Connectives.html#23549" class="Bound">f</a> <a id="23551" class="Symbol">:</a> <a id="23553" href="plfa.part1.Connectives.html#23537" class="Bound">A</a> <a id="23555" class="Symbol">→</a> <a id="23557" href="plfa.part1.Connectives.html#23539" class="Bound">B</a><a id="23558" class="Symbol">)</a> <a id="23560" class="Symbol">→</a> <a id="23562" class="Symbol">(λ</a> <a id="23565" class="Symbol">(</a><a id="23566" href="plfa.part1.Connectives.html#23566" class="Bound">x</a> <a id="23568" class="Symbol">:</a> <a id="23570" href="plfa.part1.Connectives.html#23537" class="Bound">A</a><a id="23571" class="Symbol">)</a> <a id="23573" class="Symbol">→</a> <a id="23575" href="plfa.part1.Connectives.html#23549" class="Bound">f</a> <a id="23577" href="plfa.part1.Connectives.html#23566" class="Bound">x</a><a id="23578" class="Symbol">)</a> <a id="23580" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="23582" href="plfa.part1.Connectives.html#23549" class="Bound">f</a>
<a id="23584" href="/PLFA-zh/Connectives/#23528" class="Function">η-→</a> <a id="23588" href="plfa.part1.Connectives.html#23588" class="Bound">f</a> <a id="23590" class="Symbol">=</a> <a id="23592" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre>
<!-- Implication binds less tightly than any other operator. Thus, `A ⊎ B →
B ⊎ A` parses as `(A ⊎ B) → (B ⊎ A)`. -->

<p>蕴涵比其他的运算符结合得都不紧密。因此 <code class="language-plaintext highlighter-rouge">A ⊎ B → B ⊎ A</code> 被解析为 <code class="language-plaintext highlighter-rouge">(A ⊎ B) → (B ⊎ A)</code>。</p>

<!-- Given two types `A` and `B`, we refer to `A → B` as the _function_
space from `A` to `B`.  It is also sometimes called the _exponential_,
with `B` raised to the `A` power.  Among other reasons for calling
it the exponential, note that if type `A` has `m` distinct
members, and type `B` has `n` distinct members, then the type
`A → B` has `nᵐ` distinct members.  For instance, consider a
type `Bool` with two members and a type `Tri` with three members,
as defined earlier. Then the type `Bool → Tri` has nine (that is,
three squared) members: -->

<p>给定两个类型 <code class="language-plaintext highlighter-rouge">A</code> 和 <code class="language-plaintext highlighter-rouge">B</code>，我们将 <code class="language-plaintext highlighter-rouge">A → B</code> 称为从 <code class="language-plaintext highlighter-rouge">A</code> 到 <code class="language-plaintext highlighter-rouge">B</code> 的<em>函数</em>空间。它有时也被称作以 <code class="language-plaintext highlighter-rouge">B</code> 为底，<code class="language-plaintext highlighter-rouge">A</code> 为次数的<em>幂</em>。如果类型 <code class="language-plaintext highlighter-rouge">A</code> 有 <code class="language-plaintext highlighter-rouge">m</code> 个不同的成员，类型 <code class="language-plaintext highlighter-rouge">B</code> 有 <code class="language-plaintext highlighter-rouge">n</code> 个不同的成员，那么类型 <code class="language-plaintext highlighter-rouge">A → B</code> 有 <code class="language-plaintext highlighter-rouge">nᵐ</code> 个不同的成员。这也是它被称为幂的原因之一。例如，考虑有两个成员的 <code class="language-plaintext highlighter-rouge">Bool</code> 类型，和有三个成员的 <code class="language-plaintext highlighter-rouge">Tri</code> 类型，如之前的定义。那么，<code class="language-plaintext highlighter-rouge">Bool → Tri</code> 类型有如下的九个成员（三的平方）：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>λ{true → aa; false → aa}  λ{true → aa; false → bb}  λ{true → aa; false → cc}
λ{true → bb; false → aa}  λ{true → bb; false → bb}  λ{true → bb; false → cc}
λ{true → cc; false → aa}  λ{true → cc; false → bb}  λ{true → cc; false → cc}
</code></pre></div></div>

<!-- For example, the following function enumerates all possible
arguments of the type `Bool → Tri`: -->

<p>下面的函数枚举了所有类型为 <code class="language-plaintext highlighter-rouge">Bool → Tri</code> 的参数：</p>

<pre class="Agda"><a id="→-count"></a><a id="24995" href="/PLFA-zh/Connectives/#24995" class="Function">→-count</a> <a id="25003" class="Symbol">:</a> <a id="25005" class="Symbol">(</a><a id="25006" href="plfa.part1.Connectives.html#6349" class="Datatype">Bool</a> <a id="25011" class="Symbol">→</a> <a id="25013" href="plfa.part1.Connectives.html#6402" class="Datatype">Tri</a><a id="25016" class="Symbol">)</a> <a id="25018" class="Symbol">→</a> <a id="25020" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="25022" href="/PLFA-zh/Connectives/#24995" class="Function">→-count</a> <a id="25030" href="plfa.part1.Connectives.html#25030" class="Bound">f</a> <a id="25032" class="Keyword">with</a> <a id="25037" href="plfa.part1.Connectives.html#25030" class="Bound">f</a> <a id="25039" href="plfa.part1.Connectives.html#6368" class="InductiveConstructor">true</a> <a id="25044" class="Symbol">|</a> <a id="25046" href="plfa.part1.Connectives.html#25030" class="Bound">f</a> <a id="25048" href="plfa.part1.Connectives.html#6383" class="InductiveConstructor">false</a>
<a id="25054" class="Symbol">...</a>          <a id="25067" class="Symbol">|</a> <a id="25069" href="/PLFA-zh/Connectives/#6420" class="InductiveConstructor">aa</a>     <a id="25076" class="Symbol">|</a> <a id="25078" href="plfa.part1.Connectives.html#6420" class="InductiveConstructor">aa</a>      <a id="25086" class="Symbol">=</a>   <a id="25090" class="Number">1</a>
<a id="25092" class="Symbol">...</a>          <a id="25105" class="Symbol">|</a> <a id="25107" href="/PLFA-zh/Connectives/#6420" class="InductiveConstructor">aa</a>     <a id="25114" class="Symbol">|</a> <a id="25116" href="plfa.part1.Connectives.html#6431" class="InductiveConstructor">bb</a>      <a id="25124" class="Symbol">=</a>   <a id="25128" class="Number">2</a>
<a id="25130" class="Symbol">...</a>          <a id="25143" class="Symbol">|</a> <a id="25145" href="/PLFA-zh/Connectives/#6420" class="InductiveConstructor">aa</a>     <a id="25152" class="Symbol">|</a> <a id="25154" href="plfa.part1.Connectives.html#6442" class="InductiveConstructor">cc</a>      <a id="25162" class="Symbol">=</a>   <a id="25166" class="Number">3</a>
<a id="25168" class="Symbol">...</a>          <a id="25181" class="Symbol">|</a> <a id="25183" href="/PLFA-zh/Connectives/#6431" class="InductiveConstructor">bb</a>     <a id="25190" class="Symbol">|</a> <a id="25192" href="plfa.part1.Connectives.html#6420" class="InductiveConstructor">aa</a>      <a id="25200" class="Symbol">=</a>   <a id="25204" class="Number">4</a>
<a id="25206" class="Symbol">...</a>          <a id="25219" class="Symbol">|</a> <a id="25221" href="/PLFA-zh/Connectives/#6431" class="InductiveConstructor">bb</a>     <a id="25228" class="Symbol">|</a> <a id="25230" href="plfa.part1.Connectives.html#6431" class="InductiveConstructor">bb</a>      <a id="25238" class="Symbol">=</a>   <a id="25242" class="Number">5</a>
<a id="25244" class="Symbol">...</a>          <a id="25257" class="Symbol">|</a> <a id="25259" href="/PLFA-zh/Connectives/#6431" class="InductiveConstructor">bb</a>     <a id="25266" class="Symbol">|</a> <a id="25268" href="plfa.part1.Connectives.html#6442" class="InductiveConstructor">cc</a>      <a id="25276" class="Symbol">=</a>   <a id="25280" class="Number">6</a>
<a id="25282" class="Symbol">...</a>          <a id="25295" class="Symbol">|</a> <a id="25297" href="/PLFA-zh/Connectives/#6442" class="InductiveConstructor">cc</a>     <a id="25304" class="Symbol">|</a> <a id="25306" href="plfa.part1.Connectives.html#6420" class="InductiveConstructor">aa</a>      <a id="25314" class="Symbol">=</a>   <a id="25318" class="Number">7</a>
<a id="25320" class="Symbol">...</a>          <a id="25333" class="Symbol">|</a> <a id="25335" href="/PLFA-zh/Connectives/#6442" class="InductiveConstructor">cc</a>     <a id="25342" class="Symbol">|</a> <a id="25344" href="plfa.part1.Connectives.html#6431" class="InductiveConstructor">bb</a>      <a id="25352" class="Symbol">=</a>   <a id="25356" class="Number">8</a>
<a id="25358" class="Symbol">...</a>          <a id="25371" class="Symbol">|</a> <a id="25373" href="/PLFA-zh/Connectives/#6442" class="InductiveConstructor">cc</a>     <a id="25380" class="Symbol">|</a> <a id="25382" href="plfa.part1.Connectives.html#6442" class="InductiveConstructor">cc</a>      <a id="25390" class="Symbol">=</a>   <a id="25394" class="Number">9</a>
</pre>
<!-- Exponential on types also share a property with exponential on
numbers in that many of the standard identities for numbers carry
over to the types. -->

<p>类型上的幂与数的幂有相似的性质，很多数上成立的关系式也可以在类型上成立。</p>

<!-- Corresponding to the law -->

<p>对应如下的定律：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(p ^ n) ^ m  ≡  p ^ (n * m)
</code></pre></div></div>

<!-- we have the isomorphism -->

<p>我们有如下的同构：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A → (B → C)  ≃  (A × B) → C
</code></pre></div></div>

<!-- Both types can be viewed as functions that given evidence that `A` holds
and evidence that `B` holds can return evidence that `C` holds.
This isomorphism sometimes goes by the name *currying*.
The proof of the right inverse requires extensionality: -->

<p>两个类型可以被看作给定 <code class="language-plaintext highlighter-rouge">A</code> 成立的证据和 <code class="language-plaintext highlighter-rouge">B</code> 成立的证据，返回 <code class="language-plaintext highlighter-rouge">C</code> 成立的证据。这个同构有时也被称作<em>柯里化</em>（Currying）。右逆的证明需要外延性：</p>

<pre class="Agda"><a id="currying"></a><a id="26134" href="/PLFA-zh/Connectives/#26134" class="Function">currying</a> <a id="26143" class="Symbol">:</a> <a id="26145" class="Symbol">∀</a> <a id="26147" class="Symbol">{</a><a id="26148" href="plfa.part1.Connectives.html#26148" class="Bound">A</a> <a id="26150" href="plfa.part1.Connectives.html#26150" class="Bound">B</a> <a id="26152" href="plfa.part1.Connectives.html#26152" class="Bound">C</a> <a id="26154" class="Symbol">:</a> <a id="26156" class="PrimitiveType">Set</a><a id="26159" class="Symbol">}</a> <a id="26161" class="Symbol">→</a> <a id="26163" class="Symbol">(</a><a id="26164" href="plfa.part1.Connectives.html#26148" class="Bound">A</a> <a id="26166" class="Symbol">→</a> <a id="26168" href="plfa.part1.Connectives.html#26150" class="Bound">B</a> <a id="26170" class="Symbol">→</a> <a id="26172" href="plfa.part1.Connectives.html#26152" class="Bound">C</a><a id="26173" class="Symbol">)</a> <a id="26175" href="/PLFA-zh/Isomorphism/#5849" class="Record Operator">≃</a> <a id="26177" class="Symbol">(</a><a id="26178" href="plfa.part1.Connectives.html#26148" class="Bound">A</a> <a id="26180" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="26182" href="plfa.part1.Connectives.html#26150" class="Bound">B</a> <a id="26184" class="Symbol">→</a> <a id="26186" href="plfa.part1.Connectives.html#26152" class="Bound">C</a><a id="26187" class="Symbol">)</a>
<a id="26189" href="/PLFA-zh/Connectives/#26134" class="Function">currying</a> <a id="26198" class="Symbol">=</a>
  <a id="26202" class="Keyword">record</a>
    <a id="26213" class="Symbol">{</a> <a id="26215" href="/PLFA-zh/Isomorphism/#5889" class="Field">to</a>      <a id="26223" class="Symbol">=</a>  <a id="26226" class="Symbol">λ{</a> <a id="26229" href="/PLFA-zh/Connectives/#26229" class="Bound">f</a> <a id="26231" class="Symbol">→</a> <a id="26233" class="Symbol">λ{</a> <a id="26236" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="26238" href="plfa.part1.Connectives.html#26238" class="Bound">x</a> <a id="26240" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="26242" href="plfa.part1.Connectives.html#26242" class="Bound">y</a> <a id="26244" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="26246" class="Symbol">→</a> <a id="26248" href="plfa.part1.Connectives.html#26229" class="Bound">f</a> <a id="26250" href="plfa.part1.Connectives.html#26238" class="Bound">x</a> <a id="26252" href="plfa.part1.Connectives.html#26242" class="Bound">y</a> <a id="26254" class="Symbol">}}</a>
    <a id="26261" class="Symbol">;</a> <a id="26263" href="/PLFA-zh/Isomorphism/#5906" class="Field">from</a>    <a id="26271" class="Symbol">=</a>  <a id="26274" class="Symbol">λ{</a> <a id="26277" href="/PLFA-zh/Connectives/#26277" class="Bound">g</a> <a id="26279" class="Symbol">→</a> <a id="26281" class="Symbol">λ{</a> <a id="26284" href="plfa.part1.Connectives.html#26284" class="Bound">x</a> <a id="26286" class="Symbol">→</a> <a id="26288" class="Symbol">λ{</a> <a id="26291" href="plfa.part1.Connectives.html#26291" class="Bound">y</a> <a id="26293" class="Symbol">→</a> <a id="26295" href="plfa.part1.Connectives.html#26277" class="Bound">g</a> <a id="26297" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="26299" href="plfa.part1.Connectives.html#26284" class="Bound">x</a> <a id="26301" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="26303" href="plfa.part1.Connectives.html#26291" class="Bound">y</a> <a id="26305" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="26307" class="Symbol">}}}</a>
    <a id="26315" class="Symbol">;</a> <a id="26317" href="/PLFA-zh/Isomorphism/#5923" class="Field">from∘to</a> <a id="26325" class="Symbol">=</a>  <a id="26328" class="Symbol">λ{</a> <a id="26331" href="/PLFA-zh/Connectives/#26331" class="Bound">f</a> <a id="26333" class="Symbol">→</a> <a id="26335" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="26340" class="Symbol">}</a>
    <a id="26346" class="Symbol">;</a> <a id="26348" href="/PLFA-zh/Isomorphism/#5965" class="Field">to∘from</a> <a id="26356" class="Symbol">=</a>  <a id="26359" class="Symbol">λ{</a> <a id="26362" href="/PLFA-zh/Connectives/#26362" class="Bound">g</a> <a id="26364" class="Symbol">→</a> <a id="26366" href="plfa.part1.Isomorphism.html#3764" class="Postulate">extensionality</a> <a id="26381" class="Symbol">λ{</a> <a id="26384" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="26386" href="plfa.part1.Connectives.html#26386" class="Bound">x</a> <a id="26388" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="26390" href="plfa.part1.Connectives.html#26390" class="Bound">y</a> <a id="26392" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="26394" class="Symbol">→</a> <a id="26396" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="26401" class="Symbol">}}</a>
    <a id="26408" class="Symbol">}</a>
</pre>
<!-- Currying tells us that instead of a function that takes a pair of arguments,
we can have a function that takes the first argument and returns a function that
expects the second argument.  Thus, for instance, our way of writing addition -->

<p>柯里化告诉我们，如果一个函数有取一个数据对作为参数，那么我们可以构造一个函数，取第一个参数，返回一个取第二个参数，返回最终结果的函数。因此，举例来说，下面表示加法的形式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_+_ : ℕ → ℕ → ℕ
</code></pre></div></div>

<!-- is isomorphic to a function that accepts a pair of arguments: -->

<p>和下面的一个带有一个数据对作为参数的函数是同构的：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_+′_ : (ℕ × ℕ) → ℕ
</code></pre></div></div>

<!-- Agda is optimised for currying, so `2 + 3` abbreviates `_+_ 2 3`.
In a language optimised for pairing, we would instead take `2 +′ 3` as
an abbreviation for `_+′_ ⟨ 2 , 3 ⟩`. -->

<p>Agda 对柯里化进行了优化，因此 <code class="language-plaintext highlighter-rouge">2 + 3</code> 是 <code class="language-plaintext highlighter-rouge">_+_ 2 3</code> 的简写。在一个对有序对进行优化的语言里，
<code class="language-plaintext highlighter-rouge">2 +′ 3</code> 可能是 <code class="language-plaintext highlighter-rouge">_+′_ ⟨ 2 , 3 ⟩</code> 的简写。</p>

<!-- Corresponding to the law -->

<p>对应如下的定律：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p ^ (n + m) = (p ^ n) * (p ^ m)
</code></pre></div></div>

<!-- we have the isomorphism: -->

<p>我们有如下的同构：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(A ⊎ B) → C  ≃  (A → C) × (B → C)
</code></pre></div></div>

<!-- That is, the assertion that if either `A` holds or `B` holds then `C` holds
is the same as the assertion that if `A` holds then `C` holds and if
`B` holds then `C` holds.  The proof of the left inverse requires extensionality: -->

<p>命题如果 <code class="language-plaintext highlighter-rouge">A</code> 成立或者 <code class="language-plaintext highlighter-rouge">B</code> 成立，那么 <code class="language-plaintext highlighter-rouge">C</code> 成立，和命题如果 <code class="language-plaintext highlighter-rouge">A</code> 成立，那么 <code class="language-plaintext highlighter-rouge">C</code> 成立以及如果 <code class="language-plaintext highlighter-rouge">B</code> 成立，那么 <code class="language-plaintext highlighter-rouge">C</code> 成立，是一样的。左逆的证明需要外延性：</p>

<pre class="Agda"><a id="→-distrib-⊎"></a><a id="27724" href="/PLFA-zh/Connectives/#27724" class="Function">→-distrib-⊎</a> <a id="27736" class="Symbol">:</a> <a id="27738" class="Symbol">∀</a> <a id="27740" class="Symbol">{</a><a id="27741" href="plfa.part1.Connectives.html#27741" class="Bound">A</a> <a id="27743" href="plfa.part1.Connectives.html#27743" class="Bound">B</a> <a id="27745" href="plfa.part1.Connectives.html#27745" class="Bound">C</a> <a id="27747" class="Symbol">:</a> <a id="27749" class="PrimitiveType">Set</a><a id="27752" class="Symbol">}</a> <a id="27754" class="Symbol">→</a> <a id="27756" class="Symbol">(</a><a id="27757" href="plfa.part1.Connectives.html#27741" class="Bound">A</a> <a id="27759" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="27761" href="plfa.part1.Connectives.html#27743" class="Bound">B</a> <a id="27763" class="Symbol">→</a> <a id="27765" href="plfa.part1.Connectives.html#27745" class="Bound">C</a><a id="27766" class="Symbol">)</a> <a id="27768" href="/PLFA-zh/Isomorphism/#5849" class="Record Operator">≃</a> <a id="27770" class="Symbol">((</a><a id="27772" href="plfa.part1.Connectives.html#27741" class="Bound">A</a> <a id="27774" class="Symbol">→</a> <a id="27776" href="plfa.part1.Connectives.html#27745" class="Bound">C</a><a id="27777" class="Symbol">)</a> <a id="27779" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="27781" class="Symbol">(</a><a id="27782" href="plfa.part1.Connectives.html#27743" class="Bound">B</a> <a id="27784" class="Symbol">→</a> <a id="27786" href="plfa.part1.Connectives.html#27745" class="Bound">C</a><a id="27787" class="Symbol">))</a>
<a id="27790" href="/PLFA-zh/Connectives/#27724" class="Function">→-distrib-⊎</a> <a id="27802" class="Symbol">=</a>
  <a id="27806" class="Keyword">record</a>
    <a id="27817" class="Symbol">{</a> <a id="27819" href="/PLFA-zh/Isomorphism/#5889" class="Field">to</a>      <a id="27827" class="Symbol">=</a> <a id="27829" class="Symbol">λ{</a> <a id="27832" href="/PLFA-zh/Connectives/#27832" class="Bound">f</a> <a id="27834" class="Symbol">→</a> <a id="27836" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="27838" href="plfa.part1.Connectives.html#27832" class="Bound">f</a> <a id="27840" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="27842" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="27847" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="27849" href="plfa.part1.Connectives.html#27832" class="Bound">f</a> <a id="27851" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="27853" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="27858" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="27860" class="Symbol">}</a>
    <a id="27866" class="Symbol">;</a> <a id="27868" href="/PLFA-zh/Isomorphism/#5906" class="Field">from</a>    <a id="27876" class="Symbol">=</a> <a id="27878" class="Symbol">λ{</a> <a id="27881" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="27883" href="plfa.part1.Connectives.html#27883" class="Bound">g</a> <a id="27885" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="27887" href="plfa.part1.Connectives.html#27887" class="Bound">h</a> <a id="27889" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="27891" class="Symbol">→</a> <a id="27893" class="Symbol">λ{</a> <a id="27896" class="Symbol">(</a><a id="27897" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="27902" href="plfa.part1.Connectives.html#27902" class="Bound">x</a><a id="27903" class="Symbol">)</a> <a id="27905" class="Symbol">→</a> <a id="27907" href="plfa.part1.Connectives.html#27883" class="Bound">g</a> <a id="27909" href="plfa.part1.Connectives.html#27902" class="Bound">x</a> <a id="27911" class="Symbol">;</a> <a id="27913" class="Symbol">(</a><a id="27914" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="27919" href="plfa.part1.Connectives.html#27919" class="Bound">y</a><a id="27920" class="Symbol">)</a> <a id="27922" class="Symbol">→</a> <a id="27924" href="plfa.part1.Connectives.html#27887" class="Bound">h</a> <a id="27926" href="plfa.part1.Connectives.html#27919" class="Bound">y</a> <a id="27928" class="Symbol">}</a> <a id="27930" class="Symbol">}</a>
    <a id="27936" class="Symbol">;</a> <a id="27938" href="/PLFA-zh/Isomorphism/#5923" class="Field">from∘to</a> <a id="27946" class="Symbol">=</a> <a id="27948" class="Symbol">λ{</a> <a id="27951" href="/PLFA-zh/Connectives/#27951" class="Bound">f</a> <a id="27953" class="Symbol">→</a> <a id="27955" href="plfa.part1.Isomorphism.html#3764" class="Postulate">extensionality</a> <a id="27970" class="Symbol">λ{</a> <a id="27973" class="Symbol">(</a><a id="27974" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="27979" href="plfa.part1.Connectives.html#27979" class="Bound">x</a><a id="27980" class="Symbol">)</a> <a id="27982" class="Symbol">→</a> <a id="27984" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="27989" class="Symbol">;</a> <a id="27991" class="Symbol">(</a><a id="27992" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="27997" href="plfa.part1.Connectives.html#27997" class="Bound">y</a><a id="27998" class="Symbol">)</a> <a id="28000" class="Symbol">→</a> <a id="28002" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="28007" class="Symbol">}</a> <a id="28009" class="Symbol">}</a>
    <a id="28015" class="Symbol">;</a> <a id="28017" href="/PLFA-zh/Isomorphism/#5965" class="Field">to∘from</a> <a id="28025" class="Symbol">=</a> <a id="28027" class="Symbol">λ{</a> <a id="28030" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="28032" href="plfa.part1.Connectives.html#28032" class="Bound">g</a> <a id="28034" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="28036" href="plfa.part1.Connectives.html#28036" class="Bound">h</a> <a id="28038" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="28040" class="Symbol">→</a> <a id="28042" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="28047" class="Symbol">}</a>
    <a id="28053" class="Symbol">}</a>
</pre>
<!-- Corresponding to the law -->

<p>对应如下的定律：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(p * n) ^ m = (p ^ m) * (n ^ m)
</code></pre></div></div>

<!-- we have the isomorphism: -->

<p>我们有如下的同构：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A → B × C  ≃  (A → B) × (A → C)
</code></pre></div></div>

<!-- That is, the assertion that if `A` holds then `B` holds and `C` holds
is the same as the assertion that if `A` holds then `B` holds and if
`A` holds then `C` holds.  The proof of left inverse requires both extensionality
and the rule `η-×` for products: -->

<p>命题如果 <code class="language-plaintext highlighter-rouge">A</code> 成立，那么 <code class="language-plaintext highlighter-rouge">B</code> 成立和 <code class="language-plaintext highlighter-rouge">C</code> 成立，和命题如果 <code class="language-plaintext highlighter-rouge">A</code> 成立，那么 <code class="language-plaintext highlighter-rouge">B</code> 成立以及如果 <code class="language-plaintext highlighter-rouge">A</code> 成立，那么 <code class="language-plaintext highlighter-rouge">C</code> 成立，是一样的。左逆的证明需要外延性和积的 <code class="language-plaintext highlighter-rouge">η-×</code> 规则：</p>

<pre class="Agda"><a id="→-distrib-×"></a><a id="28622" href="/PLFA-zh/Connectives/#28622" class="Function">→-distrib-×</a> <a id="28634" class="Symbol">:</a> <a id="28636" class="Symbol">∀</a> <a id="28638" class="Symbol">{</a><a id="28639" href="plfa.part1.Connectives.html#28639" class="Bound">A</a> <a id="28641" href="plfa.part1.Connectives.html#28641" class="Bound">B</a> <a id="28643" href="plfa.part1.Connectives.html#28643" class="Bound">C</a> <a id="28645" class="Symbol">:</a> <a id="28647" class="PrimitiveType">Set</a><a id="28650" class="Symbol">}</a> <a id="28652" class="Symbol">→</a> <a id="28654" class="Symbol">(</a><a id="28655" href="plfa.part1.Connectives.html#28639" class="Bound">A</a> <a id="28657" class="Symbol">→</a> <a id="28659" href="plfa.part1.Connectives.html#28641" class="Bound">B</a> <a id="28661" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="28663" href="plfa.part1.Connectives.html#28643" class="Bound">C</a><a id="28664" class="Symbol">)</a> <a id="28666" href="/PLFA-zh/Isomorphism/#5849" class="Record Operator">≃</a> <a id="28668" class="Symbol">(</a><a id="28669" href="plfa.part1.Connectives.html#28639" class="Bound">A</a> <a id="28671" class="Symbol">→</a> <a id="28673" href="plfa.part1.Connectives.html#28641" class="Bound">B</a><a id="28674" class="Symbol">)</a> <a id="28676" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="28678" class="Symbol">(</a><a id="28679" href="plfa.part1.Connectives.html#28639" class="Bound">A</a> <a id="28681" class="Symbol">→</a> <a id="28683" href="plfa.part1.Connectives.html#28643" class="Bound">C</a><a id="28684" class="Symbol">)</a>
<a id="28686" href="/PLFA-zh/Connectives/#28622" class="Function">→-distrib-×</a> <a id="28698" class="Symbol">=</a>
  <a id="28702" class="Keyword">record</a>
    <a id="28713" class="Symbol">{</a> <a id="28715" href="/PLFA-zh/Isomorphism/#5889" class="Field">to</a>      <a id="28723" class="Symbol">=</a> <a id="28725" class="Symbol">λ{</a> <a id="28728" href="/PLFA-zh/Connectives/#28728" class="Bound">f</a> <a id="28730" class="Symbol">→</a> <a id="28732" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="28734" href="plfa.part1.Connectives.html#2203" class="Function">proj₁</a> <a id="28740" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="28742" href="plfa.part1.Connectives.html#28728" class="Bound">f</a> <a id="28744" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="28746" href="plfa.part1.Connectives.html#2272" class="Function">proj₂</a> <a id="28752" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="28754" href="plfa.part1.Connectives.html#28728" class="Bound">f</a> <a id="28756" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="28758" class="Symbol">}</a>
    <a id="28764" class="Symbol">;</a> <a id="28766" href="/PLFA-zh/Isomorphism/#5906" class="Field">from</a>    <a id="28774" class="Symbol">=</a> <a id="28776" class="Symbol">λ{</a> <a id="28779" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="28781" href="plfa.part1.Connectives.html#28781" class="Bound">g</a> <a id="28783" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="28785" href="plfa.part1.Connectives.html#28785" class="Bound">h</a> <a id="28787" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="28789" class="Symbol">→</a> <a id="28791" class="Symbol">λ</a> <a id="28793" href="plfa.part1.Connectives.html#28793" class="Bound">x</a> <a id="28795" class="Symbol">→</a> <a id="28797" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="28799" href="plfa.part1.Connectives.html#28781" class="Bound">g</a> <a id="28801" href="plfa.part1.Connectives.html#28793" class="Bound">x</a> <a id="28803" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="28805" href="plfa.part1.Connectives.html#28785" class="Bound">h</a> <a id="28807" href="plfa.part1.Connectives.html#28793" class="Bound">x</a> <a id="28809" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="28811" class="Symbol">}</a>
    <a id="28817" class="Symbol">;</a> <a id="28819" href="/PLFA-zh/Isomorphism/#5923" class="Field">from∘to</a> <a id="28827" class="Symbol">=</a> <a id="28829" class="Symbol">λ{</a> <a id="28832" href="/PLFA-zh/Connectives/#28832" class="Bound">f</a> <a id="28834" class="Symbol">→</a> <a id="28836" href="plfa.part1.Isomorphism.html#3764" class="Postulate">extensionality</a> <a id="28851" class="Symbol">λ{</a> <a id="28854" href="plfa.part1.Connectives.html#28854" class="Bound">x</a> <a id="28856" class="Symbol">→</a> <a id="28858" href="plfa.part1.Connectives.html#4997" class="Function">η-×</a> <a id="28862" class="Symbol">(</a><a id="28863" href="plfa.part1.Connectives.html#28832" class="Bound">f</a> <a id="28865" href="plfa.part1.Connectives.html#28854" class="Bound">x</a><a id="28866" class="Symbol">)</a> <a id="28868" class="Symbol">}</a> <a id="28870" class="Symbol">}</a>
    <a id="28876" class="Symbol">;</a> <a id="28878" href="/PLFA-zh/Isomorphism/#5965" class="Field">to∘from</a> <a id="28886" class="Symbol">=</a> <a id="28888" class="Symbol">λ{</a> <a id="28891" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="28893" href="plfa.part1.Connectives.html#28893" class="Bound">g</a> <a id="28895" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="28897" href="plfa.part1.Connectives.html#28897" class="Bound">h</a> <a id="28899" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="28901" class="Symbol">→</a> <a id="28903" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="28908" class="Symbol">}</a>
    <a id="28914" class="Symbol">}</a>
</pre>

<!-- ## Distribution -->

<h2 id="分配律">分配律</h2>

<!-- Products distribute over sum, up to isomorphism.  The code to validate
this fact is similar in structure to our previous results: -->

<p>在同构意义下，积对于和满足分配律。验证这条形式的代码和之前的证明相似：</p>

<pre class="Agda"><a id="×-distrib-⊎"></a><a id="29153" href="/PLFA-zh/Connectives/#29153" class="Function">×-distrib-⊎</a> <a id="29165" class="Symbol">:</a> <a id="29167" class="Symbol">∀</a> <a id="29169" class="Symbol">{</a><a id="29170" href="plfa.part1.Connectives.html#29170" class="Bound">A</a> <a id="29172" href="plfa.part1.Connectives.html#29172" class="Bound">B</a> <a id="29174" href="plfa.part1.Connectives.html#29174" class="Bound">C</a> <a id="29176" class="Symbol">:</a> <a id="29178" class="PrimitiveType">Set</a><a id="29181" class="Symbol">}</a> <a id="29183" class="Symbol">→</a> <a id="29185" class="Symbol">(</a><a id="29186" href="plfa.part1.Connectives.html#29170" class="Bound">A</a> <a id="29188" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="29190" href="plfa.part1.Connectives.html#29172" class="Bound">B</a><a id="29191" class="Symbol">)</a> <a id="29193" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="29195" href="plfa.part1.Connectives.html#29174" class="Bound">C</a> <a id="29197" href="/PLFA-zh/Isomorphism/#5849" class="Record Operator">≃</a> <a id="29199" class="Symbol">(</a><a id="29200" href="plfa.part1.Connectives.html#29170" class="Bound">A</a> <a id="29202" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="29204" href="plfa.part1.Connectives.html#29174" class="Bound">C</a><a id="29205" class="Symbol">)</a> <a id="29207" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="29209" class="Symbol">(</a><a id="29210" href="plfa.part1.Connectives.html#29172" class="Bound">B</a> <a id="29212" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="29214" href="plfa.part1.Connectives.html#29174" class="Bound">C</a><a id="29215" class="Symbol">)</a>
<a id="29217" href="/PLFA-zh/Connectives/#29153" class="Function">×-distrib-⊎</a> <a id="29229" class="Symbol">=</a>
  <a id="29233" class="Keyword">record</a>
    <a id="29244" class="Symbol">{</a> <a id="29246" href="/PLFA-zh/Isomorphism/#5889" class="Field">to</a>      <a id="29254" class="Symbol">=</a> <a id="29256" class="Symbol">λ{</a> <a id="29259" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="29261" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="29266" href="plfa.part1.Connectives.html#29266" class="Bound">x</a> <a id="29268" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="29270" href="plfa.part1.Connectives.html#29270" class="Bound">z</a> <a id="29272" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="29274" class="Symbol">→</a> <a id="29276" class="Symbol">(</a><a id="29277" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="29282" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="29284" href="plfa.part1.Connectives.html#29266" class="Bound">x</a> <a id="29286" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="29288" href="plfa.part1.Connectives.html#29270" class="Bound">z</a> <a id="29290" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a><a id="29291" class="Symbol">)</a>
                 <a id="29310" class="Symbol">;</a> <a id="29312" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="29314" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="29319" href="plfa.part1.Connectives.html#29319" class="Bound">y</a> <a id="29321" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="29323" href="plfa.part1.Connectives.html#29323" class="Bound">z</a> <a id="29325" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="29327" class="Symbol">→</a> <a id="29329" class="Symbol">(</a><a id="29330" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="29335" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="29337" href="plfa.part1.Connectives.html#29319" class="Bound">y</a> <a id="29339" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="29341" href="plfa.part1.Connectives.html#29323" class="Bound">z</a> <a id="29343" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a><a id="29344" class="Symbol">)</a>
                 <a id="29363" class="Symbol">}</a>
    <a id="29369" class="Symbol">;</a> <a id="29371" href="/PLFA-zh/Isomorphism/#5906" class="Field">from</a>    <a id="29379" class="Symbol">=</a> <a id="29381" class="Symbol">λ{</a> <a id="29384" class="Symbol">(</a><a id="29385" href="/PLFA-zh/Connectives/#14099" class="InductiveConstructor">inj₁</a> <a id="29390" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="29392" href="plfa.part1.Connectives.html#29392" class="Bound">x</a> <a id="29394" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="29396" href="plfa.part1.Connectives.html#29396" class="Bound">z</a> <a id="29398" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a><a id="29399" class="Symbol">)</a> <a id="29401" class="Symbol">→</a> <a id="29403" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="29405" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="29410" href="plfa.part1.Connectives.html#29392" class="Bound">x</a> <a id="29412" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="29414" href="plfa.part1.Connectives.html#29396" class="Bound">z</a> <a id="29416" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a>
                 <a id="29435" class="Symbol">;</a> <a id="29437" class="Symbol">(</a><a id="29438" href="/PLFA-zh/Connectives/#14141" class="InductiveConstructor">inj₂</a> <a id="29443" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="29445" href="plfa.part1.Connectives.html#29445" class="Bound">y</a> <a id="29447" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="29449" href="plfa.part1.Connectives.html#29449" class="Bound">z</a> <a id="29451" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a><a id="29452" class="Symbol">)</a> <a id="29454" class="Symbol">→</a> <a id="29456" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="29458" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="29463" href="plfa.part1.Connectives.html#29445" class="Bound">y</a> <a id="29465" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="29467" href="plfa.part1.Connectives.html#29449" class="Bound">z</a> <a id="29469" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a>
                 <a id="29488" class="Symbol">}</a>
    <a id="29494" class="Symbol">;</a> <a id="29496" href="/PLFA-zh/Isomorphism/#5923" class="Field">from∘to</a> <a id="29504" class="Symbol">=</a> <a id="29506" class="Symbol">λ{</a> <a id="29509" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="29511" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="29516" href="plfa.part1.Connectives.html#29516" class="Bound">x</a> <a id="29518" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="29520" href="plfa.part1.Connectives.html#29520" class="Bound">z</a> <a id="29522" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="29524" class="Symbol">→</a> <a id="29526" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
                 <a id="29548" class="Symbol">;</a> <a id="29550" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="29552" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="29557" href="plfa.part1.Connectives.html#29557" class="Bound">y</a> <a id="29559" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="29561" href="plfa.part1.Connectives.html#29561" class="Bound">z</a> <a id="29563" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="29565" class="Symbol">→</a> <a id="29567" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
                 <a id="29589" class="Symbol">}</a>
    <a id="29595" class="Symbol">;</a> <a id="29597" href="/PLFA-zh/Isomorphism/#5965" class="Field">to∘from</a> <a id="29605" class="Symbol">=</a> <a id="29607" class="Symbol">λ{</a> <a id="29610" class="Symbol">(</a><a id="29611" href="/PLFA-zh/Connectives/#14099" class="InductiveConstructor">inj₁</a> <a id="29616" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="29618" href="plfa.part1.Connectives.html#29618" class="Bound">x</a> <a id="29620" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="29622" href="plfa.part1.Connectives.html#29622" class="Bound">z</a> <a id="29624" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a><a id="29625" class="Symbol">)</a> <a id="29627" class="Symbol">→</a> <a id="29629" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
                 <a id="29651" class="Symbol">;</a> <a id="29653" class="Symbol">(</a><a id="29654" href="/PLFA-zh/Connectives/#14141" class="InductiveConstructor">inj₂</a> <a id="29659" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="29661" href="plfa.part1.Connectives.html#29661" class="Bound">y</a> <a id="29663" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="29665" href="plfa.part1.Connectives.html#29665" class="Bound">z</a> <a id="29667" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a><a id="29668" class="Symbol">)</a> <a id="29670" class="Symbol">→</a> <a id="29672" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
                 <a id="29694" class="Symbol">}</a>
    <a id="29700" class="Symbol">}</a>
</pre>
<!-- Sums do not distribute over products up to isomorphism, but it is an embedding: -->

<p>和对于积不满足分配律，但满足嵌入：</p>

<pre class="Agda"><a id="⊎-distrib-×"></a><a id="29828" href="/PLFA-zh/Connectives/#29828" class="Function">⊎-distrib-×</a> <a id="29840" class="Symbol">:</a> <a id="29842" class="Symbol">∀</a> <a id="29844" class="Symbol">{</a><a id="29845" href="plfa.part1.Connectives.html#29845" class="Bound">A</a> <a id="29847" href="plfa.part1.Connectives.html#29847" class="Bound">B</a> <a id="29849" href="plfa.part1.Connectives.html#29849" class="Bound">C</a> <a id="29851" class="Symbol">:</a> <a id="29853" class="PrimitiveType">Set</a><a id="29856" class="Symbol">}</a> <a id="29858" class="Symbol">→</a> <a id="29860" class="Symbol">(</a><a id="29861" href="plfa.part1.Connectives.html#29845" class="Bound">A</a> <a id="29863" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="29865" href="plfa.part1.Connectives.html#29847" class="Bound">B</a><a id="29866" class="Symbol">)</a> <a id="29868" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="29870" href="plfa.part1.Connectives.html#29849" class="Bound">C</a> <a id="29872" href="/PLFA-zh/Isomorphism/#11925" class="Record Operator">≲</a> <a id="29874" class="Symbol">(</a><a id="29875" href="plfa.part1.Connectives.html#29845" class="Bound">A</a> <a id="29877" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="29879" href="plfa.part1.Connectives.html#29849" class="Bound">C</a><a id="29880" class="Symbol">)</a> <a id="29882" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="29884" class="Symbol">(</a><a id="29885" href="plfa.part1.Connectives.html#29847" class="Bound">B</a> <a id="29887" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="29889" href="plfa.part1.Connectives.html#29849" class="Bound">C</a><a id="29890" class="Symbol">)</a>
<a id="29892" href="/PLFA-zh/Connectives/#29828" class="Function">⊎-distrib-×</a> <a id="29904" class="Symbol">=</a>
  <a id="29908" class="Keyword">record</a>
    <a id="29919" class="Symbol">{</a> <a id="29921" href="/PLFA-zh/Isomorphism/#11965" class="Field">to</a>      <a id="29929" class="Symbol">=</a> <a id="29931" class="Symbol">λ{</a> <a id="29934" class="Symbol">(</a><a id="29935" href="/PLFA-zh/Connectives/#14099" class="InductiveConstructor">inj₁</a> <a id="29940" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="29942" href="plfa.part1.Connectives.html#29942" class="Bound">x</a> <a id="29944" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="29946" href="plfa.part1.Connectives.html#29946" class="Bound">y</a> <a id="29948" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a><a id="29949" class="Symbol">)</a> <a id="29951" class="Symbol">→</a> <a id="29953" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="29955" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="29960" href="plfa.part1.Connectives.html#29942" class="Bound">x</a> <a id="29962" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="29964" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="29969" href="plfa.part1.Connectives.html#29946" class="Bound">y</a> <a id="29971" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a>
                 <a id="29990" class="Symbol">;</a> <a id="29992" class="Symbol">(</a><a id="29993" href="/PLFA-zh/Connectives/#14141" class="InductiveConstructor">inj₂</a> <a id="29998" href="plfa.part1.Connectives.html#29998" class="Bound">z</a><a id="29999" class="Symbol">)</a>         <a id="30009" class="Symbol">→</a> <a id="30011" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="30013" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="30018" href="plfa.part1.Connectives.html#29998" class="Bound">z</a> <a id="30020" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="30022" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="30027" href="plfa.part1.Connectives.html#29998" class="Bound">z</a> <a id="30029" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a>
                 <a id="30048" class="Symbol">}</a>
    <a id="30054" class="Symbol">;</a> <a id="30056" href="/PLFA-zh/Isomorphism/#11985" class="Field">from</a>    <a id="30064" class="Symbol">=</a> <a id="30066" class="Symbol">λ{</a> <a id="30069" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="30071" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="30076" href="plfa.part1.Connectives.html#30076" class="Bound">x</a> <a id="30078" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="30080" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="30085" href="plfa.part1.Connectives.html#30085" class="Bound">y</a> <a id="30087" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="30089" class="Symbol">→</a> <a id="30091" class="Symbol">(</a><a id="30092" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="30097" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="30099" href="plfa.part1.Connectives.html#30076" class="Bound">x</a> <a id="30101" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="30103" href="plfa.part1.Connectives.html#30085" class="Bound">y</a> <a id="30105" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a><a id="30106" class="Symbol">)</a>
                 <a id="30125" class="Symbol">;</a> <a id="30127" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="30129" href="plfa.part1.Connectives.html#14099" class="InductiveConstructor">inj₁</a> <a id="30134" href="plfa.part1.Connectives.html#30134" class="Bound">x</a> <a id="30136" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="30138" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="30143" href="plfa.part1.Connectives.html#30143" class="Bound">z</a> <a id="30145" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="30147" class="Symbol">→</a> <a id="30149" class="Symbol">(</a><a id="30150" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="30155" href="plfa.part1.Connectives.html#30143" class="Bound">z</a><a id="30156" class="Symbol">)</a>
                 <a id="30175" class="Symbol">;</a> <a id="30177" href="/PLFA-zh/Connectives/#1769" class="InductiveConstructor Operator">⟨</a> <a id="30179" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="30184" href="plfa.part1.Connectives.html#30184" class="Bound">z</a> <a id="30186" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="30188" class="Symbol">_</a>      <a id="30195" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a> <a id="30197" class="Symbol">→</a> <a id="30199" class="Symbol">(</a><a id="30200" href="plfa.part1.Connectives.html#14141" class="InductiveConstructor">inj₂</a> <a id="30205" href="plfa.part1.Connectives.html#30184" class="Bound">z</a><a id="30206" class="Symbol">)</a>
                 <a id="30225" class="Symbol">}</a>
    <a id="30231" class="Symbol">;</a> <a id="30233" href="/PLFA-zh/Isomorphism/#12005" class="Field">from∘to</a> <a id="30241" class="Symbol">=</a> <a id="30243" class="Symbol">λ{</a> <a id="30246" class="Symbol">(</a><a id="30247" href="/PLFA-zh/Connectives/#14099" class="InductiveConstructor">inj₁</a> <a id="30252" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟨</a> <a id="30254" href="plfa.part1.Connectives.html#30254" class="Bound">x</a> <a id="30256" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">,</a> <a id="30258" href="plfa.part1.Connectives.html#30258" class="Bound">y</a> <a id="30260" href="plfa.part1.Connectives.html#1769" class="InductiveConstructor Operator">⟩</a><a id="30261" class="Symbol">)</a> <a id="30263" class="Symbol">→</a> <a id="30265" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
                 <a id="30287" class="Symbol">;</a> <a id="30289" class="Symbol">(</a><a id="30290" href="/PLFA-zh/Connectives/#14141" class="InductiveConstructor">inj₂</a> <a id="30295" href="plfa.part1.Connectives.html#30295" class="Bound">z</a><a id="30296" class="Symbol">)</a>         <a id="30306" class="Symbol">→</a> <a id="30308" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
                 <a id="30330" class="Symbol">}</a>
    <a id="30336" class="Symbol">}</a>
</pre>
<!-- Note that there is a choice in how we write the `from` function.
As given, it takes `⟨ inj₂ z , inj₂ z′ ⟩` to `inj₂ z`, but it is
easy to write a variant that instead returns `inj₂ z′`.  We have
an embedding rather than an isomorphism because the
`from` function must discard either `z` or `z′` in this case. -->

<p>我们在定义 <code class="language-plaintext highlighter-rouge">from</code> 函数的时候可以有选择。给定的定义中，它将 <code class="language-plaintext highlighter-rouge">⟨ inj₂ z , inj₂ z′ ⟩</code>
转换为 <code class="language-plaintext highlighter-rouge">inj₂ z</code>，但我们也可以返回 <code class="language-plaintext highlighter-rouge">inj₂ z′</code> 作为嵌入证明的变种。我们在这里只能证明嵌入，而不能证明同构，因为 <code class="language-plaintext highlighter-rouge">from</code> 函数必须丢弃 <code class="language-plaintext highlighter-rouge">z</code> 或者 <code class="language-plaintext highlighter-rouge">z′</code> 其中的一个。</p>

<!-- In the usual approach to logic, both of the distribution laws
are given as equivalences, where each side implies the other: -->

<p>在一般的逻辑学方法中，两条分配律都以等价的形式给出，每一边都蕴涵了另一边：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A × (B ⊎ C) ⇔ (A × B) ⊎ (A × C)
A ⊎ (B × C) ⇔ (A ⊎ B) × (A ⊎ C)
</code></pre></div></div>

<!-- But when we consider the functions that provide evidence for these
implications, then the first corresponds to an isomorphism while the
second only corresponds to an embedding, revealing a sense in which
one of these laws is "more true" than the other. -->

<p>但当我们考虑提供上述蕴涵证明的函数时，第一条对应同构而第二条只能对应嵌入，揭示了有些定理比另一个更加的”正确“。</p>

<!-- #### Exercise `⊎-weak-×` (recommended) -->

<h4 id="练习--weak--推荐">练习 <code class="language-plaintext highlighter-rouge">⊎-weak-×</code> （推荐）</h4>

<!-- Show that the following property holds: -->

<p>证明如下性质成立：</p>

<pre class="Agda"><a id="31567" class="Keyword">postulate</a>
  <a id="⊎-weak-×"></a><a id="31579" href="/PLFA-zh/Connectives/#31579" class="Postulate">⊎-weak-×</a> <a id="31588" class="Symbol">:</a> <a id="31590" class="Symbol">∀</a> <a id="31592" class="Symbol">{</a><a id="31593" href="plfa.part1.Connectives.html#31593" class="Bound">A</a> <a id="31595" href="plfa.part1.Connectives.html#31595" class="Bound">B</a> <a id="31597" href="plfa.part1.Connectives.html#31597" class="Bound">C</a> <a id="31599" class="Symbol">:</a> <a id="31601" class="PrimitiveType">Set</a><a id="31604" class="Symbol">}</a> <a id="31606" class="Symbol">→</a> <a id="31608" class="Symbol">(</a><a id="31609" href="plfa.part1.Connectives.html#31593" class="Bound">A</a> <a id="31611" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="31613" href="plfa.part1.Connectives.html#31595" class="Bound">B</a><a id="31614" class="Symbol">)</a> <a id="31616" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="31618" href="plfa.part1.Connectives.html#31597" class="Bound">C</a> <a id="31620" class="Symbol">→</a> <a id="31622" href="plfa.part1.Connectives.html#31593" class="Bound">A</a> <a id="31624" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="31626" class="Symbol">(</a><a id="31627" href="plfa.part1.Connectives.html#31595" class="Bound">B</a> <a id="31629" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="31631" href="plfa.part1.Connectives.html#31597" class="Bound">C</a><a id="31632" class="Symbol">)</a>
</pre>
<!-- This is called a _weak distributive law_. Give the corresponding
distributive law, and explain how it relates to the weak version. -->

<p>这被称为<em>弱分配律</em>。给出相对应的分配律，并解释分配律与弱分配律的关系。</p>

<!-- <pre class="Agda"><a id="31842" class="Comment">-- Your code goes here</a>
</pre>{:/}

<pre class="Agda"><a id="31879" class="Comment">-- 请将代码写在此处。</a>
</pre>

{::comment}
#### Exercise `⊎×-implies-×⊎` (practice) -->

<h4 id="练习--implies-实践">练习 <code class="language-plaintext highlighter-rouge">⊎×-implies-×⊎</code>（实践）</h4>

<!-- Show that a disjunct of conjuncts implies a conjunct of disjuncts: -->

<p>证明合取的析取蕴涵了析取的合取：</p>

<pre class="Agda"><a id="32093" class="Keyword">postulate</a>
  <a id="⊎×-implies-×⊎"></a><a id="32105" href="/PLFA-zh/Connectives/#32105" class="Postulate">⊎×-implies-×⊎</a> <a id="32119" class="Symbol">:</a> <a id="32121" class="Symbol">∀</a> <a id="32123" class="Symbol">{</a><a id="32124" href="plfa.part1.Connectives.html#32124" class="Bound">A</a> <a id="32126" href="plfa.part1.Connectives.html#32126" class="Bound">B</a> <a id="32128" href="plfa.part1.Connectives.html#32128" class="Bound">C</a> <a id="32130" href="plfa.part1.Connectives.html#32130" class="Bound">D</a> <a id="32132" class="Symbol">:</a> <a id="32134" class="PrimitiveType">Set</a><a id="32137" class="Symbol">}</a> <a id="32139" class="Symbol">→</a> <a id="32141" class="Symbol">(</a><a id="32142" href="plfa.part1.Connectives.html#32124" class="Bound">A</a> <a id="32144" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="32146" href="plfa.part1.Connectives.html#32126" class="Bound">B</a><a id="32147" class="Symbol">)</a> <a id="32149" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="32151" class="Symbol">(</a><a id="32152" href="plfa.part1.Connectives.html#32128" class="Bound">C</a> <a id="32154" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="32156" href="plfa.part1.Connectives.html#32130" class="Bound">D</a><a id="32157" class="Symbol">)</a> <a id="32159" class="Symbol">→</a> <a id="32161" class="Symbol">(</a><a id="32162" href="plfa.part1.Connectives.html#32124" class="Bound">A</a> <a id="32164" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="32166" href="plfa.part1.Connectives.html#32128" class="Bound">C</a><a id="32167" class="Symbol">)</a> <a id="32169" href="plfa.part1.Connectives.html#1738" class="Datatype Operator">×</a> <a id="32171" class="Symbol">(</a><a id="32172" href="plfa.part1.Connectives.html#32126" class="Bound">B</a> <a id="32174" href="plfa.part1.Connectives.html#14068" class="Datatype Operator">⊎</a> <a id="32176" href="plfa.part1.Connectives.html#32130" class="Bound">D</a><a id="32177" class="Symbol">)</a>
</pre>
<!-- Does the converse hold? If so, prove; if not, give a counterexample. -->

<p>反命题成立吗？如果成立，给出证明；如果不成立，给出反例。</p>

<!-- <pre class="Agda"><a id="32317" class="Comment">-- Your code goes here</a>
</pre>{:/}

<pre class="Agda"><a id="32354" class="Comment">-- 请将代码写在此处。</a>
</pre>
{::comment}
## Standard library -->

<h2 id="标准库">标准库</h2>

<!-- Definitions similar to those in this chapter can be found in the standard library: -->

<p>标准库中可以找到与本章节中相似的定义：</p>

<pre class="Agda"><a id="32544" class="Keyword">import</a> <a id="32551" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html" class="Module">Data.Product</a> <a id="32564" class="Keyword">using</a> <a id="32570" class="Symbol">(</a><a id="32571" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">_×_</a><a id="32574" class="Symbol">;</a> <a id="32576" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a><a id="32581" class="Symbol">;</a> <a id="32583" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a><a id="32588" class="Symbol">)</a> <a id="32590" class="Keyword">renaming</a> <a id="32599" class="Symbol">(</a><a id="32600" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a> <a id="32604" class="Symbol">to</a> <a id="32607" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="32612" class="Symbol">)</a>
<a id="32614" class="Keyword">import</a> <a id="32621" href="https://agda.github.io/agda-stdlib/v1.1/Data.Unit.html" class="Module">Data.Unit</a> <a id="32631" class="Keyword">using</a> <a id="32637" class="Symbol">(</a><a id="32638" href="Agda.Builtin.Unit.html#137" class="Record">⊤</a><a id="32639" class="Symbol">;</a> <a id="32641" href="Agda.Builtin.Unit.html#174" class="InductiveConstructor">tt</a><a id="32643" class="Symbol">)</a>
<a id="32645" class="Keyword">import</a> <a id="32652" href="https://agda.github.io/agda-stdlib/v1.1/Data.Sum.html" class="Module">Data.Sum</a> <a id="32661" class="Keyword">using</a> <a id="32667" class="Symbol">(</a><a id="32668" href="https://agda.github.io/agda-stdlib/v1.1/Data.Sum.Base.html#612" class="Datatype Operator">_⊎_</a><a id="32671" class="Symbol">;</a> <a id="32673" href="https://agda.github.io/agda-stdlib/v1.1/Data.Sum.Base.html#662" class="InductiveConstructor">inj₁</a><a id="32677" class="Symbol">;</a> <a id="32679" href="https://agda.github.io/agda-stdlib/v1.1/Data.Sum.Base.html#687" class="InductiveConstructor">inj₂</a><a id="32683" class="Symbol">)</a> <a id="32685" class="Keyword">renaming</a> <a id="32694" class="Symbol">(</a><a id="32695" href="https://agda.github.io/agda-stdlib/v1.1/Data.Sum.Base.html#798" class="Function Operator">[_,_]</a> <a id="32701" class="Symbol">to</a> <a id="32704" href="https://agda.github.io/agda-stdlib/v1.1/Data.Sum.Base.html#798" class="Function Operator">case-⊎</a><a id="32710" class="Symbol">)</a>
<a id="32712" class="Keyword">import</a> <a id="32719" href="https://agda.github.io/agda-stdlib/v1.1/Data.Empty.html" class="Module">Data.Empty</a> <a id="32730" class="Keyword">using</a> <a id="32736" class="Symbol">(</a><a id="32737" href="https://agda.github.io/agda-stdlib/v1.1/Data.Empty.html#279" class="Datatype">⊥</a><a id="32738" class="Symbol">;</a> <a id="32740" href="https://agda.github.io/agda-stdlib/v1.1/Data.Empty.html#294" class="Function">⊥-elim</a><a id="32746" class="Symbol">)</a>
<a id="32748" class="Keyword">import</a> <a id="32755" href="https://agda.github.io/agda-stdlib/v1.1/Function.Equivalence.html" class="Module">Function.Equivalence</a> <a id="32776" class="Keyword">using</a> <a id="32782" class="Symbol">(</a><a id="32783" href="https://agda.github.io/agda-stdlib/v1.1/Function.Equivalence.html#971" class="Function Operator">_⇔_</a><a id="32786" class="Symbol">)</a>
</pre>
<!-- The standard library constructs pairs with `_,_` whereas we use `⟨_,_⟩`.
The former makes it convenient to build triples or larger tuples from pairs,
permitting `a , b , c` to stand for `(a , (b , c))`.  But it conflicts with
other useful notations, such as `[_,_]` to construct a list of two elements in
Chapter [Lists](/PLFA-zh/Lists/)
and `Γ , A` to extend environments in
Chapter [DeBruijn](/PLFA-zh/DeBruijn/).
The standard library `_⇔_` is similar to ours, but the one in the
standard library is less convenient, since it is parameterised with
respect to an arbitrary notion of equivalence. -->

<p>标准库中使用 <code class="language-plaintext highlighter-rouge">_,_</code> 构造数据对，而我们使用 <code class="language-plaintext highlighter-rouge">⟨_,_⟩</code>。前者在从数据对构造三元对或者更大的元组时更加的方便，允许 <code class="language-plaintext highlighter-rouge">a , b , c</code> 作为 <code class="language-plaintext highlighter-rouge">(a, (b , c))</code> 的记法。但它与其他有用的记法相冲突，比如说 [Lists][plfa.Lists] 中的 <code class="language-plaintext highlighter-rouge">[_,_]</code> 记法表示两个元素的列表，或者 [DeBruijn][plfa.DeBruijn] 章节中的 <code class="language-plaintext highlighter-rouge">Γ , A</code> 来表示环境的扩展。标准库中的 <code class="language-plaintext highlighter-rouge">_⇔_</code> 和我们的相似，但使用起来比较不便，因为它可以根据任意的相等性定义进行参数化。</p>

<h2 id="unicode">Unicode</h2>

<!-- This chapter uses the following unicode:

    ×  U+00D7  MULTIPLICATION SIGN (\x)
    ⊎  U+228E  MULTISET UNION (\u+)
    ⊤  U+22A4  DOWN TACK (\top)
    ⊥  U+22A5  UP TACK (\bot)
    η  U+03B7  GREEK SMALL LETTER ETA (\eta)
    ₁  U+2081  SUBSCRIPT ONE (\_1)
    ₂  U+2082  SUBSCRIPT TWO (\_2)
    ⇔  U+21D4  LEFT RIGHT DOUBLE ARROW (\<=>) -->

<p>本章节使用下列 Unicode：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>×  U+00D7  乘法符号 (\x)
⊎  U+228E  多重集并集 (\u+)
⊤  U+22A4  向下图钉 (\top)
⊥  U+22A5  向上图钉 (\bot)
η  U+03B7  希腊小写字母 ETA (\eta)
₁  U+2081  下标 1 (\_1)
₂  U+2082  下标 2 (\_2)
⇔  U+21D4  左右双箭头 (\&lt;=&gt;)
</code></pre></div></div>

  </div>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/PLFA-zh/Isomorphism/">上一章</a>
    
    
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/Agda-zh/PLFA-zh/blob/dev/src/plfa/part1/Connectives.lagda.md">源代码</a>
    
    
    &bullet;
    
    
    <a alt="Next chapter" href="/PLFA-zh/Negation/">下一章</a>
    
</p>


</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/PLFA-zh/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">编程语言基础：Agda 语言描述
</h2>

    <h3 class="footer-heading">原作者：</h3><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li>
          <li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li>
          <li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Jeremy Siek</li>
          <li><a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jsiek"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jsiek</span></a></li><li><a href="https://www.twitter.com/jeremysiek"><svg class="svg-icon"><use xlink:href="/PLFA-zh/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jeremysiek</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><h3 class="footer-heading">本章翻译进度：100%</h3>
        <h3 class="footer-heading">本章译者：</h3>
        <p>Fangyi Zhou</p>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">创作共用-署名 4.0 国际（CC BY 4.0）许可协议</a>授权。<br />
  </div>
</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/PLFA-zh/assets/jquery.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha256-E4RlfxwyJVmkkk0szw7LYJxuPlp6evtPSBDlWHsYYL8=" crossorigin="anonymous"></script>
<script type="text/javascript">
  anchors.add();
</script>

<script type="text/javascript">

 // Makes sandwhich menu works
 $('.menu-icon').click(function(){
   $('.trigger').toggle();
 });

 // Script which allows for foldable code blocks
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/PLFA-zh/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
